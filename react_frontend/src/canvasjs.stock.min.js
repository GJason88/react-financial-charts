/*
 CanvasJS HTML5 & JavaScript StockCharts - v1.0.5 GA - https://canvasjs.com/ 
 Copyright 2020 fenopix

  --------------------- License Information --------------------
 CanvasJS is a commercial product which requires purchase of license. Without a commercial license you can use it for evaluation purposes for upto 30 days. Please refer to the following link for further details.
     https://canvasjs.com/license/

*/
/*eslint-disable*/
/*jshint ignore:start*/
(function () {
  function V(m, n) { m.prototype = qb(n.prototype); m.prototype.constructor = m; m.base = n.prototype } function qb(m) { function n() { } n.prototype = m; return new n } function cb(m, n, aa) {
    "millisecond" === aa ? m.setMilliseconds(m.getMilliseconds() + 1 * n) : "second" === aa ? m.setSeconds(m.getSeconds() + 1 * n) : "minute" === aa ? m.setMinutes(m.getMinutes() + 1 * n) : "hour" === aa ? m.setHours(m.getHours() + 1 * n) : "day" === aa ? m.setDate(m.getDate() + 1 * n) : "week" === aa ? m.setDate(m.getDate() + 7 * n) : "month" === aa ? m.setMonth(m.getMonth() + 1 * n) : "year" ===
      aa && m.setFullYear(m.getFullYear() + 1 * n); return m
  } function na(m, n) { var aa = !1; 0 > m && (aa = !0, m *= -1); m = "" + m; for (n = n ? n : 1; m.length < n;)m = "0" + m; return aa ? "-" + m : m } function Pa(m) { if (!m) return m; m = m.replace(/^\s\s*/, ""); for (var n = /\s/, aa = m.length; n.test(m.charAt(--aa));); return m.slice(0, aa + 1) } function Ha(m) {
    m.roundRect = function (m, aa, h, s, H, B, w, y) {
      w && (this.fillStyle = w); y && (this.strokeStyle = y); "undefined" === typeof H && (H = 5); this.lineWidth = B; this.beginPath(); this.moveTo(m + H, aa); this.lineTo(m + h - H, aa); this.quadraticCurveTo(m +
        h, aa, m + h, aa + H); this.lineTo(m + h, aa + s - H); this.quadraticCurveTo(m + h, aa + s, m + h - H, aa + s); this.lineTo(m + H, aa + s); this.quadraticCurveTo(m, aa + s, m, aa + s - H); this.lineTo(m, aa + H); this.quadraticCurveTo(m, aa, m + H, aa); this.closePath(); w && this.fill(); y && 0 < B && this.stroke()
    }
  } function Xa(m, n) { return m - n } function eb(m, n, h) {
    if (m && n && h) {
      h = h + "." + n; var s = "image/" + n; m = m.toDataURL(s); var db = !1, H = document.createElement("a"); H.download = h; H.href = m; if ("undefined" !== typeof Blob && new Blob) {
        for (var B = m.replace(/^data:[a-z\/]*;base64,/,
          ""), B = atob(B), w = new ArrayBuffer(B.length), w = new Uint8Array(w), y = 0; y < B.length; y++)w[y] = B.charCodeAt(y); n = new Blob([w.buffer], { type: "image/" + n }); try { window.navigator.msSaveBlob(n, h), db = !0 } catch (M) { H.dataset.downloadurl = [s, H.download, H.href].join(":"), H.href = window.URL.createObjectURL(n) }
      } if (!db) try { event = document.createEvent("MouseEvents"), event.initMouseEvent("click", !0, !1, window, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null), H.dispatchEvent ? H.dispatchEvent(event) : H.fireEvent && H.fireEvent("onclick") } catch (D) {
        n = window.open(),
          n.document.write("<img src='" + m + "'></img><div>Please right click on the image and save it to your device</div>"), n.document.close()
      }
    }
  } function Q(m) { var n = ((m & 16711680) >> 16).toString(16), h = ((m & 65280) >> 8).toString(16); m = ((m & 255) >> 0).toString(16); n = 2 > n.length ? "0" + n : n; h = 2 > h.length ? "0" + h : h; m = 2 > m.length ? "0" + m : m; return "#" + n + h + m } function rb(m, n) { var h = this.length >>> 0, s = Number(n) || 0, s = 0 > s ? Math.ceil(s) : Math.floor(s); for (0 > s && (s += h); s < h; s++)if (s in this && this[s] === m) return s; return -1 } function h(m) {
    return null ===
      m || "undefined" === typeof m
  } function Ea(m) { m.indexOf || (m.indexOf = rb); return m } function sb(m) { if (fa.fSDec) m[sa("`eeDwdouMhrudods")](sa("e`u`@ohl`uhnoHuds`uhnoDoe"), function () { fa._fTWm && fa._fTWm(m) }) } function fb(m, n, h) {
    h = h || "normal"; var s = m + "_" + n + "_" + h, w = gb[s]; if (isNaN(w)) {
      try {
        m = "position:absolute; left:0px; top:-20000px; padding:0px;margin:0px;border:none;white-space:pre;line-height:normal;font-family:" + m + "; font-size:" + n + "px; font-weight:" + h + ";"; if (!Fa) {
          var H = document.body; Fa = document.createElement("span");
          Fa.innerHTML = ""; var B = document.createTextNode("Mpgyi"); Fa.appendChild(B); H.appendChild(Fa)
        } Fa.style.display = ""; Fa.setAttribute("style", m); w = Math.round(Fa.offsetHeight); Fa.style.display = "none"
      } catch (y) { w = Math.ceil(1.1 * n) } w = Math.max(w, n); gb[s] = w
    } return w
  } function R(m, n) {
    var h = []; if (h = { solid: [], shortDash: [3, 1], shortDot: [1, 1], shortDashDot: [3, 1, 1, 1], shortDashDotDot: [3, 1, 1, 1, 1, 1], dot: [1, 2], dash: [4, 2], dashDot: [4, 2, 1, 2], longDash: [8, 2], longDashDot: [8, 2, 1, 2], longDashDotDot: [8, 2, 1, 2, 1, 2] }[m || "solid"]) for (var s =
      0; s < h.length; s++)h[s] *= n; else h = []; return h
  } function y(m, n, h, s, w) { s = s || []; w = w || !1; s.push([m, n, h, w]); return m.addEventListener ? (m.addEventListener(n, h, w), h) : m.attachEvent ? (s = function (n) { n = n || window.event; n.preventDefault = n.preventDefault || function () { n.returnValue = !1 }; n.stopPropagation = n.stopPropagation || function () { n.cancelBubble = !0 }; h.call(m, n) }, m.attachEvent("on" + n, s), s) : !1 } function hb(m, n, h, s) {
    s = s || !1; if (m.removeEventListener) m.removeEventListener(n, h, s); else if (m.detachEvent) m.detachEvent("on" +
      n, h); else return !1
  } function ib(m) {
    if (m._menuButton) m.exportEnabled ? Sa(m._menuButton) : ya(m._menuButton); else if (m.exportEnabled && s) {
      var n = !1; m._menuButton = document.createElement("button"); Ba(m, m._menuButton, "menu"); m._toolBar.appendChild(m._menuButton); y(m._menuButton, "touchstart", function (m) { n = !0 }, m.allDOMEventHandlers); y(m._menuButton, "click", function () {
        "none" !== m._dropdownMenu.style.display || m._dropDownCloseTime && 500 >= (new Date).getTime() - m._dropDownCloseTime.getTime() || (m._dropdownMenu.style.display =
          "block", m._menuButton.blur(), m._dropdownMenu.focus())
      }, m.allDOMEventHandlers, !0); y(m._menuButton, "mouseover", function () { n || (ua(m, m._menuButton, { backgroundColor: m.toolbar.backgroundColorOnHover, color: m.toolbar.fontColorOnHover }), 0 >= navigator.userAgent.search("MSIE") && ua(m, m._menuButton.childNodes[0], { WebkitFilter: "invert(100%)", filter: "invert(100%)" })) }, m.allDOMEventHandlers, !0); y(m._menuButton, "mouseout", function () {
        n || (ua(m, m._menuButton, { backgroundColor: m.toolbar.backgroundColor, color: m.toolbar.fontColor }),
          0 >= navigator.userAgent.search("MSIE") && ua(m, m._menuButton.childNodes[0], { WebkitFilter: "invert(0%)", filter: "invert(0%)" }))
      }, m.allDOMEventHandlers, !0)
    } if (!m._dropdownMenu && m.exportEnabled && s) {
      n = !1; m._dropdownMenu = document.createElement("div"); m._dropdownMenu.setAttribute("tabindex", -1); var h = -1 !== m.theme.indexOf("dark") ? "black" : "#888888"; m._dropdownMenu.style.cssText = "position: absolute; z-index: 1; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; cursor: pointer;right: 0px;top: 25px;min-width: 120px;outline: 0;font-size: 14px; font-family: Arial, Helvetica, sans-serif;padding: 5px 0px 5px 0px;text-align: left;line-height: 10px;background-color:" +
        m.toolbar.backgroundColor + ";box-shadow: 2px 2px 10px " + h; m._dropdownMenu.style.display = "none"; m._toolBar.appendChild(m._dropdownMenu); y(m._dropdownMenu, "blur", function () { ya(m._dropdownMenu); m._dropDownCloseTime = new Date }, m.allDOMEventHandlers, !0); h = document.createElement("div"); h.style.cssText = "padding: 12px 8px 12px 8px"; h.innerHTML = m._cultureInfo.printText; h.style.backgroundColor = m.toolbar.backgroundColor; h.style.color = m.toolbar.fontColor; m._dropdownMenu.appendChild(h); y(h, "touchstart", function (m) {
          n =
            !0
        }, m.allDOMEventHandlers); y(h, "mouseover", function () { n || (this.style.backgroundColor = m.toolbar.backgroundColorOnHover, this.style.color = m.toolbar.fontColorOnHover) }, m.allDOMEventHandlers, !0); y(h, "mouseout", function () { n || (this.style.backgroundColor = m.toolbar.backgroundColor, this.style.color = m.toolbar.fontColor) }, m.allDOMEventHandlers, !0); y(h, "click", function () { m.print(); ya(m._dropdownMenu) }, m.allDOMEventHandlers, !0); h = document.createElement("div"); h.style.cssText = "padding: 12px 8px 12px 8px"; h.innerHTML =
          m._cultureInfo.saveJPGText; h.style.backgroundColor = m.toolbar.backgroundColor; h.style.color = m.toolbar.fontColor; m._dropdownMenu.appendChild(h); y(h, "touchstart", function (m) { n = !0 }, m.allDOMEventHandlers); y(h, "mouseover", function () { n || (this.style.backgroundColor = m.toolbar.backgroundColorOnHover, this.style.color = m.toolbar.fontColorOnHover) }, m.allDOMEventHandlers, !0); y(h, "mouseout", function () { n || (this.style.backgroundColor = m.toolbar.backgroundColor, this.style.color = m.toolbar.fontColor) }, m.allDOMEventHandlers,
            !0); y(h, "click", function () { m.exportChart({ format: "jpeg", fileName: m.exportFileName }); ya(m._dropdownMenu) }, m.allDOMEventHandlers, !0); h = document.createElement("div"); h.style.cssText = "padding: 12px 8px 12px 8px"; h.innerHTML = m._cultureInfo.savePNGText; h.style.backgroundColor = m.toolbar.backgroundColor; h.style.color = m.toolbar.fontColor; m._dropdownMenu.appendChild(h); y(h, "touchstart", function (m) { n = !0 }, m.allDOMEventHandlers); y(h, "mouseover", function () {
              n || (this.style.backgroundColor = m.toolbar.backgroundColorOnHover,
                this.style.color = m.toolbar.fontColorOnHover)
            }, m.allDOMEventHandlers, !0); y(h, "mouseout", function () { n || (this.style.backgroundColor = m.toolbar.backgroundColor, this.style.color = m.toolbar.fontColor) }, m.allDOMEventHandlers, !0); y(h, "click", function () { m.exportChart({ format: "png", fileName: m.exportFileName }); ya(m._dropdownMenu) }, m.allDOMEventHandlers, !0)
    }
  } function jb(m, n, h) {
    m *= ga; n *= ga; m = h.getImageData(m, n, 2, 2).data; n = !0; for (h = 0; 4 > h; h++)if (m[h] !== m[h + 4] | m[h] !== m[h + 8] | m[h] !== m[h + 12]) { n = !1; break } return n ? m[0] <<
      16 | m[1] << 8 | m[2] : 0
  } function oa(m, n, h) { return m in n ? n[m] : h[m] } function Ta(m, n, h) { if (s && kb) { var ba = m.getContext("2d"); Ua = ba.webkitBackingStorePixelRatio || ba.mozBackingStorePixelRatio || ba.msBackingStorePixelRatio || ba.oBackingStorePixelRatio || ba.backingStorePixelRatio || 1; ga = Ya / Ua; m.width = n * ga; m.height = h * ga; Ya !== Ua && (m.style.width = n + "px", m.style.height = h + "px", ba.scale(ga, ga)) } else m.width = n, m.height = h } function tb(m) {
    if (!ub) {
      var n = !1, h = !1; "undefined" === typeof Y.Chart.creditHref ? (m.creditHref = sa("iuuqr;..b`ow`rkr/bnl."),
        m.creditText = sa("B`ow`rKR/bnl")) : (n = m.updateOption("creditText"), h = m.updateOption("creditHref")); if (m.creditHref && m.creditText) {
          m._creditLink || (m._creditLink = document.createElement("a"), m._creditLink.setAttribute("class", "canvasjs-chart-credit"), m._creditLink.setAttribute("title", "JavaScript Charts"), m._creditLink.setAttribute("style", "outline:none;margin:0px;position:absolute;right:2px;top:" + (m.height - 14) + "px;color:dimgrey;text-decoration:none;font-size:11px;font-family: Calibri, Lucida Grande, Lucida Sans Unicode, Arial, sans-serif"),
            m._creditLink.setAttribute("tabIndex", -1), m._creditLink.setAttribute("target", "_blank")); if (0 === m.renderCount || n || h) m._creditLink.setAttribute("href", m.creditHref), m._creditLink.innerHTML = m.creditText; m._creditLink && m.creditHref && m.creditText ? (m._creditLink.parentElement || m._canvasJSContainer.appendChild(m._creditLink), m._creditLink.style.top = m.height - 14 + "px") : m._creditLink.parentElement && m._canvasJSContainer.removeChild(m._creditLink)
        }
    }
  } function pa(m, n) {
    Ma && (this.canvasCount |= 0, window.console.log(++this.canvasCount));
    var h = document.createElement("canvas"); h.setAttribute("class", "canvasjs-chart-canvas"); Ta(h, m, n); s || "undefined" === typeof G_vmlCanvasManager || G_vmlCanvasManager.initElement(h); return h
  } function ua(m, n, h) { for (var s in h) n.style[s] = h[s] } function Ba(m, n, h) {
    n.getAttribute("state") || (n.style.backgroundColor = m.toolbar.backgroundColor, n.style.color = m.toolbar.fontColor, n.style.border = "none", ua(m, n, { WebkitUserSelect: "none", MozUserSelect: "none", msUserSelect: "none", userSelect: "none" })); n.getAttribute("state") !==
      h && (n.setAttribute("state", h), n.setAttribute("type", "button"), ua(m, n, { padding: "5px 12px", cursor: "pointer", "float": "left", width: "40px", height: "25px", outline: "0px", verticalAlign: "baseline", lineHeight: "0" }), n.setAttribute("title", m._cultureInfo[h + "Text"]), n.innerHTML = "<img style='height:95%; pointer-events: none;' src='" + vb[h].image + "' alt='" + m._cultureInfo[h + "Text"] + "' />")
  } function Sa() { for (var m = null, n = 0; n < arguments.length; n++)m = arguments[n], m.style && (m.style.display = "inline") } function ya() {
    for (var m =
      null, n = 0; n < arguments.length; n++)(m = arguments[n]) && m.style && (m.style.display = "none")
  } function Za(m) { if (null === m || "object" !== typeof m) return m; if (m instanceof Date) return new Date(m.getTime()); Array.isArray || (Array.isArray = function (m) { return "[object Array]" === Object.prototype.toString.call(m) }); if (Array.isArray(m)) { for (var n = [], h = 0; h < m.length; h++)n.push(Za(m[h])); return n } n = new m.constructor; for (h in m) m.hasOwnProperty(h) && (n[h] = Za(m[h])); return n } function Va(m, n, h, s, w) {
    if (null === m || "undefined" === typeof m) return "undefined" ===
      typeof h ? n : h; m = parseFloat(m.toString()) * (0 <= m.toString().indexOf("%") ? n / 100 : 1); "undefined" !== typeof s && (m = Math.min(s, m), "undefined" !== typeof w && (m = Math.max(w, m))); return !isNaN(m) && m <= n && 0 <= m ? m : "undefined" === typeof h ? n : h
  } function K(m, n, s, ba, w) {
    this._defaultsKey = m; this._themeOptionsKey = n; this._index = ba; this.parent = w; this._eventListeners = []; m = {}; this.theme && h(this.parent) && h(n) && h(ba) ? m = h(this.predefinedThemes[this.theme]) ? this.predefinedThemes.light1 : this.predefinedThemes[this.theme] : this.parent && (this.parent.themeOptions &&
      this.parent.themeOptions[n]) && (null === ba ? m = this.parent.themeOptions[n] : 0 < this.parent.themeOptions[n].length && (ba = Math.min(this.parent.themeOptions[n].length - 1, ba), m = this.parent.themeOptions[n][ba])); this.themeOptions = m; this.options = s ? s : { _isPlaceholder: !0 }; this.setOptions(this.options, m)
  } function La(m, n, h, s, w) { "undefined" === typeof w && (w = 0); this._padding = w; this._x1 = m; this._y1 = n; this._x2 = h; this._y2 = s; this._rightOccupied = this._leftOccupied = this._bottomOccupied = this._topOccupied = this._padding } function ja(m,
    n) { ja.base.constructor.call(this, "TextBlock", null, n, null, null); this.ctx = m; this._isDirty = !0; this._wrappedText = null; this._initialize() } function Wa(m, n) { Wa.base.constructor.call(this, "Toolbar", "toolbar", n, null, m); this.chart = m; this.canvas = m.canvas; this.ctx = this.chart.ctx; this.optionsName = "toolbar" } function Ia(m, n) {
      Ia.base.constructor.call(this, "Title", "title", n, null, m); this.chart = m; this.canvas = m.canvas; this.ctx = this.chart.ctx; this.optionsName = "title"; if (h(this.options.margin) && m.options.subtitles) for (var s =
        m.options.subtitles, ba = 0; ba < s.length; ba++)if ((h(s[ba].horizontalAlign) && "center" === this.horizontalAlign || s[ba].horizontalAlign === this.horizontalAlign) && (h(s[ba].verticalAlign) && "top" === this.verticalAlign || s[ba].verticalAlign === this.verticalAlign) && !s[ba].dockInsidePlotArea === !this.dockInsidePlotArea) { this.margin = 0; break } "undefined" === typeof this.options.fontSize && (this.fontSize = this.chart.getAutoFontSize(this.fontSize)); this.height = this.width = null; this.bounds = { x1: null, y1: null, x2: null, y2: null }
    } function Na(m,
      n, h) { Na.base.constructor.call(this, "Subtitle", "subtitles", n, h, m); this.chart = m; this.canvas = m.canvas; this.ctx = this.chart.ctx; this.optionsName = "subtitles"; this.isOptionsInArray = !0; "undefined" === typeof this.options.fontSize && (this.fontSize = this.chart.getAutoFontSize(this.fontSize)); this.height = this.width = null; this.bounds = { x1: null, y1: null, x2: null, y2: null } } function $a() { this.pool = [] } function Oa(m) { var n; m && Qa[m] && (n = Qa[m]); Oa.base.constructor.call(this, "CultureInfo", null, n, null, null) } var Ma = !1, fa = {}, s =
        !!document.createElement("canvas").getContext, Y = {
          Chart: {
            width: 500, height: 400, zoomEnabled: !1, zoomType: "x", backgroundColor: "white", theme: "light1", animationEnabled: !1, animationDuration: 1200, dataPointWidth: null, dataPointMinWidth: null, dataPointMaxWidth: null, colorSet: "colorSet1", culture: "en", creditHref: "", creditText: "CanvasJS", interactivityEnabled: !0, exportEnabled: !1, exportFileName: "Chart", rangeChanging: null, rangeChanged: null, publicProperties: {
              title: "readWrite", subtitles: "readWrite", toolbar: "readWrite",
              toolTip: "readWrite", legend: "readWrite", axisX: "readWrite", axisY: "readWrite", axisX2: "readWrite", axisY2: "readWrite", data: "readWrite", options: "readWrite", bounds: "readOnly", container: "readOnly"
            }
          }, Title: {
            padding: 0, text: null, verticalAlign: "top", horizontalAlign: "center", fontSize: 20, fontFamily: "Calibri", fontWeight: "normal", fontColor: "black", fontStyle: "normal", borderThickness: 0, borderColor: "black", cornerRadius: 0, backgroundColor: s ? "transparent" : null, margin: 5, wrap: !0, maxWidth: null, dockInsidePlotArea: !1, publicProperties: {
              options: "readWrite",
              bounds: "readOnly", chart: "readOnly"
            }
          }, Subtitle: { padding: 0, text: null, verticalAlign: "top", horizontalAlign: "center", fontSize: 14, fontFamily: "Calibri", fontWeight: "normal", fontColor: "black", fontStyle: "normal", borderThickness: 0, borderColor: "black", cornerRadius: 0, backgroundColor: null, margin: 2, wrap: !0, maxWidth: null, dockInsidePlotArea: !1, publicProperties: { options: "readWrite", bounds: "readOnly", chart: "readOnly" } }, Toolbar: {
            backgroundColor: "white", backgroundColorOnHover: "#2196f3", borderColor: "#2196f3", borderThickness: 1,
            fontColor: "black", fontColorOnHover: "white", publicProperties: { options: "readWrite", chart: "readOnly" }
          }, Legend: {
            name: null, verticalAlign: "center", horizontalAlign: "right", fontSize: 14, fontFamily: "calibri", fontWeight: "normal", fontColor: "black", fontStyle: "normal", cursor: null, itemmouseover: null, itemmouseout: null, itemmousemove: null, itemclick: null, dockInsidePlotArea: !1, reversed: !1, backgroundColor: s ? "transparent" : null, borderColor: s ? "transparent" : null, borderThickness: 0, cornerRadius: 0, maxWidth: null, maxHeight: null,
            markerMargin: null, itemMaxWidth: null, itemWidth: null, itemWrap: !0, itemTextFormatter: null, publicProperties: { options: "readWrite", bounds: "readOnly", chart: "readOnly" }
          }, ToolTip: {
            enabled: !0, shared: !1, animationEnabled: !0, content: null, contentFormatter: null, reversed: !1, backgroundColor: s ? "rgba(255,255,255,.9)" : "rgb(255,255,255)", borderColor: null, borderThickness: 2, cornerRadius: 5, fontSize: 14, fontColor: "black", fontFamily: "Calibri, Arial, Georgia, serif;", fontWeight: "normal", fontStyle: "italic", updated: null, hidden: null,
            publicProperties: { options: "readWrite", chart: "readOnly" }
          }, Axis: {
            minimum: null, maximum: null, viewportMinimum: null, viewportMaximum: null, interval: null, intervalType: null, reversed: !1, logarithmic: !1, logarithmBase: 10, title: null, titleFontColor: "black", titleFontSize: 20, titleFontFamily: "arial", titleFontWeight: "normal", titleFontStyle: "normal", titleWrap: !0, titleMaxWidth: null, titleBackgroundColor: s ? "transparent" : null, titleBorderColor: s ? "transparent" : null, titleBorderThickness: 0, titleCornerRadius: 0, labelAngle: 0, labelFontFamily: "arial",
            labelFontColor: "black", labelFontSize: 12, labelFontWeight: "normal", labelFontStyle: "normal", labelAutoFit: !0, labelWrap: !0, labelMaxWidth: null, labelFormatter: null, labelBackgroundColor: s ? "transparent" : null, labelBorderColor: s ? "transparent" : null, labelBorderThickness: 0, labelCornerRadius: 0, labelPlacement: "outside", prefix: "", suffix: "", includeZero: !1, tickLength: 5, tickColor: "black", tickThickness: 1, tickPlacement: "outside", lineColor: "black", lineThickness: 1, lineDashType: "solid", gridColor: "#A0A0A0", gridThickness: 0,
            gridDashType: "solid", interlacedColor: s ? "transparent" : null, valueFormatString: null, margin: 2, publicProperties: { options: "readWrite", stripLines: "readWrite", scaleBreaks: "readWrite", crosshair: "readWrite", bounds: "readOnly", chart: "readOnly" }
          }, StripLine: {
            value: null, startValue: null, endValue: null, color: "orange", opacity: null, thickness: 2, lineDashType: "solid", label: "", labelPlacement: "inside", labelAlign: "far", labelWrap: !0, labelMaxWidth: null, labelBackgroundColor: null, labelBorderColor: s ? "transparent" : null, labelBorderThickness: 0,
            labelCornerRadius: 0, labelFontFamily: "arial", labelFontColor: "orange", labelFontSize: 12, labelFontWeight: "normal", labelFontStyle: "normal", labelFormatter: null, showOnTop: !1, publicProperties: { options: "readWrite", axis: "readOnly", bounds: "readOnly", chart: "readOnly" }
          }, ScaleBreaks: {
            autoCalculate: !1, collapsibleThreshold: "25%", maxNumberOfAutoBreaks: 2, spacing: 8, type: "straight", color: "#FFFFFF", fillOpacity: 0.9, lineThickness: 2, lineColor: "#E16E6E", lineDashType: "solid", publicProperties: {
              options: "readWrite", customBreaks: "readWrite",
              axis: "readOnly", autoBreaks: "readOnly", bounds: "readOnly", chart: "readOnly"
            }
          }, Break: { startValue: null, endValue: null, spacing: 8, type: "straight", color: "#FFFFFF", fillOpacity: 0.9, lineThickness: 2, lineColor: "#E16E6E", lineDashType: "solid", publicProperties: { options: "readWrite", scaleBreaks: "readOnly", bounds: "readOnly", chart: "readOnly" } }, Crosshair: {
            enabled: !1, snapToDataPoint: !1, color: "grey", opacity: null, thickness: 2, lineDashType: "solid", label: "", labelWrap: !0, labelMaxWidth: null, labelBackgroundColor: s ? "grey" : null,
            labelBorderColor: s ? "grey" : null, labelBorderThickness: 0, labelCornerRadius: 0, labelFontFamily: s ? "Calibri, Optima, Candara, Verdana, Geneva, sans-serif" : "calibri", labelFontSize: 12, labelFontColor: "#fff", labelFontWeight: "normal", labelFontStyle: "normal", labelFormatter: null, valueFormatString: null, updated: null, hidden: null, publicProperties: { options: "readWrite", axis: "readOnly", bounds: "readOnly", chart: "readOnly" }
          }, DataSeries: {
            name: null, dataPoints: null, label: "", bevelEnabled: !1, highlightEnabled: !0, cursor: "default",
            indexLabel: "", indexLabelPlacement: "auto", indexLabelOrientation: "horizontal", indexLabelFontColor: "black", indexLabelFontSize: 12, indexLabelFontStyle: "normal", indexLabelFontFamily: "Arial", indexLabelFontWeight: "normal", indexLabelBackgroundColor: null, indexLabelLineColor: "gray", indexLabelLineThickness: 1, indexLabelLineDashType: "solid", indexLabelMaxWidth: null, indexLabelWrap: !0, indexLabelFormatter: null, lineThickness: 2, lineDashType: "solid", connectNullData: !1, nullDataLineDashType: "dash", color: null, lineColor: null,
            risingColor: "white", fallingColor: "red", fillOpacity: null, startAngle: 0, radius: null, innerRadius: null, neckHeight: null, neckWidth: null, reversed: !1, valueRepresents: null, linkedDataSeriesIndex: null, whiskerThickness: 2, whiskerDashType: "solid", whiskerColor: null, whiskerLength: null, stemThickness: 2, stemColor: null, stemDashType: "solid", upperBoxColor: "white", lowerBoxColor: "white", type: "column", xValueType: "number", axisXType: "primary", axisYType: "primary", axisXIndex: 0, axisYIndex: 0, xValueFormatString: null, yValueFormatString: null,
            zValueFormatString: null, percentFormatString: null, showInLegend: null, legendMarkerType: null, legendMarkerColor: null, legendText: null, legendMarkerBorderColor: s ? "transparent" : null, legendMarkerBorderThickness: 0, markerType: "circle", markerColor: null, markerSize: null, markerBorderColor: s ? "transparent" : null, markerBorderThickness: 0, mouseover: null, mouseout: null, mousemove: null, click: null, toolTipContent: null, visible: !0, publicProperties: { options: "readWrite", axisX: "readWrite", axisY: "readWrite", chart: "readOnly" }
          }, TextBlock: {
            x: 0,
            y: 0, width: null, height: null, maxWidth: null, maxHeight: null, padding: 0, angle: 0, text: "", horizontalAlign: "center", fontSize: 12, fontFamily: "calibri", fontWeight: "normal", fontColor: "black", fontStyle: "normal", borderThickness: 0, borderColor: "black", cornerRadius: 0, backgroundColor: null, textBaseline: "top"
          }, CultureInfo: {
            decimalSeparator: ".", digitGroupSeparator: ",", zoomText: "Zoom", panText: "Pan", resetText: "Reset", menuText: "More Options", saveJPGText: "Save as JPEG", savePNGText: "Save as PNG", printText: "Print", days: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
            shortDays: "Sun Mon Tue Wed Thu Fri Sat".split(" "), months: "January February March April May June July August September October November December".split(" "), shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" ")
          }
        }, Qa = { en: {} }, w = s ? "Trebuchet MS, Helvetica, sans-serif" : "Arial", za = s ? "Impact, Charcoal, sans-serif" : "Arial", wa = {
          colorSet1: "#4F81BC #C0504E #9BBB58 #23BFAA #8064A1 #4AACC5 #F79647 #7F6084 #77A033 #33558B #E59566".split(" "), colorSet2: "#6D78AD #51CDA0 #DF7970 #4C9CA0 #AE7D99 #C9D45C #5592AD #DF874D #52BCA8 #8E7AA3 #E3CB64 #C77B85 #C39762 #8DD17E #B57952 #FCC26C".split(" "),
          colorSet3: "#8CA1BC #36845C #017E82 #8CB9D0 #708C98 #94838D #F08891 #0366A7 #008276 #EE7757 #E5BA3A #F2990B #03557B #782970".split(" ")
        }, G, W, N, T, qa; W = "#333333"; N = "#000000"; G = "#666666"; qa = T = "#000000"; var ha = 20, D = 14, Ga = {
          colorSet: "colorSet1", backgroundColor: "#FFFFFF", title: { fontFamily: za, fontSize: 32, fontColor: W, fontWeight: "normal", verticalAlign: "top", margin: 5 }, subtitles: [{ fontFamily: za, fontSize: D, fontColor: W, fontWeight: "normal", verticalAlign: "top", margin: 5 }], data: [{
            indexLabelFontFamily: w, indexLabelFontSize: D,
            indexLabelFontColor: W, indexLabelFontWeight: "normal", indexLabelLineThickness: 1
          }], axisX: [{
            titleFontFamily: w, titleFontSize: ha, titleFontColor: W, titleFontWeight: "normal", labelFontFamily: w, labelFontSize: D, labelFontColor: N, labelFontWeight: "normal", lineThickness: 1, lineColor: G, tickThickness: 1, tickColor: G, gridThickness: 0, gridColor: G, stripLines: [{ labelFontFamily: w, labelFontSize: D, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }], crosshair: {
              labelFontFamily: w,
              labelFontSize: D, labelFontColor: "#EEEEEE", labelFontWeight: "normal", labelBackgroundColor: qa, color: T, thickness: 1, lineDashType: "dash"
            }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" }
          }], axisX2: [{
            titleFontFamily: w, titleFontSize: ha, titleFontColor: W, titleFontWeight: "normal", labelFontFamily: w, labelFontSize: D, labelFontColor: N, labelFontWeight: "normal", lineThickness: 1, lineColor: G, tickThickness: 1, tickColor: G, gridThickness: 0, gridColor: G, stripLines: [{
              labelFontFamily: w,
              labelFontSize: D, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1
            }], crosshair: { labelFontFamily: w, labelFontSize: D, labelFontColor: "#EEEEEE", labelFontWeight: "normal", labelBackgroundColor: qa, color: T, thickness: 1, lineDashType: "dash" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" }
          }], axisY: [{
            titleFontFamily: w, titleFontSize: ha, titleFontColor: W, titleFontWeight: "normal", labelFontFamily: w, labelFontSize: D,
            labelFontColor: N, labelFontWeight: "normal", lineThickness: 1, lineColor: G, tickThickness: 1, tickColor: G, gridThickness: 1, gridColor: G, stripLines: [{ labelFontFamily: w, labelFontSize: D, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }], crosshair: { labelFontFamily: w, labelFontSize: D, labelFontColor: "#EEEEEE", labelFontWeight: "normal", labelBackgroundColor: qa, color: T, thickness: 1, lineDashType: "dash" }, scaleBreaks: {
              type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1,
              lineDashType: "solid"
            }
          }], axisY2: [{
            titleFontFamily: w, titleFontSize: ha, titleFontColor: W, titleFontWeight: "normal", labelFontFamily: w, labelFontSize: D, labelFontColor: N, labelFontWeight: "normal", lineThickness: 1, lineColor: G, tickThickness: 1, tickColor: G, gridThickness: 1, gridColor: G, stripLines: [{ labelFontFamily: w, labelFontSize: D, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }], crosshair: {
              labelFontFamily: w, labelFontSize: D, labelFontColor: "#EEEEEE", labelFontWeight: "normal",
              labelBackgroundColor: qa, color: T, thickness: 1, lineDashType: "dash"
            }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" }
          }], legend: { fontFamily: w, fontSize: 14, fontColor: W, fontWeight: "bold", verticalAlign: "bottom", horizontalAlign: "center" }, toolTip: { fontFamily: w, fontSize: 14, fontStyle: "normal", cornerRadius: 0, borderThickness: 1 }
        }; G = "#2A2A2A"; N = W = "#F5F5F5"; G = "#FFFFFF"; T = "#40BAF1"; qa = "#F5F5F5"; var ha = 20, D = 14, Ja = {
          colorSet: "colorSet2", title: {
            fontFamily: w, fontSize: 33, fontColor: "#3A3A3A",
            fontWeight: "bold", verticalAlign: "top", margin: 5
          }, subtitles: [{ fontFamily: w, fontSize: D, fontColor: "#3A3A3A", fontWeight: "normal", verticalAlign: "top", margin: 5 }], data: [{ indexLabelFontFamily: w, indexLabelFontSize: D, indexLabelFontColor: "#666666", indexLabelFontWeight: "normal", indexLabelLineThickness: 1 }], axisX: [{
            titleFontFamily: w, titleFontSize: ha, titleFontColor: "#666666", titleFontWeight: "normal", labelFontFamily: w, labelFontSize: D, labelFontColor: "#666666", labelFontWeight: "normal", lineThickness: 1, lineColor: "#BBBBBB",
            tickThickness: 1, tickColor: "#BBBBBB", gridThickness: 1, gridColor: "#BBBBBB", stripLines: [{ labelFontFamily: w, labelFontSize: D, labelFontColor: "#FFA500", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FFA500", thickness: 1 }], crosshair: { labelFontFamily: w, labelFontSize: D, labelFontColor: "#EEEEEE", labelFontWeight: "normal", labelBackgroundColor: "black", color: "black", thickness: 1, lineDashType: "dot" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" }
          }], axisX2: [{
            titleFontFamily: w,
            titleFontSize: ha, titleFontColor: "#666666", titleFontWeight: "normal", labelFontFamily: w, labelFontSize: D, labelFontColor: "#666666", labelFontWeight: "normal", lineThickness: 1, lineColor: "#BBBBBB", tickColor: "#BBBBBB", tickThickness: 1, gridThickness: 1, gridColor: "#BBBBBB", stripLines: [{ labelFontFamily: w, labelFontSize: D, labelFontColor: "#FFA500", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FFA500", thickness: 1 }], crosshair: {
              labelFontFamily: w, labelFontSize: D, labelFontColor: "#EEEEEE", labelFontWeight: "normal",
              labelBackgroundColor: "black", color: "black", thickness: 1, lineDashType: "dot"
            }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" }
          }], axisY: [{
            titleFontFamily: w, titleFontSize: ha, titleFontColor: "#666666", titleFontWeight: "normal", labelFontFamily: w, labelFontSize: D, labelFontColor: "#666666", labelFontWeight: "normal", lineThickness: 0, lineColor: "#BBBBBB", tickColor: "#BBBBBB", tickThickness: 1, gridThickness: 1, gridColor: "#BBBBBB", stripLines: [{
              labelFontFamily: w, labelFontSize: D,
              labelFontColor: "#FFA500", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FFA500", thickness: 1
            }], crosshair: { labelFontFamily: w, labelFontSize: D, labelFontColor: "#EEEEEE", labelFontWeight: "normal", labelBackgroundColor: "black", color: "black", thickness: 1, lineDashType: "dot" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" }
          }], axisY2: [{
            titleFontFamily: w, titleFontSize: ha, titleFontColor: "#666666", titleFontWeight: "normal", labelFontFamily: w, labelFontSize: D,
            labelFontColor: "#666666", labelFontWeight: "normal", lineThickness: 0, lineColor: "#BBBBBB", tickColor: "#BBBBBB", tickThickness: 1, gridThickness: 1, gridColor: "#BBBBBB", stripLines: [{ labelFontFamily: w, labelFontSize: D, labelFontColor: "#FFA500", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FFA500", thickness: 1 }], crosshair: { labelFontFamily: w, labelFontSize: D, labelFontColor: "#EEEEEE", labelFontWeight: "normal", labelBackgroundColor: "black", color: "black", thickness: 1, lineDashType: "dot" }, scaleBreaks: {
              type: "zigzag",
              spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid"
            }
          }], legend: { fontFamily: w, fontSize: 14, fontColor: "#3A3A3A", fontWeight: "bold", verticalAlign: "bottom", horizontalAlign: "center" }, toolTip: { fontFamily: w, fontSize: 14, fontStyle: "normal", cornerRadius: 0, borderThickness: 1 }
        }; N = W = "#F5F5F5"; G = "#FFFFFF"; T = "#40BAF1"; qa = "#F5F5F5"; ha = 20; D = 14; za = {
          colorSet: "colorSet12", backgroundColor: "#2A2A2A", title: { fontFamily: za, fontSize: 32, fontColor: W, fontWeight: "normal", verticalAlign: "top", margin: 5 }, subtitles: [{
            fontFamily: za,
            fontSize: D, fontColor: W, fontWeight: "normal", verticalAlign: "top", margin: 5
          }], toolbar: { backgroundColor: "#666666", backgroundColorOnHover: "#FF7372", borderColor: "#FF7372", borderThickness: 1, fontColor: "#F5F5F5", fontColorOnHover: "#F5F5F5" }, data: [{ indexLabelFontFamily: w, indexLabelFontSize: D, indexLabelFontColor: N, indexLabelFontWeight: "normal", indexLabelLineThickness: 1 }], axisX: [{
            titleFontFamily: w, titleFontSize: ha, titleFontColor: N, titleFontWeight: "normal", labelFontFamily: w, labelFontSize: D, labelFontColor: N, labelFontWeight: "normal",
            lineThickness: 1, lineColor: G, tickThickness: 1, tickColor: G, gridThickness: 0, gridColor: G, stripLines: [{ labelFontFamily: w, labelFontSize: D, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }], crosshair: { labelFontFamily: w, labelFontSize: D, labelFontColor: "#000000", labelFontWeight: "normal", labelBackgroundColor: qa, color: T, thickness: 1, lineDashType: "dash" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" }
          }],
          axisX2: [{
            titleFontFamily: w, titleFontSize: ha, titleFontColor: N, titleFontWeight: "normal", labelFontFamily: w, labelFontSize: D, labelFontColor: N, labelFontWeight: "normal", lineThickness: 1, lineColor: G, tickThickness: 1, tickColor: G, gridThickness: 0, gridColor: G, stripLines: [{ labelFontFamily: w, labelFontSize: D, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }], crosshair: {
              labelFontFamily: w, labelFontSize: D, labelFontColor: "#000000", labelFontWeight: "normal", labelBackgroundColor: qa,
              color: T, thickness: 1, lineDashType: "dash"
            }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" }
          }], axisY: [{
            titleFontFamily: w, titleFontSize: ha, titleFontColor: N, titleFontWeight: "normal", labelFontFamily: w, labelFontSize: D, labelFontColor: N, labelFontWeight: "normal", lineThickness: 1, lineColor: G, tickThickness: 1, tickColor: G, gridThickness: 1, gridColor: G, stripLines: [{
              labelFontFamily: w, labelFontSize: D, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null,
              color: "#FF7300", thickness: 1
            }], crosshair: { labelFontFamily: w, labelFontSize: D, labelFontColor: "#000000", labelFontWeight: "normal", labelBackgroundColor: qa, color: T, thickness: 1, lineDashType: "dash" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" }
          }], axisY2: [{
            titleFontFamily: w, titleFontSize: ha, titleFontColor: N, titleFontWeight: "normal", labelFontFamily: w, labelFontSize: D, labelFontColor: N, labelFontWeight: "normal", lineThickness: 1, lineColor: G, tickThickness: 1,
            tickColor: G, gridThickness: 1, gridColor: G, stripLines: [{ labelFontFamily: w, labelFontSize: D, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }], crosshair: { labelFontFamily: w, labelFontSize: D, labelFontColor: "#000000", labelFontWeight: "normal", labelBackgroundColor: qa, color: T, thickness: 1, lineDashType: "dash" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" }
          }], legend: {
            fontFamily: w, fontSize: 14,
            fontColor: W, fontWeight: "bold", verticalAlign: "bottom", horizontalAlign: "center"
          }, toolTip: { fontFamily: w, fontSize: 14, fontStyle: "normal", cornerRadius: 0, borderThickness: 1, fontColor: N, backgroundColor: "rgba(0, 0, 0, .7)" }
        }; G = "#FFFFFF"; N = W = "#FAFAFA"; T = "#40BAF1"; qa = "#F5F5F5"; ha = 20; D = 14; T = {
          colorSet: "colorSet2", backgroundColor: "#32373A", title: { fontFamily: w, fontSize: 32, fontColor: W, fontWeight: "normal", verticalAlign: "top", margin: 5 }, subtitles: [{
            fontFamily: w, fontSize: D, fontColor: W, fontWeight: "normal", verticalAlign: "top",
            margin: 5
          }], toolbar: { backgroundColor: "#666666", backgroundColorOnHover: "#FF7372", borderColor: "#FF7372", borderThickness: 1, fontColor: "#F5F5F5", fontColorOnHover: "#F5F5F5" }, data: [{ indexLabelFontFamily: w, indexLabelFontSize: D, indexLabelFontColor: N, indexLabelFontWeight: "normal", indexLabelLineThickness: 1 }], axisX: [{
            titleFontFamily: w, titleFontSize: ha, titleFontColor: N, titleFontWeight: "normal", labelFontFamily: w, labelFontSize: D, labelFontColor: N, labelFontWeight: "normal", lineThickness: 1, lineColor: G, tickThickness: 1,
            tickColor: G, gridThickness: 0, gridColor: G, stripLines: [{ labelFontFamily: w, labelFontSize: D, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }], crosshair: { labelFontFamily: w, labelFontSize: D, labelFontColor: "#000000", labelFontWeight: "normal", labelBackgroundColor: qa, color: T, thickness: 1, lineDashType: "dash" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" }
          }], axisX2: [{
            titleFontFamily: w, titleFontSize: ha,
            titleFontColor: N, titleFontWeight: "normal", labelFontFamily: w, labelFontSize: D, labelFontColor: N, labelFontWeight: "normal", lineThickness: 1, lineColor: G, tickThickness: 1, tickColor: G, gridThickness: 0, gridColor: G, stripLines: [{ labelFontFamily: w, labelFontSize: D, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }], crosshair: { labelFontFamily: w, labelFontSize: D, labelFontColor: "#000000", labelFontWeight: "normal", labelBackgroundColor: qa, color: T, thickness: 1, lineDashType: "dash" },
            scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" }
          }], axisY: [{
            titleFontFamily: w, titleFontSize: ha, titleFontColor: N, titleFontWeight: "normal", labelFontFamily: w, labelFontSize: D, labelFontColor: N, labelFontWeight: "normal", lineThickness: 0, lineColor: G, tickThickness: 1, tickColor: G, gridThickness: 1, gridColor: G, stripLines: [{ labelFontFamily: w, labelFontSize: D, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }],
            crosshair: { labelFontFamily: w, labelFontSize: D, labelFontColor: "#000000", labelFontWeight: "normal", labelBackgroundColor: qa, color: T, thickness: 1, lineDashType: "dash" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" }
          }], axisY2: [{
            titleFontFamily: w, titleFontSize: ha, titleFontColor: N, titleFontWeight: "normal", labelFontFamily: w, labelFontSize: D, labelFontColor: N, labelFontWeight: "normal", lineThickness: 0, lineColor: G, tickThickness: 1, tickColor: G, gridThickness: 1,
            gridColor: G, stripLines: [{ labelFontFamily: w, labelFontSize: D, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }], crosshair: { labelFontFamily: w, labelFontSize: D, labelFontColor: "#000000", labelFontWeight: "normal", labelBackgroundColor: qa, color: T, thickness: 1, lineDashType: "dash" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" }
          }], legend: {
            fontFamily: w, fontSize: 14, fontColor: W, fontWeight: "bold",
            verticalAlign: "bottom", horizontalAlign: "center"
          }, toolTip: { fontFamily: w, fontSize: 14, fontStyle: "normal", cornerRadius: 0, borderThickness: 1, fontColor: N, backgroundColor: "rgba(0, 0, 0, .7)" }
        }; var ab = { light1: Ga, light2: Ja, dark1: za, dark2: T, theme1: Ga, theme2: Ja, theme3: Ga }, U = { numberDuration: 1, yearDuration: 314496E5, monthDuration: 2592E6, weekDuration: 6048E5, dayDuration: 864E5, hourDuration: 36E5, minuteDuration: 6E4, secondDuration: 1E3, millisecondDuration: 1, dayOfWeekFromInt: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" ") };
  (function () {
    fa.fSDec = function (m) { for (var n = "", h = 0; h < m.length; h++)n += String.fromCharCode(Math.ceil(m.length / 57 / 5) ^ m.charCodeAt(h)); return n }; fa.obj = { trVs: "Ush`m!Wdsrhno", fntStr: "qy!B`mhcsh-!Mtbhe`!Fs`oed-!Mtbhe`!R`or!Tohbned-!@sh`m-!r`or,rdshg", txtBl: "udyuC`rdmhod", fnt: "gnou", fSy: "ghmmRuxmd", fTx: "ghmmUdyu", grClr: "fsdx", cntx: "buy", tp: "unq" }; delete Y[fa.fSDec("Bi`su")][fa.fSDec("bsdehuIsdg")]; fa.pro = { sCH: Y[fa.fSDec("Bi`su")][fa.fSDec("bsdehuIsdg")] }; fa._fTWm = function (m) {
      if ("undefined" === typeof fa.pro.sCH &&
        !lb) try { var n = m[fa.fSDec(fa.obj.cntx)]; n[fa.fSDec(fa.obj.txtBl)] = fa.fSDec(fa.obj.tp); n[fa.fSDec(fa.obj.fnt)] = 11 + fa.fSDec(fa.obj.fntStr); n[fa.fSDec(fa.obj.fSy)] = fa.fSDec(fa.obj.grClr); n[fa.fSDec(fa.obj.fTx)](fa.fSDec(fa.obj.trVs), 2, m.height - 11 - 2) } catch (h) { }
    }
  })(); var gb = {}, Fa = null, mb = function (m) {
    var n = 0, h = 0; this.options.width ? n = this.width : this.width = n = 0 < this.container.clientWidth ? this.container.clientWidth : this.width; this.options.height ? h = this.height : this.height = h = 0 < this.container.clientHeight ? this.container.clientHeight :
      this.height; if (this.canvas.width !== n * ga || this.canvas.height !== h * ga) { for (var s = 0; s < m.length; s++)Ta(m[s], n, h); this.bounds = { x1: 0, y1: 0, x2: this.width, y2: this.height, width: this.width, height: this.height }; return !0 } return !1
  }, nb = function () { this.ctx.clearRect(0, 0, this.width, this.height); this.backgroundColor && (this.ctx.fillStyle = this.backgroundColor, this.ctx.fillRect(0, 0, this.width, this.height)) }, ob = function (m, n, h) {
    n = Math.min(this.width, this.height); return Math.max("theme4" === this.theme ? 0 : 300 <= n ? 12 : 11, Math.round(n *
      (m / 400)))
  }, ka = function () {
    var m = /D{1,4}|M{1,4}|Y{1,4}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|f{1,3}|t{1,2}|T{1,2}|K|z{1,3}|"[^"]*"|'[^']*'/g, n = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), h = "Sun Mon Tue Wed Thu Fri Sat".split(" "), s = "January February March April May June July August September October November December".split(" "), w = "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "), H = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,
      B = /[^-+\dA-Z]/g; return function (y, D, M) {
        var G = M ? M.days : n, R = M ? M.months : s, N = M ? M.shortDays : h, Q = M ? M.shortMonths : w; M = ""; var f = !1; y = y && y.getTime ? y : y ? new Date(y) : new Date; if (isNaN(y)) throw SyntaxError("invalid date"); "UTC:" === D.slice(0, 4) && (D = D.slice(4), f = !0); M = f ? "getUTC" : "get"; var x = y[M + "Date"](), v = y[M + "Day"](), z = y[M + "Month"](), a = y[M + "FullYear"](), d = y[M + "Hours"](), b = y[M + "Minutes"](), c = y[M + "Seconds"](), e = y[M + "Milliseconds"](), g = f ? 0 : y.getTimezoneOffset(); return M = D.replace(m, function (A) {
          switch (A) {
            case "D": return x;
            case "DD": return na(x, 2); case "DDD": return N[v]; case "DDDD": return G[v]; case "M": return z + 1; case "MM": return na(z + 1, 2); case "MMM": return Q[z]; case "MMMM": return R[z]; case "Y": return parseInt(String(a).slice(-2)); case "YY": return na(String(a).slice(-2), 2); case "YYY": return na(String(a).slice(-3), 3); case "YYYY": return na(a, 4); case "h": return d % 12 || 12; case "hh": return na(d % 12 || 12, 2); case "H": return d; case "HH": return na(d, 2); case "m": return b; case "mm": return na(b, 2); case "s": return c; case "ss": return na(c,
              2); case "f": return String(e).slice(0, 1); case "ff": return na(String(e).slice(0, 2), 2); case "fff": return na(String(e).slice(0, 3), 3); case "t": return 12 > d ? "a" : "p"; case "tt": return 12 > d ? "am" : "pm"; case "T": return 12 > d ? "A" : "P"; case "TT": return 12 > d ? "AM" : "PM"; case "K": return f ? "UTC" : (String(y).match(H) || [""]).pop().replace(B, ""); case "z": return (0 < g ? "-" : "+") + Math.floor(Math.abs(g) / 60); case "zz": return (0 < g ? "-" : "+") + na(Math.floor(Math.abs(g) / 60), 2); case "zzz": return (0 < g ? "-" : "+") + na(Math.floor(Math.abs(g) / 60),
                2) + na(Math.abs(g) % 60, 2); default: return A.slice(1, A.length - 1)
          }
        })
      }
  }(), Z = function (m, h, s) {
    if (null === m) return ""; if (!isFinite(m)) return m; m = Number(m); var w = 0 > m ? !0 : !1; w && (m *= -1); var y = s ? s.decimalSeparator : ".", H = s ? s.digitGroupSeparator : ",", B = ""; h = String(h); var B = 1, D = s = "", G = -1, M = [], R = [], N = 0, Q = 0, K = 0, f = !1, x = 0, D = h.match(/"[^"]*"|'[^']*'|[eE][+-]*[0]+|[,]+[.]|\u2030|./g); h = null; for (var v = 0; D && v < D.length; v++)if (h = D[v], "." === h && 0 > G) G = v; else {
      if ("%" === h) B *= 100; else if ("\u2030" === h) { B *= 1E3; continue } else if ("," === h[0] &&
        "." === h[h.length - 1]) { B /= Math.pow(1E3, h.length - 1); G = v + h.length - 1; continue } else "E" !== h[0] && "e" !== h[0] || "0" !== h[h.length - 1] || (f = !0); 0 > G ? (M.push(h), "#" === h || "0" === h ? N++ : "," === h && K++) : (R.push(h), "#" !== h && "0" !== h || Q++)
    } f && (h = Math.floor(m), D = -Math.floor(Math.log(m) / Math.LN10 + 1), x = 0 === m ? 0 : 0 === h ? -(N + D) : String(h).length - N, B /= Math.pow(10, x)); 0 > G && (G = v); B = (m * B).toFixed(Q); h = B.split("."); B = (h[0] + "").split(""); m = (h[1] + "").split(""); B && "0" === B[0] && B.shift(); for (f = D = v = Q = G = 0; 0 < M.length;)if (h = M.pop(), "#" === h || "0" ===
      h) if (G++, G === N) { var z = B, B = []; if ("0" === h) for (h = N - Q - (z ? z.length : 0); 0 < h;)z.unshift("0"), h--; for (; 0 < z.length;)s = z.pop() + s, f++, 0 === f % D && (v === K && 0 < z.length) && (s = H + s) } else 0 < B.length ? (s = B.pop() + s, Q++, f++) : "0" === h && (s = "0" + s, Q++, f++), 0 === f % D && (v === K && 0 < B.length) && (s = H + s); else "E" !== h[0] && "e" !== h[0] || "0" !== h[h.length - 1] || !/[eE][+-]*[0]+/.test(h) ? "," === h ? (v++, D = f, f = 0, 0 < B.length && (s = H + s)) : s = 1 < h.length && ('"' === h[0] && '"' === h[h.length - 1] || "'" === h[0] && "'" === h[h.length - 1]) ? h.slice(1, h.length - 1) + s : h + s : (h = 0 > x ? h.replace("+",
        "").replace("-", "") : h.replace("-", ""), s += h.replace(/[0]+/, function (a) { return na(x, a.length) })); H = ""; for (M = !1; 0 < R.length;)h = R.shift(), "#" === h || "0" === h ? 0 < m.length && 0 !== Number(m.join("")) ? (H += m.shift(), M = !0) : "0" === h && (H += "0", M = !0) : 1 < h.length && ('"' === h[0] && '"' === h[h.length - 1] || "'" === h[0] && "'" === h[h.length - 1]) ? H += h.slice(1, h.length - 1) : "E" !== h[0] && "e" !== h[0] || "0" !== h[h.length - 1] || !/[eE][+-]*[0]+/.test(h) ? H += h : (h = 0 > x ? h.replace("+", "").replace("-", "") : h.replace("-", ""), H += h.replace(/[0]+/, function (a) {
          return na(x,
            a.length)
        })); s += (M ? y : "") + H; return w ? "-" + s : s
  }, Aa = function (m) { var h = 0, s = 0; m = m || window.event; m.offsetX || 0 === m.offsetX ? (h = m.offsetX, s = m.offsetY) : m.layerX || 0 == m.layerX ? (h = m.layerX, s = m.layerY) : (h = m.pageX - m.target.offsetLeft, s = m.pageY - m.target.offsetTop); return { x: h, y: s } }, kb = !0, Ya = window.devicePixelRatio || 1, Ua = 1, ga = kb ? Ya / Ua : 1, X = function (m, h, s, w, y, H, B, D, G, M, R, Q, N) {
    "undefined" === typeof N && (N = 1); B = B || 0; D = D || "black"; var K = 15 < w - h && 15 < y - s ? 8 : 0.35 * Math.min(w - h, y - s); m.beginPath(); m.moveTo(h, s); m.save(); m.fillStyle =
      H; m.globalAlpha = N; m.fillRect(h, s, w - h, y - s); m.globalAlpha = 1; 0 < B && (N = 0 === B % 2 ? 0 : 0.5, m.beginPath(), m.lineWidth = B, m.strokeStyle = D, m.moveTo(h, s), m.rect(h - N, s - N, w - h + 2 * N, y - s + 2 * N), m.stroke()); m.restore(); !0 === G && (m.save(), m.beginPath(), m.moveTo(h, s), m.lineTo(h + K, s + K), m.lineTo(w - K, s + K), m.lineTo(w, s), m.closePath(), B = m.createLinearGradient((w + h) / 2, s + K, (w + h) / 2, s), B.addColorStop(0, H), B.addColorStop(1, "rgba(255, 255, 255, .4)"), m.fillStyle = B, m.fill(), m.restore()); !0 === M && (m.save(), m.beginPath(), m.moveTo(h, y), m.lineTo(h +
        K, y - K), m.lineTo(w - K, y - K), m.lineTo(w, y), m.closePath(), B = m.createLinearGradient((w + h) / 2, y - K, (w + h) / 2, y), B.addColorStop(0, H), B.addColorStop(1, "rgba(255, 255, 255, .4)"), m.fillStyle = B, m.fill(), m.restore()); !0 === R && (m.save(), m.beginPath(), m.moveTo(h, s), m.lineTo(h + K, s + K), m.lineTo(h + K, y - K), m.lineTo(h, y), m.closePath(), B = m.createLinearGradient(h + K, (y + s) / 2, h, (y + s) / 2), B.addColorStop(0, H), B.addColorStop(1, "rgba(255, 255, 255, 0.1)"), m.fillStyle = B, m.fill(), m.restore()); !0 === Q && (m.save(), m.beginPath(), m.moveTo(w,
          s), m.lineTo(w - K, s + K), m.lineTo(w - K, y - K), m.lineTo(w, y), B = m.createLinearGradient(w - K, (y + s) / 2, w, (y + s) / 2), B.addColorStop(0, H), B.addColorStop(1, "rgba(255, 255, 255, 0.1)"), m.fillStyle = B, B.addColorStop(0, H), B.addColorStop(1, "rgba(255, 255, 255, 0.1)"), m.fillStyle = B, m.fill(), m.closePath(), m.restore())
  }, sa = function (m) { for (var h = "", s = 0; s < m.length; s++)h += String.fromCharCode(Math.ceil(m.length / 57 / 5) ^ m.charCodeAt(s)); return h }, lb = window && window[sa("mnb`uhno")] && window[sa("mnb`uhno")].href && window[sa("mnb`uhno")].href.indexOf &&
    (-1 !== window[sa("mnb`uhno")].href.indexOf(sa("b`ow`rkr/bnl")) || -1 !== window[sa("mnb`uhno")].href.indexOf(sa("gdonqhy/bnl")) || -1 !== window[sa("mnb`uhno")].href.indexOf(sa("gheemd"))), ub = lb && -1 === window[sa("mnb`uhno")].href.indexOf(sa("gheemd")), vb = {
      reset: { image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACIAAAAeCAYAAABJ/8wUAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAPjSURBVFhHxVdJaFNRFP1J/jwkP5MxsbaC1WJEglSxOFAXIsFpVRE3ggi1K90obioRRBA33XXnQnciirhQcMCdorgQxBkXWlREkFKsWkv5npvckp/XnzRpKh64kLw733fffe9L/wrL0+mVUdO8uTSZ3MBL/we2qg4rkuSpodCELstXE46ziVkLQ6FQcGOmeSSq6wd4aV50d3drWjj8kQKZJTUc9kxFGenv79dZrDksTSTWWJp2QYtEPiErysyzdX0LsxsCQR8keX8gs6RHIk8ysdgKFg2G53mhuOPsshTlBjKaFo1g7SqLNoShKLdFXT8huQ/paLSbxatYnc2mHMM4hr18Vi8TIvCmXF3vYrW6cF23gGTOk0M1wA4RKvOmq6vLZRVJipvmSWT6tZ6CSEYkco5V50VPT4+D7RwOqi6RiSZm0fJ+vggSqkeoypdsNmuyelNwbXsbgvkWYMtzDWNvWaijoyOBqE+hVK8abcssUeXQ/YfKyi0gFYv1Ipgfoj34fYGTJLOYJA0ODirok32GLN8XhUWCwSes1hIwBg6LydJ/tEeRRapAdUp+wSAiZchtZZWWgAZ+JNpD8peYXQVK9UwUxNpzOK8pq97kURZhYTCKBwPD7h2zK+js7Myi7D8Fod+0TkMI8+EMAngLGc/WtBFWawkFHFnoj/t9KLgGmF0B3QfkxC+EarxkdhnFYlFLY06USqUwL7UMjICHfh/wOc2sCqhpxGbCkLvL7EUDbF73+6DkmVWB6zi7xUDQSLeYvWjAILvm9zEnkJhlbRcDQZcv6Kg2AipyT/Axw6wKlqVSqxDdjF8Izfod13qURdrG/nxehY+xGh+h0CSzKygGvSNQIcc097BI24jb9hax6kj2E7OrMFX1il+ICEf2NrPbhiXLl+fYl+U7zK4iYdsDcyLGf+ofFlkwcN+s10KhmpuYhhtm0hCLVIFL0MDsqNlDIqy9x2CLs1jL6OvrI7vPRbtohXG6eFmsFnHDGAp6n9AgyuVySRZrGvROxRgIfLXhzjrNYnNBUxNX/dMgRWT1mt4XLDovaApD53E9W3ilNX5M55LJHpRtIsgAvciR4WWcgK2Dvb1YqgXevmF8z2zEBTcKG39EfSKsT9EbhVUaI2FZO+oZIqImxol6j66/hcAu4sSN4vc1ZPoKeoE6RGhYL2YYA+ymOSSi0Z0wWntbtkGUWCvfSDXIxONraZ/FY90KUfNTpfC5spnNLgxoYNnR9RO4F8ofXEHOgogCQE99w+fF2Xw+b7O59rEOsyRqGEfpVoaDMQQ1CZrG46bcM6AZ0C/wPqNfHliqejyTySxh9TqQpL+xmbIlkB9SlAAAAABJRU5ErkJggg==" },
      pan: { image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAICSURBVEhLxZbPahNRGMUn/5MpuAiBEAIufQGfzr5E40YptBXajYzudCEuGqS+gGlrFwquDGRTutBdYfydzJ3LzeQmJGZue+Dw/Z17Mnfmu5Pof9Hr9Z61Wq0bWZMKj263O6xWq99wU9lOpzPMKgEhEcRucNOcioOK+0RzBhNvt9tPV4nmVF19+OWhVqt9xXgFXZq+8lCv119UKpUJ7iX2FmvFTKz8RH34YdBsNk8wVtjE4fGYwm8wrrDi3WBG5oKXZGRSS9hGuNFojLTe2lFz5xThWZIktayyiE2FdT3rzXBXz7krKiL8c17wAKFDjCus2AvW+YGZ9y2JF0VFRuMPfI//rsCE/C+s26s4gQu9ul7r4NteKx7H8XOC724xNNGbaNu++IrBqbOV7Tj3FgMRvc/YKOr3+3sE47wgEt/Bl/gaK5cHbNU11vYSXylfpK7XOvjuumPp4Wcoipu30Qsez2uMXYz4lfI+mOmwothY+SLiXJy7mKVpWs3Si0CoOMfeI9Od43Wic+jO+ZVv+crsm9QSNhUW9LXSeoPBYLXopthGuFQgdIxxhY+UDwlt1x5CZ1hX+NTUdt/OIvjKaDSmuOJfaIVNPKX+W18j/PLA2/kR44p5Sd8HbHngT/yTfNRWUXX14ZcL3wmX0+TLf8YO7CGT8yFE5zB3/gney25/OETRP9CtPDFe5jShAAAAAElFTkSuQmCC" },
      zoom: { image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAALWSURBVEhLvZZLaBNRFIabyftBIgEfqCCBoCC6MYqiXYiIj4U76U4X7sUHbhQhUBfixhZEUBDB16YuFERaUaQLK7ooCOJj4UKtYEFU0EptShO/A9Ph3js3k8lo/eHnP7n3nP/M3LlzMz1hkUwmNziOcyKRSFyFt+LxeD/c2Wq1Ym7Kv0M2m11Os1OxWGycn1OwZXCGuXfwIhezkd9/jRgNT2L4ldhs1pbkX5OLJe4euVxuGQaPCa3mnUjtJx7BDuKusJTCV6jVVGHTMuYRjxma7yIOhTgFY6jNaAKew2xPKpVay9ganmkvj+M448/MfJdT5K5Gg4HJacRngPFgqVRaRNwW1B4i7yehWfsEDdz1K+A01AoxPIqGAiuwGfkOTY8+1A6u7AyiFTB2Hu0KPIrdiOnzHLWDybeImvy+Wq2mZa5bUHsD0Zpz+KxHdWQymV6kAb1ElqeORgJLvgnRdj1+R1AfzkIvSUjxVjQSarVakrueIPT8+H1F5jSUy+WXiJrUYBVWyVxU4PEU8TzhfaijUqnMIWrjaY492eWRwdKOIqrnIxnXwLLeRLwk2GQzrEMjg0avEbXxkIxr4OoOImpj2QwyFgms1koa/SZUG8s+0iGnEhNfCNXEhzIXBVz0McTzEvJ+70P9oNFtxEzei3aFYrFYxmuSUPWSv9Yi9IMm2xE1We56Mp1OV4nDwqFmBDV9gk9AEh4gZtFHNt8W4kAUCoXF5MorY9Z/kDni9nDv7hc0i2fhgLvTtX8a99PoMPPagTFPxofRzmDJ9yM+AyEmTfgGysYbQcfhDzPPJDmX0c7gDg4gs9BqFIWhm/Nct5H8gtBq1I7UfIbtvmIuoaGQcp+fdpbbSM43eEH5wrwLbXmhm/fU63VHXjcuok7hEByFY/AeHGC8L5/PL3HT5xGH1uYwfPOICGo+CBcU0vwO1BqzUqILDl/z/9VYIMfpddiAc47jDP8BsUpb13wOLRwAAAAASUVORK5CYII=" },
      menu: { image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAeCAYAAABE4bxTAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAADoSURBVFhH7dc9CsJAFATgRxIIBCwCqZKATX5sbawsY2MvWOtF9AB6AU8gguAJbD2AnZ2VXQT/Ko2TYGCL2OYtYQc+BuYA+1hCtnCVwMm27SGaXpDJIAiCvCkVR05hGOZNN3HkFMdx3nQRR06+76/R1IcFLJlNQEWlmWlBTwJtKLKHynehZqnjOGM0PYWRVXk61C37p7xlZ3Hk5HneCk1dmMH811xGoKLSzDiQwIBZB4ocoPJdqNkDt2yKlueWRVGUtzy3rPwo3sWRU3nLjuLI6OO67oZM00wMw3hrmpZx0XU9syxrR0T0BeMpb9dneSR2AAAAAElFTkSuQmCC" }
    };
  K.prototype.setOptions = function (m, h) { if (Y[this._defaultsKey]) { var s = Y[this._defaultsKey], w; for (w in s) "publicProperties" !== w && s.hasOwnProperty(w) && (this[w] = m && w in m ? m[w] : h && w in h ? h[w] : s[w]) } else Ma && window.console && console.log("defaults not set") }; K.prototype.get = function (m) {
    var h = Y[this._defaultsKey]; if ("options" === m) return this.options && this.options._isPlaceholder ? null : this.options; if (h.hasOwnProperty(m) || h.publicProperties && h.publicProperties.hasOwnProperty(m)) return this[m]; window.console &&
      window.console.log('Property "' + m + "\" doesn't exist. Please check for typo.")
  }; K.prototype.set = function (h, s, w) {
    w = "undefined" === typeof w ? !0 : w; var y = Y[this._defaultsKey]; if ("options" === h) this.createUserOptions(s); else if (y.hasOwnProperty(h) || y.publicProperties && y.publicProperties.hasOwnProperty(h) && "readWrite" === y.publicProperties[h]) this.options._isPlaceholder && this.createUserOptions(), this.options[h] = s; else {
      window.console && (y.publicProperties && y.publicProperties.hasOwnProperty(h) && "readOnly" === y.publicProperties[h] ?
        window.console.log('Property "' + h + '" is read-only.') : window.console.log('Property "' + h + "\" doesn't exist. Please check for typo.")); return
    } w && (this.stockChart || this.chart || this).render()
  }; K.prototype.addTo = function (h, s, w, y) {
    y = "undefined" === typeof y ? !0 : y; var D = Y[this._defaultsKey]; D.hasOwnProperty(h) || D.publicProperties && D.publicProperties.hasOwnProperty(h) && "readWrite" === D.publicProperties[h] ? (this.options._isPlaceholder && this.createUserOptions(), "undefined" === typeof this.options[h] && (this.options[h] =
      []), h = this.options[h], w = "undefined" === typeof w || null === w ? h.length : w, h.splice(w, 0, s), y && (this.stockChart || this.chart || this).render()) : window.console && (D.publicProperties && D.publicProperties.hasOwnProperty(h) && "readOnly" === D.publicProperties[h] ? window.console.log('Property "' + h + '" is read-only.') : window.console.log('Property "' + h + "\" doesn't exist. Please check for typo."))
  }; K.prototype.createUserOptions = function (h) {
    if ("undefined" !== typeof h || this.options._isPlaceholder) if (this.parent.options._isPlaceholder &&
      this.parent.createUserOptions(), this.isOptionsInArray) { this.parent.options[this.optionsName] || (this.parent.options[this.optionsName] = []); var s = this.parent.options[this.optionsName], w = s.length; this.options._isPlaceholder || (Ea(s), w = s.indexOf(this.options)); this.options = "undefined" === typeof h ? {} : h; s[w] = this.options } else this.options = "undefined" === typeof h ? {} : h, h = this.parent.options, this.optionsName ? s = this.optionsName : (s = this._defaultsKey) && 0 !== s.length ? (w = s.charAt(0).toLowerCase(), 1 < s.length && (w = w.concat(s.slice(1))),
        s = w) : s = void 0, h[s] = this.options
  }; K.prototype.remove = function (h) { h = "undefined" === typeof h ? !0 : h; if (this.isOptionsInArray) { var s = this.parent.options[this.optionsName]; Ea(s); var w = s.indexOf(this.options); 0 <= w && s.splice(w, 1) } else delete this.parent.options[this.optionsName]; h && (this.stockChart || this.chart || this).render() }; K.prototype.updateOption = function (m) {
    !Y[this._defaultsKey] && (Ma && window.console) && console.log("defaults not set"); var s = Y[this._defaultsKey], w = {}, y = this[m], D = this._themeOptionsKey, H =
      this._index; this.theme && h(this.parent) && h(D) && h(H) ? w = h(this.predefinedThemes[this.theme]) ? this.predefinedThemes.light1 : this.predefinedThemes[this.theme] : this.parent && (this.parent.themeOptions && this.parent.themeOptions[D]) && (null === H ? w = this.parent.themeOptions[D] : 0 < this.parent.themeOptions[D].length && (w = Math.min(this.parent.themeOptions[D].length - 1, H), w = this.parent.themeOptions[D][w])); this.themeOptions = w; m in s && (y = m in this.options ? this.options[m] : w && m in w ? w[m] : s[m]); if (y === this[m]) return !1; this[m] =
        y; return !0
  }; K.prototype.trackChanges = function (h) { if (!this.sessionVariables) throw "Session Variable Store not set"; this.sessionVariables[h] = this.options[h] }; K.prototype.isBeingTracked = function (h) { this.options._oldOptions || (this.options._oldOptions = {}); return this.options._oldOptions[h] ? !0 : !1 }; K.prototype.hasOptionChanged = function (h) { if (!this.sessionVariables) throw "Session Variable Store not set"; return this.sessionVariables[h] !== this.options[h] }; K.prototype.addEventListener = function (h, s, w) {
    h && s && (this._eventListeners[h] =
      this._eventListeners[h] || [], this._eventListeners[h].push({ context: w || this, eventHandler: s }))
  }; K.prototype.removeEventListener = function (h, s) { if (h && s && this._eventListeners[h]) for (var w = this._eventListeners[h], y = 0; y < w.length; y++)if (w[y].eventHandler === s) { w[y].splice(y, 1); break } }; K.prototype.removeAllEventListeners = function () { this._eventListeners = [] }; K.prototype.dispatchEvent = function (h, s, w) {
    if (h && this._eventListeners[h]) {
      s = s || {}; for (var y = this._eventListeners[h], D = 0; D < y.length; D++)y[D].eventHandler.call(y[D].context,
        s)
    } "function" === typeof this[h] && this[h].call(w || this.chart, s)
  }; La.prototype.registerSpace = function (h, s) { "top" === h ? this._topOccupied += s.height : "bottom" === h ? this._bottomOccupied += s.height : "left" === h ? this._leftOccupied += s.width : "right" === h && (this._rightOccupied += s.width) }; La.prototype.unRegisterSpace = function (h, s) { "top" === h ? this._topOccupied -= s.height : "bottom" === h ? this._bottomOccupied -= s.height : "left" === h ? this._leftOccupied -= s.width : "right" === h && (this._rightOccupied -= s.width) }; La.prototype.getFreeSpace =
    function () { return { x1: this._x1 + this._leftOccupied, y1: this._y1 + this._topOccupied, x2: this._x2 - this._rightOccupied, y2: this._y2 - this._bottomOccupied, width: this._x2 - this._x1 - this._rightOccupied - this._leftOccupied, height: this._y2 - this._y1 - this._bottomOccupied - this._topOccupied } }; La.prototype.reset = function () { this._rightOccupied = this._leftOccupied = this._bottomOccupied = this._topOccupied = this._padding }; V(ja, K); ja.prototype._initialize = function () {
      h(this.padding) || "object" !== typeof this.padding ? this.topPadding =
        this.rightPadding = this.bottomPadding = this.leftPadding = Number(this.padding) | 0 : (this.topPadding = h(this.padding.top) ? 0 : Number(this.padding.top) | 0, this.rightPadding = h(this.padding.right) ? 0 : Number(this.padding.right) | 0, this.bottomPadding = h(this.padding.bottom) ? 0 : Number(this.padding.bottom) | 0, this.leftPadding = h(this.padding.left) ? 0 : Number(this.padding.left) | 0)
    }; ja.prototype.render = function (h) {
      if (0 !== this.fontSize) {
        h && this.ctx.save(); var s = this.ctx.font; this.ctx.textBaseline = this.textBaseline; var w = 0; this._isDirty &&
          this.measureText(this.ctx); this.ctx.translate(this.x, this.y + w); "middle" === this.textBaseline && (w = -this._lineHeight / 2); this.ctx.font = this._getFontString(); this.ctx.rotate(Math.PI / 180 * this.angle); var y = 0, D = this.topPadding, H = null; this.ctx.roundRect || Ha(this.ctx); (0 < this.borderThickness && this.borderColor || this.backgroundColor) && this.ctx.roundRect(0, w, this.width, this.height, this.cornerRadius, this.borderThickness, this.backgroundColor, this.borderColor); this.ctx.fillStyle = this.fontColor; for (w = 0; w < this._wrappedText.lines.length; w++)H =
            this._wrappedText.lines[w], "right" === this.horizontalAlign ? y = this.width - H.width - this.rightPadding : "left" === this.horizontalAlign ? y = this.leftPadding : "center" === this.horizontalAlign && (y = (this.width - (this.leftPadding + this.rightPadding)) / 2 - H.width / 2 + this.leftPadding), this.ctx.fillText(H.text, y, D), D += H.height; this.ctx.font = s; h && this.ctx.restore()
      }
    }; ja.prototype.setText = function (h) { this.text = h; this._isDirty = !0; this._wrappedText = null }; ja.prototype.measureText = function () {
      this._lineHeight = fb(this.fontFamily,
        this.fontSize, this.fontWeight); if (null === this.maxWidth) throw "Please set maxWidth and height for TextBlock"; this._wrapText(this.ctx); this._isDirty = !1; return { width: this.width, height: this.height }
    }; ja.prototype._getLineWithWidth = function (h, s, w) {
      h = String(h); if (!h) return { text: "", width: 0 }; var y = w = 0, D = h.length - 1, H = Infinity; for (this.ctx.font = this._getFontString(); y <= D;) { var H = Math.floor((y + D) / 2), B = h.substr(0, H + 1); w = this.ctx.measureText(B).width; if (w < s) y = H + 1; else if (w > s) D = H - 1; else break } w > s && 1 < B.length && (B =
        B.substr(0, B.length - 1), w = this.ctx.measureText(B).width); s = !0; if (B.length === h.length || " " === h[B.length]) s = !1; s && (h = B.split(" "), 1 < h.length && h.pop(), B = h.join(" "), w = this.ctx.measureText(B).width); return { text: B, width: w }
    }; ja.prototype._wrapText = function () {
      var h = new String(Pa(String(this.text))), s = [], w = this.ctx.font, y = 0, D = 0; this.ctx.font = this._getFontString(); if (0 === this.frontSize) D = y = 0; else for (; 0 < h.length;) {
        var H = this.maxHeight - (this.topPadding + this.bottomPadding), B = this._getLineWithWidth(h, this.maxWidth -
          (this.leftPadding + this.rightPadding), !1); B.height = this._lineHeight; s.push(B); var G = D, D = Math.max(D, B.width), y = y + B.height, h = Pa(h.slice(B.text.length, h.length)); H && y > H && (B = s.pop(), y -= B.height, D = G)
      } this._wrappedText = { lines: s, width: D, height: y }; this.width = D + (this.leftPadding + this.rightPadding); this.height = y + (this.topPadding + this.bottomPadding); this.ctx.font = w
    }; ja.prototype._getFontString = function () {
      var h; h = "" + (this.fontStyle ? this.fontStyle + " " : ""); h += this.fontWeight ? this.fontWeight + " " : ""; h += this.fontSize ?
        this.fontSize + "px " : ""; var n = this.fontFamily ? this.fontFamily + "" : ""; !s && n && (n = n.split(",")[0], "'" !== n[0] && '"' !== n[0] && (n = "'" + n + "'")); return h += n
    }; V(Wa, K); V(Ia, K); Ia.prototype.setLayout = function () {
      if (this.text) {
        var m = this.dockInsidePlotArea ? this.chart.plotArea : this.chart, s = m.layoutManager.getFreeSpace(), w = s.x1, y = s.y1, D = 0, H = 0, B = this.chart._menuButton && this.chart.exportEnabled && "top" === this.verticalAlign ? 22 : 0, G, K; "top" === this.verticalAlign || "bottom" === this.verticalAlign ? (null === this.maxWidth && (this.maxWidth =
          s.width - 4 - B * ("center" === this.horizontalAlign ? 2 : 1)), H = 0.5 * s.height - this.margin - 2, D = 0) : "center" === this.verticalAlign && ("left" === this.horizontalAlign || "right" === this.horizontalAlign ? (null === this.maxWidth && (this.maxWidth = s.height - 4), H = 0.5 * s.width - this.margin - 2) : "center" === this.horizontalAlign && (null === this.maxWidth && (this.maxWidth = s.width - 4), H = 0.5 * s.height - 4)); var M; h(this.padding) || "number" !== typeof this.padding ? h(this.padding) || "object" !== typeof this.padding || (M = this.padding.top ? this.padding.top : this.padding.bottom ?
            this.padding.bottom : 0, M += this.padding.bottom ? this.padding.bottom : this.padding.top ? this.padding.top : 0) : M = 2 * this.padding; this.wrap || (H = Math.min(H, 1.5 * this.fontSize + M)); H = new ja(this.ctx, {
              fontSize: this.fontSize, fontFamily: this.fontFamily, fontColor: this.fontColor, fontStyle: this.fontStyle, fontWeight: this.fontWeight, horizontalAlign: this.horizontalAlign, verticalAlign: this.verticalAlign, borderColor: this.borderColor, borderThickness: this.borderThickness, backgroundColor: this.backgroundColor, maxWidth: this.maxWidth,
              maxHeight: H, cornerRadius: this.cornerRadius, text: this.text, padding: this.padding, textBaseline: "top"
            }); M = H.measureText(); "top" === this.verticalAlign || "bottom" === this.verticalAlign ? ("top" === this.verticalAlign ? (y = s.y1 + 2, K = "top") : "bottom" === this.verticalAlign && (y = s.y2 - 2 - M.height, K = "bottom"), "left" === this.horizontalAlign ? w = s.x1 + 2 : "center" === this.horizontalAlign ? w = s.x1 + s.width / 2 - M.width / 2 : "right" === this.horizontalAlign && (w = s.x2 - 2 - M.width - B), G = this.horizontalAlign, this.width = M.width, this.height = M.height) : "center" ===
              this.verticalAlign && ("left" === this.horizontalAlign ? (w = s.x1 + 2, y = s.y2 - 2 - (this.maxWidth / 2 - M.width / 2), D = -90, K = "left", this.width = M.height, this.height = M.width) : "right" === this.horizontalAlign ? (w = s.x2 - 2, y = s.y1 + 2 + (this.maxWidth / 2 - M.width / 2), D = 90, K = "right", this.width = M.height, this.height = M.width) : "center" === this.horizontalAlign && (y = m.y1 + (m.height / 2 - M.height / 2), w = m.x1 + (m.width / 2 - M.width / 2), K = "center", this.width = M.width, this.height = M.height), G = "center"); H.x = w; H.y = y; H.angle = D; H.horizontalAlign = G; this._textBlock =
                H; m.layoutManager.registerSpace(K, { width: this.width + ("left" === K || "right" === K ? this.margin + 2 : 0), height: this.height + ("top" === K || "bottom" === K ? this.margin + 2 : 0) }); this.bounds = { x1: w, y1: y, x2: w + this.width, y2: y + this.height }; this.ctx.textBaseline = "top"
      }
    }; Ia.prototype.render = function () { this._textBlock && this._textBlock.render(!0) }; V(Na, K); Na.prototype.setLayout = Ia.prototype.setLayout; Na.prototype.render = Ia.prototype.render; $a.prototype.get = function (h, s) {
      var w = null; 0 < this.pool.length ? (w = this.pool.pop(), Ta(w, h,
        s)) : w = pa(h, s); return w
    }; $a.prototype.release = function (h) { this.pool.push(h) }; V(Oa, K); var Ra = { addTheme: function (h, s) { ab[h] = s }, addColorSet: function (h, s) { wa[h] = s }, addCultureInfo: function (h, s) { Qa[h] = s }, formatNumber: function (h, s, w) { w = w || "en"; if (Qa[w]) return Z(h, s || "#,##0.##", new Oa(w)); throw "Unknown Culture Name"; }, formatDate: function (h, s, w) { w = w || "en"; if (Qa[w]) return ka(h, s || "DD MMM YYYY", new Oa(w)); throw "Unknown Culture Name"; } }; "undefined" !== typeof module && "undefined" !== typeof module.exports ? module.exports =
      Ra : "function" === typeof define && define.amd ? define([], function () { return Ra }) : (window.CanvasJS && window.console && window.console.log("CanvasJS namespace already exists. If you are loading both chart and stockchart scripts, just load stockchart alone as it includes all chart features."), window.CanvasJS = window.CanvasJS ? window.CanvasJS : Ra); var Ka = Ra.Chart = function () {
        function m(a, d) { return a.x - d.x } function n(a, d, b) {
          d = d || {}; h(b) ? (this.predefinedThemes = ab, this.optionsName = this.parent = this.index = null) : (this.parent =
            b.parent, this.index = b.index, this.predefinedThemes = b.predefinedThemes, this.optionsName = b.optionsName, this.stockChart = b.stockChart, this.panel = a, this.isOptionsInArray = b.isOptionsInArray); this.theme = h(d.theme) || h(this.predefinedThemes[d.theme]) ? "light1" : d.theme; n.base.constructor.call(this, "Chart", this.optionsName, d, this.index, this.parent); var c = this; this._containerId = a; this._objectsInitialized = !1; this.overlaidCanvasCtx = this.ctx = null; this._indexLabels = []; this._panTimerId = 0; this._lastTouchEventType = "";
          this._lastTouchData = null; this.isAnimating = !1; this.renderCount = 0; this.disableToolTip = this.animatedRender = !1; this.canvasPool = new $a; this.allDOMEventHandlers = []; this.panEnabled = !1; this._defaultCursor = "default"; this.plotArea = { canvas: null, ctx: null, x1: 0, y1: 0, x2: 0, y2: 0, width: 0, height: 0 }; this._dataInRenderedOrder = []; (this.container = "string" === typeof this._containerId ? document.getElementById(this._containerId) : this._containerId) ? (this.container.innerHTML = "", d = a = 0, a = this.options.width ? this.width : 0 < this.container.clientWidth ?
            this.container.clientWidth : this.width, d = this.options.height ? this.height : 0 < this.container.clientHeight ? this.container.clientHeight : this.height, this.width = a, this.height = d, this.x1 = this.y1 = 0, this.x2 = this.width, this.y2 = this.height, this._selectedColorSet = "undefined" !== typeof wa[this.colorSet] ? wa[this.colorSet] : wa.colorSet1, this._canvasJSContainer = document.createElement("div"), this._canvasJSContainer.setAttribute("class", "canvasjs-chart-container"), this._canvasJSContainer.style.position = "relative", this._canvasJSContainer.style.textAlign =
            "left", this._canvasJSContainer.style.cursor = "auto", this._canvasJSContainer.style.direction = "ltr", s || (this._canvasJSContainer.style.height = "0px"), this.container.appendChild(this._canvasJSContainer), this.canvas = pa(a, d), this._preRenderCanvas = pa(a, d), this.canvas.style.position = "absolute", this.canvas.style.WebkitUserSelect = "none", this.canvas.style.MozUserSelect = "none", this.canvas.style.msUserSelect = "none", this.canvas.style.userSelect = "none", this.canvas.getContext && (this._canvasJSContainer.appendChild(this.canvas),
              this.ctx = this.canvas.getContext("2d"), this.ctx.textBaseline = "top", Ha(this.ctx), this._preRenderCtx = this._preRenderCanvas.getContext("2d"), this._preRenderCtx.textBaseline = "top", Ha(this._preRenderCtx), s ? this.plotArea.ctx = this.ctx : (this.plotArea.canvas = pa(a, d), this.plotArea.canvas.style.position = "absolute", this.plotArea.canvas.setAttribute("class", "plotAreaCanvas"), this._canvasJSContainer.appendChild(this.plotArea.canvas), this.plotArea.ctx = this.plotArea.canvas.getContext("2d")), this.overlaidCanvas = pa(a,
                d), this.overlaidCanvas.style.position = "absolute", this.overlaidCanvas.style.webkitTapHighlightColor = "transparent", this.overlaidCanvas.style.WebkitUserSelect = "none", this.overlaidCanvas.style.MozUserSelect = "none", this.overlaidCanvas.style.msUserSelect = "none", this.overlaidCanvas.style.userSelect = "none", this.overlaidCanvas.getContext && (this._canvasJSContainer.appendChild(this.overlaidCanvas), this.overlaidCanvasCtx = this.overlaidCanvas.getContext("2d"), this.overlaidCanvasCtx.textBaseline = "top", Ha(this.overlaidCanvasCtx)),
              this._eventManager = new Y(this), this.windowResizeHandler = y(window, "resize", function () { c._updateSize() && c.render() }, this.allDOMEventHandlers), this._toolBar = document.createElement("div"), this._toolBar.setAttribute("class", "canvasjs-chart-toolbar"), this._toolBar.style.cssText = "position: absolute; right: 1px; top: 1px;", this._canvasJSContainer.appendChild(this._toolBar), this.bounds = { x1: 0, y1: 0, x2: this.width, y2: this.height }, y(this.overlaidCanvas, "click", function (a) { c._mouseEventHandler(a) }, this.allDOMEventHandlers),
              y(this.overlaidCanvas, "mousemove", function (a) { c._mouseEventHandler(a) }, this.allDOMEventHandlers), y(this.overlaidCanvas, "mouseup", function (a) { c._mouseEventHandler(a) }, this.allDOMEventHandlers), y(this.overlaidCanvas, "mousedown", function (a) { c._mouseEventHandler(a); ya(c._dropdownMenu) }, this.allDOMEventHandlers), y(this.overlaidCanvas, "mouseout", function (a) { c._mouseEventHandler(a) }, this.allDOMEventHandlers), y(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerDown" : "touchstart", function (a) { c._touchEventHandler(a) },
                this.allDOMEventHandlers), y(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerMove" : "touchmove", function (a) { c._touchEventHandler(a) }, this.allDOMEventHandlers), y(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerUp" : "touchend", function (a) { c._touchEventHandler(a) }, this.allDOMEventHandlers), y(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerCancel" : "touchcancel", function (a) { c._touchEventHandler(a) }, this.allDOMEventHandlers), this.toolTip = new la(this, this.options.toolTip),
              this.data = null, this.axisX = [], this.axisX2 = [], this.axisY = [], this.axisY2 = [], this.sessionVariables = { axisX: [], axisX2: [], axisY: [], axisY2: [] })) : window.console && window.console.log('CanvasJS Error: Chart Container with id "' + this._containerId + '" was not found')
        } function w(a, d) {
          for (var b = [], c, e = 0; e < a.length; e++)if (0 == e) b.push(a[0]); else {
            var g, A, u; u = e - 1; g = 0 === u ? 0 : u - 1; A = u === a.length - 1 ? u : u + 1; c = Math.abs((a[A].x - a[g].x) / (0 === a[A].x - a[u].x ? 0.01 : a[A].x - a[u].x)) * (d - 1) / 2 + 1; var h = (a[A].x - a[g].x) / c; c = (a[A].y - a[g].y) /
              c; b[b.length] = a[u].x > a[g].x && 0 < h || a[u].x < a[g].x && 0 > h ? { x: a[u].x + h / 3, y: a[u].y + c / 3 } : { x: a[u].x, y: a[u].y + c / 9 }; u = e; g = 0 === u ? 0 : u - 1; A = u === a.length - 1 ? u : u + 1; c = Math.abs((a[A].x - a[g].x) / (0 === a[u].x - a[g].x ? 0.01 : a[u].x - a[g].x)) * (d - 1) / 2 + 1; h = (a[A].x - a[g].x) / c; c = (a[A].y - a[g].y) / c; b[b.length] = a[u].x > a[g].x && 0 < h || a[u].x < a[g].x && 0 > h ? { x: a[u].x - h / 3, y: a[u].y - c / 3 } : { x: a[u].x, y: a[u].y - c / 9 }; b[b.length] = a[e]
          } return b
        } function D(a, d, b, c, e, g, A, u, h, l) {
          var r = 0; l ? (A.color = g, u.color = g) : l = 1; r = h ? Math.abs(e - b) : Math.abs(c - d); r = 0 < A.trimLength ?
            Math.abs(r * A.trimLength / 100) : Math.abs(r - A.length); h ? (b += r / 2, e -= r / 2) : (d += r / 2, c -= r / 2); var r = 1 === Math.round(A.thickness) % 2 ? 0.5 : 0, p = 1 === Math.round(u.thickness) % 2 ? 0.5 : 0; a.save(); a.globalAlpha = l; a.strokeStyle = u.color || g; a.lineWidth = u.thickness || 2; a.setLineDash && a.setLineDash(R(u.dashType, u.thickness)); a.beginPath(); h && 0 < u.thickness ? (a.moveTo(c - A.thickness / 2, Math.round((b + e) / 2) - p), a.lineTo(d + A.thickness / 2, Math.round((b + e) / 2) - p)) : 0 < u.thickness && (a.moveTo(Math.round((d + c) / 2) - p, b + A.thickness / 2), a.lineTo(Math.round((d +
              c) / 2) - p, e - A.thickness / 2)); a.stroke(); a.strokeStyle = A.color || g; a.lineWidth = A.thickness || 2; a.setLineDash && a.setLineDash(R(A.dashType, A.thickness)); a.beginPath(); h && 0 < A.thickness ? (a.moveTo(c - r, b), a.lineTo(c - r, e), a.moveTo(d + r, b), a.lineTo(d + r, e)) : 0 < A.thickness && (a.moveTo(d, b + r), a.lineTo(c, b + r), a.moveTo(d, e - r), a.lineTo(c, e - r)); a.stroke(); a.restore()
        } function G(a, d) {
          G.base.constructor.call(this, "Legend", "legend", d, null, a); this.chart = a; this.canvas = a.canvas; this.ctx = this.chart.ctx; this.ghostCtx = this.chart._eventManager.ghostCtx;
          this.items = []; this.optionsName = "legend"; this.height = this.width = 0; this.orientation = null; this.dataSeries = []; this.bounds = { x1: null, y1: null, x2: null, y2: null }; "undefined" === typeof this.options.fontSize && (this.fontSize = this.chart.getAutoFontSize(this.fontSize)); this.lineHeight = fb(this.fontFamily, this.fontSize, this.fontWeight); this.horizontalSpacing = this.fontSize
        } function H(a, d, b, c) {
          H.base.constructor.call(this, "DataSeries", "data", d, b, a); this.chart = a; this.canvas = a.canvas; this._ctx = a.canvas.ctx; this.index =
            b; this.noDataPointsInPlotArea = 0; this.id = c; this.chart._eventManager.objectMap[c] = { id: c, objectType: "dataSeries", dataSeriesIndex: b }; a = d.dataPoints ? d.dataPoints.length : 0; this.dataPointEOs = []; for (d = 0; d < a; d++)this.dataPointEOs[d] = {}; this.dataPointIds = []; this.plotUnit = []; this.axisY = this.axisX = null; this.optionsName = "data"; this.isOptionsInArray = !0; null === this.fillOpacity && (this.type.match(/area/i) ? this.fillOpacity = 0.7 : this.fillOpacity = 1); this.axisPlacement = this.getDefaultAxisPlacement(); "undefined" === typeof this.options.indexLabelFontSize &&
              (this.indexLabelFontSize = this.chart.getAutoFontSize(this.indexLabelFontSize))
        } function B(a, d, b, c, e, g) {
          B.base.constructor.call(this, "Axis", d, b, c, a); this.chart = a; this.canvas = a.canvas; this.ctx = a.ctx; this.intervalStartPosition = this.maxHeight = this.maxWidth = 0; this.labels = []; this.dataSeries = []; this._stripLineLabels = this._ticks = this._labels = null; this.dataInfo = { min: Infinity, max: -Infinity, viewPortMin: Infinity, viewPortMax: -Infinity, minDiff: Infinity }; this.isOptionsInArray = !0; "axisX" === e ? ("left" === g || "bottom" ===
            g ? (this.optionsName = "axisX", h(this.chart.sessionVariables.axisX[c]) && (this.chart.sessionVariables.axisX[c] = {}), this.sessionVariables = this.chart.sessionVariables.axisX[c]) : (this.optionsName = "axisX2", h(this.chart.sessionVariables.axisX2[c]) && (this.chart.sessionVariables.axisX2[c] = {}), this.sessionVariables = this.chart.sessionVariables.axisX2[c]), this.options.interval || (this.intervalType = null)) : "left" === g || "bottom" === g ? (this.optionsName = "axisY", h(this.chart.sessionVariables.axisY[c]) && (this.chart.sessionVariables.axisY[c] =
              {}), this.sessionVariables = this.chart.sessionVariables.axisY[c]) : (this.optionsName = "axisY2", h(this.chart.sessionVariables.axisY2[c]) && (this.chart.sessionVariables.axisY2[c] = {}), this.sessionVariables = this.chart.sessionVariables.axisY2[c]); "undefined" === typeof this.options.titleFontSize && (this.titleFontSize = this.chart.getAutoFontSize(this.titleFontSize)); "undefined" === typeof this.options.labelFontSize && (this.labelFontSize = this.chart.getAutoFontSize(this.labelFontSize)); this.type = e; "axisX" !== e || b && "undefined" !==
                typeof b.gridThickness || (this.gridThickness = 0); this._position = g; this.lineCoordinates = { x1: null, y1: null, x2: null, y2: null, width: null }; this.labelAngle = (this.labelAngle % 360 + 360) % 360; 90 < this.labelAngle && 270 > this.labelAngle ? this.labelAngle -= 180 : 270 <= this.labelAngle && 360 >= this.labelAngle && (this.labelAngle -= 360); this.options.scaleBreaks && (this.scaleBreaks = new N(this.chart, this.options.scaleBreaks, ++this.chart._eventManager.lastObjectId, this)); this.stripLines = []; if (this.options.stripLines && 0 < this.options.stripLines.length) for (a =
                  0; a < this.options.stripLines.length; a++)this.stripLines.push(new M(this.chart, this.options.stripLines[a], a, ++this.chart._eventManager.lastObjectId, this)); this.options.crosshair && (this.crosshair = new T(this.chart, this.options.crosshair, this)); this._titleTextBlock = null; this.hasOptionChanged("viewportMinimum") && null === this.viewportMinimum && (this.options.viewportMinimum = void 0, this.sessionVariables.viewportMinimum = null); this.hasOptionChanged("viewportMinimum") || isNaN(this.sessionVariables.newViewportMinimum) ||
                    null === this.sessionVariables.newViewportMinimum ? this.sessionVariables.newViewportMinimum = null : this.viewportMinimum = this.sessionVariables.newViewportMinimum; this.hasOptionChanged("viewportMaximum") && null === this.viewportMaximum && (this.options.viewportMaximum = void 0, this.sessionVariables.viewportMaximum = null); this.hasOptionChanged("viewportMaximum") || isNaN(this.sessionVariables.newViewportMaximum) || null === this.sessionVariables.newViewportMaximum ? this.sessionVariables.newViewportMaximum = null : this.viewportMaximum =
                      this.sessionVariables.newViewportMaximum; null !== this.minimum && null !== this.viewportMinimum && (this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum)); null !== this.maximum && null !== this.viewportMaximum && (this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum)); this.trackChanges("viewportMinimum"); this.trackChanges("viewportMaximum")
        } function N(a, d, b, c) {
          N.base.constructor.call(this, "ScaleBreaks", "scaleBreaks", d, null, c); this.id = b; this.chart = a; this.ctx = this.chart.ctx; this.axis = c; this.optionsName =
            "scaleBreaks"; this.isOptionsInArray = !1; this._appliedBreaks = []; this.customBreaks = []; this.autoBreaks = []; "string" === typeof this.spacing ? (this.spacing = parseFloat(this.spacing), this.spacing = isNaN(this.spacing) ? 8 : (10 < this.spacing ? 10 : this.spacing) + "%") : "number" !== typeof this.spacing && (this.spacing = 8); this.autoCalculate && (this.maxNumberOfAutoBreaks = Math.min(this.maxNumberOfAutoBreaks, 5)); if (this.options.customBreaks && 0 < this.options.customBreaks.length) {
              for (a = 0; a < this.options.customBreaks.length; a++)this.customBreaks.push(new W(this.chart,
                "customBreaks", this.options.customBreaks[a], a, ++this.chart._eventManager.lastObjectId, this)), "number" === typeof this.customBreaks[a].startValue && ("number" === typeof this.customBreaks[a].endValue && this.customBreaks[a].endValue !== this.customBreaks[a].startValue) && this._appliedBreaks.push(this.customBreaks[a]); this._appliedBreaks.sort(function (a, c) { return a.startValue - c.startValue }); for (a = 0; a < this._appliedBreaks.length - 1; a++)this._appliedBreaks[a].endValue >= this._appliedBreaks[a + 1].startValue && (this._appliedBreaks[a].endValue =
                  Math.max(this._appliedBreaks[a].endValue, this._appliedBreaks[a + 1].endValue), window.console && window.console.log("CanvasJS Error: Breaks " + a + " and " + (a + 1) + " are overlapping."), this._appliedBreaks.splice(a, 2), a--)
            }
        } function W(a, d, b, c, e, g) {
          W.base.constructor.call(this, "Break", d, b, c, g); this.id = e; this.chart = a; this.ctx = this.chart.ctx; this.scaleBreaks = g; this.optionsName = d; this.isOptionsInArray = !0; this.type = b.type ? this.type : g.type; this.fillOpacity = h(b.fillOpacity) ? g.fillOpacity : this.fillOpacity; this.lineThickness =
            h(b.lineThickness) ? g.lineThickness : this.lineThickness; this.color = b.color ? this.color : g.color; this.lineColor = b.lineColor ? this.lineColor : g.lineColor; this.lineDashType = b.lineDashType ? this.lineDashType : g.lineDashType; !h(this.startValue) && this.startValue.getTime && (this.startValue = this.startValue.getTime()); !h(this.endValue) && this.endValue.getTime && (this.endValue = this.endValue.getTime()); "number" === typeof this.startValue && ("number" === typeof this.endValue && this.endValue < this.startValue) && (a = this.startValue,
              this.startValue = this.endValue, this.endValue = a); this.spacing = "undefined" === typeof b.spacing ? g.spacing : b.spacing; "string" === typeof this.options.spacing ? (this.spacing = parseFloat(this.spacing), this.spacing = isNaN(this.spacing) ? 0 : (10 < this.spacing ? 10 : this.spacing) + "%") : "number" !== typeof this.options.spacing && (this.spacing = g.spacing); this.size = g.parent.logarithmic ? 1 : 0
        } function M(a, d, b, c, e) {
          M.base.constructor.call(this, "StripLine", "stripLines", d, b, e); this.id = c; this.chart = a; this.ctx = this.chart.ctx; this.label =
            this.label; this.axis = e; this.optionsName = "stripLines"; this.isOptionsInArray = !0; this._thicknessType = "pixel"; null !== this.startValue && null !== this.endValue && (this.value = e.logarithmic ? Math.sqrt((this.startValue.getTime ? this.startValue.getTime() : this.startValue) * (this.endValue.getTime ? this.endValue.getTime() : this.endValue)) : ((this.startValue.getTime ? this.startValue.getTime() : this.startValue) + (this.endValue.getTime ? this.endValue.getTime() : this.endValue)) / 2, this._thicknessType = null)
        } function T(a, d, b) {
          T.base.constructor.call(this,
            "Crosshair", "crosshair", d, null, b); this.chart = a; this.ctx = this.chart.ctx; this.axis = b; this.optionsName = "crosshair"; this._thicknessType = "pixel"
        } function la(a, d) {
          la.base.constructor.call(this, "ToolTip", "toolTip", d, null, a); this.chart = a; this.canvas = a.canvas; this.ctx = this.chart.ctx; this.currentDataPointIndex = this.currentSeriesIndex = -1; this._prevY = this._prevX = NaN; this.containerTransitionDuration = 0.1; this.mozContainerTransition = this.getContainerTransition(this.containerTransitionDuration); this.optionsName =
            "toolTip"; this._initialize()
        } function Y(a) { this.chart = a; this.lastObjectId = 0; this.objectMap = []; this.rectangularRegionEventSubscriptions = []; this.previousDataPointEventObject = null; this.ghostCanvas = pa(this.chart.width, this.chart.height); this.ghostCtx = this.ghostCanvas.getContext("2d"); this.mouseoveredObjectMaps = [] } function ha(a) { this.chart = a; this.ctx = this.chart.plotArea.ctx; this.animations = []; this.animationRequestId = null } V(n, K); n.prototype.destroy = function () {
          var a = this.allDOMEventHandlers; this._animator &&
            this._animator.cancelAllAnimations(); this._panTimerId && clearTimeout(this._panTimerId); for (var d = 0; d < a.length; d++)hb(a[d][0], a[d][1], a[d][2], a[d][3]); this.allDOMEventHandlers = []; for (this.removeAllEventListeners(); this._canvasJSContainer && this._canvasJSContainer.hasChildNodes();)this._canvasJSContainer.removeChild(this._canvasJSContainer.lastChild); for (; this.container && this.container.hasChildNodes();)this.container.removeChild(this.container.lastChild); for (; this._dropdownMenu && this._dropdownMenu.hasChildNodes();)this._dropdownMenu.removeChild(this._dropdownMenu.lastChild);
          this.overlaidCanvas = this.canvas = this.container = this._canvasJSContainer = null; this._toolBar = this._dropdownMenu = this._menuButton = this._resetButton = this._zoomButton = this._breaksCanvas = this._preRenderCanvas = this.toolTip.container = null
        }; n.prototype._updateOptions = function () {
          var a = this; this.updateOption("width"); this.updateOption("height"); this.updateOption("dataPointWidth"); this.updateOption("dataPointMinWidth"); this.updateOption("dataPointMaxWidth"); this.updateOption("interactivityEnabled"); this.updateOption("theme");
          this.updateOption("colorSet") && (this._selectedColorSet = "undefined" !== typeof wa[this.colorSet] ? wa[this.colorSet] : wa.colorSet1); this.updateOption("backgroundColor"); this.backgroundColor || (this.backgroundColor = "rgba(0,0,0,0)"); this.updateOption("culture"); this._cultureInfo = new Oa(this.options.culture); this.updateOption("animationEnabled"); this.animationEnabled = this.animationEnabled && s; this.updateOption("animationDuration"); this.updateOption("rangeChanging"); this.updateOption("rangeChanged"); this.updateOption("exportEnabled");
          this.updateOption("exportFileName"); this.updateOption("zoomType"); if (this.options.zoomEnabled || this.panEnabled) {
            if (!this._zoomButton) {
              var d = !1; ya(this._zoomButton = document.createElement("button")); Ba(this, this._zoomButton, "pan"); this._toolBar.appendChild(this._zoomButton); this._zoomButton.style.borderRight = this.toolbar.borderThickness + "px solid " + this.toolbar.borderColor; y(this._zoomButton, "touchstart", function (a) { d = !0 }, this.allDOMEventHandlers); y(this._zoomButton, "click", function () {
                a.zoomEnabled ?
                  (a.zoomEnabled = !1, a.panEnabled = !0, Ba(a, a._zoomButton, "zoom")) : (a.zoomEnabled = !0, a.panEnabled = !1, Ba(a, a._zoomButton, "pan")); a.render()
              }, this.allDOMEventHandlers); y(this._zoomButton, "mouseover", function () { d ? d = !1 : (ua(a, a._zoomButton, { backgroundColor: a.toolbar.backgroundColorOnHover, color: a.toolbar.fontColorOnHover, transition: "0.4s", WebkitTransition: "0.4s" }), 0 >= navigator.userAgent.search("MSIE") && ua(a, a._zoomButton.childNodes[0], { WebkitFilter: "invert(100%)", filter: "invert(100%)" })) }, this.allDOMEventHandlers);
              y(this._zoomButton, "mouseout", function () { d || (ua(a, a._zoomButton, { backgroundColor: a.toolbar.backgroundColor, color: a.toolbar.fontColor, transition: "0.4s", WebkitTransition: "0.4s" }), 0 >= navigator.userAgent.search("MSIE") && ua(a, a._zoomButton.childNodes[0], { WebkitFilter: "invert(0%)", filter: "invert(0%)" })) }, this.allDOMEventHandlers)
            } this._resetButton || (d = !1, ya(this._resetButton = document.createElement("button")), Ba(this, this._resetButton, "reset"), this._resetButton.style.borderRight = (this.exportEnabled ? this.toolbar.borderThickness :
              0) + "px solid " + this.toolbar.borderColor, this._toolBar.appendChild(this._resetButton), y(this._resetButton, "touchstart", function (a) { d = !0 }, this.allDOMEventHandlers), y(this._resetButton, "click", function () {
                a.toolTip.hide(); a.toolTip.dispatchEvent("hidden", { chart: a, toolTip: a.toolTip }, a.toolTip); a.zoomEnabled || a.panEnabled ? (a.zoomEnabled = !0, a.panEnabled = !1, Ba(a, a._zoomButton, "pan"), a._defaultCursor = "default", a.overlaidCanvas.style.cursor = a._defaultCursor) : (a.zoomEnabled = !1, a.panEnabled = !1); if (a.sessionVariables.axisX) for (var c =
                  0; c < a.sessionVariables.axisX.length; c++)a.sessionVariables.axisX[c].newViewportMinimum = null, a.sessionVariables.axisX[c].newViewportMaximum = null; if (a.sessionVariables.axisX2) for (c = 0; c < a.sessionVariables.axisX2.length; c++)a.sessionVariables.axisX2[c].newViewportMinimum = null, a.sessionVariables.axisX2[c].newViewportMaximum = null; if (a.sessionVariables.axisY) for (c = 0; c < a.sessionVariables.axisY.length; c++)a.sessionVariables.axisY[c].newViewportMinimum = null, a.sessionVariables.axisY[c].newViewportMaximum = null;
                if (a.sessionVariables.axisY2) for (c = 0; c < a.sessionVariables.axisY2.length; c++)a.sessionVariables.axisY2[c].newViewportMinimum = null, a.sessionVariables.axisY2[c].newViewportMaximum = null; a.resetOverlayedCanvas(); ya(a._zoomButton, a._resetButton); a.stockChart && (a.stockChart._rangeEventParameter = { stockChart: a.stockChart, source: "chart", index: a.stockChart.charts.indexOf(a), minimum: null, maximum: null }); a._dispatchRangeEvent("rangeChanging", "reset"); a.stockChart && (a.stockChart._rangeEventParameter.type = "rangeChanging",
                  a.stockChart.dispatchEvent("rangeChanging", a.stockChart._rangeEventParameter, a.stockChart)); a.render(); a.syncCharts && a.syncCharts(null, null); a._dispatchRangeEvent("rangeChanged", "reset"); a.stockChart && (a.stockChart._rangeEventParameter.type = "rangeChanged", a.stockChart.dispatchEvent("rangeChanged", a.stockChart._rangeEventParameter, a.stockChart))
              }, this.allDOMEventHandlers), y(this._resetButton, "mouseover", function () {
                d || (ua(a, a._resetButton, {
                  backgroundColor: a.toolbar.backgroundColorOnHover, color: a.toolbar.hoverFfontColorOnHoverontColor,
                  transition: "0.4s", WebkitTransition: "0.4s"
                }), 0 >= navigator.userAgent.search("MSIE") && ua(a, a._resetButton.childNodes[0], { WebkitFilter: "invert(100%)", filter: "invert(100%)" }))
              }, this.allDOMEventHandlers), y(this._resetButton, "mouseout", function () { d || (ua(a, a._resetButton, { backgroundColor: a.toolbar.backgroundColor, color: a.toolbar.fontColor, transition: "0.4s", WebkitTransition: "0.4s" }), 0 >= navigator.userAgent.search("MSIE") && ua(a, a._resetButton.childNodes[0], { WebkitFilter: "invert(0%)", filter: "invert(0%)" })) },
                this.allDOMEventHandlers), this.overlaidCanvas.style.cursor = a._defaultCursor); this.zoomEnabled || this.panEnabled || (this._zoomButton ? (a._zoomButton.getAttribute("state") === a._cultureInfo.zoomText ? (this.panEnabled = !0, this.zoomEnabled = !1) : (this.zoomEnabled = !0, this.panEnabled = !1), Sa(a._zoomButton, a._resetButton)) : (this.zoomEnabled = !0, this.panEnabled = !1))
          } else this.panEnabled = this.zoomEnabled = !1; ib(this); "none" !== this._toolBar.style.display && this._zoomButton && (this.panEnabled ? Ba(a, a._zoomButton, "zoom") :
            Ba(a, a._zoomButton, "pan"), a._resetButton.getAttribute("state") !== a._cultureInfo.resetText && Ba(a, a._resetButton, "reset")); this.options.toolTip && this.toolTip.options !== this.options.toolTip && (this.toolTip.options = this.options.toolTip); for (var b in this.toolTip.options) this.toolTip.options.hasOwnProperty(b) && this.toolTip.updateOption(b)
        }; n.prototype._updateSize = function () { return mb.call(this, [this.canvas, this.overlaidCanvas, this._eventManager.ghostCanvas]) }; n.prototype._initialize = function () {
          this.isNavigator =
            h(this.parent) || h(this.parent._defaultsKey) || "Navigator" !== this.parent._defaultsKey ? !1 : !0; this.toolbar = new Wa(this, this.options.toolbar); this._animator ? this._animator.cancelAllAnimations() : this._animator = new ha(this); this.removeAllEventListeners(); this.disableToolTip = !1; this._axes = []; this.funnelPyramidClickHandler = this.pieDoughnutClickHandler = null; this._updateOptions(); this.animatedRender = s && this.animationEnabled && 0 === this.renderCount; this._updateSize(); this.clearCanvas(); this.ctx.beginPath(); this.axisX =
              []; this.axisX2 = []; this.axisY = []; this.axisY2 = []; this._indexLabels = []; this._dataInRenderedOrder = []; this._events = []; this._eventManager && this._eventManager.reset(); this.plotInfo = { axisPlacement: null, plotTypes: [] }; this.layoutManager = new La(0, 0, this.width, this.height, this.isNavigator ? 0 : 2); this.plotArea.layoutManager && this.plotArea.layoutManager.reset(); this.data = []; var a = 0, d = null; if (this.options.data) {
                for (var b = 0; b < this.options.data.length; b++)if (a++, !this.options.data[b].type || 0 <= n._supportedChartTypes.indexOf(this.options.data[b].type)) {
                  var c =
                    new H(this, this.options.data[b], a - 1, ++this._eventManager.lastObjectId); "error" === c.type && (c.linkedDataSeriesIndex = h(this.options.data[b].linkedDataSeriesIndex) ? b - 1 : this.options.data[b].linkedDataSeriesIndex, 0 > c.linkedDataSeriesIndex || c.linkedDataSeriesIndex >= this.options.data.length || "number" !== typeof c.linkedDataSeriesIndex || "error" === this.options.data[c.linkedDataSeriesIndex].type) && (c.linkedDataSeriesIndex = null); null === c.name && (c.name = "DataSeries " + a); null === c.color ? 1 < this.options.data.length ?
                      (c._colorSet = [this._selectedColorSet[c.index % this._selectedColorSet.length]], c.color = this._selectedColorSet[c.index % this._selectedColorSet.length]) : c._colorSet = "line" === c.type || "stepLine" === c.type || "spline" === c.type || "area" === c.type || "stepArea" === c.type || "splineArea" === c.type || "stackedArea" === c.type || "stackedArea100" === c.type || "rangeArea" === c.type || "rangeSplineArea" === c.type || "candlestick" === c.type || "ohlc" === c.type || "waterfall" === c.type || "boxAndWhisker" === c.type ? [this._selectedColorSet[0]] : this._selectedColorSet :
                      c._colorSet = [c.color]; null === c.markerSize && (("line" === c.type || "stepLine" === c.type || "spline" === c.type || 0 <= c.type.toLowerCase().indexOf("area")) && c.dataPoints && c.dataPoints.length < this.width / 16 || "scatter" === c.type) && (c.markerSize = 8); "bubble" !== c.type && "scatter" !== c.type || !c.dataPoints || (c.dataPoints.some ? c.dataPoints.some(function (a) { return a.x }) && c.dataPoints.sort(m) : c.dataPoints.sort(m)); this.data.push(c); var e = c.axisPlacement, d = d || e, g; "normal" === e ? "xySwapped" === this.plotInfo.axisPlacement ? g = 'You cannot combine "' +
                        c.type + '" with bar chart' : "none" === this.plotInfo.axisPlacement ? g = 'You cannot combine "' + c.type + '" with pie chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = "normal") : "xySwapped" === e ? "normal" === this.plotInfo.axisPlacement ? g = 'You cannot combine "' + c.type + '" with line, area, column or pie chart' : "none" === this.plotInfo.axisPlacement ? g = 'You cannot combine "' + c.type + '" with pie chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = "xySwapped") : "none" === e ? "normal" ===
                          this.plotInfo.axisPlacement ? g = 'You cannot combine "' + c.type + '" with line, area, column or bar chart' : "xySwapped" === this.plotInfo.axisPlacement ? g = 'You cannot combine "' + c.type + '" with bar chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = "none") : null === e && "none" === this.plotInfo.axisPlacement && (g = 'You cannot combine "' + c.type + '" with pie chart'); if (g && window.console) { window.console.log(g); return }
                } for (b = 0; b < this.data.length; b++) {
                  if ("none" == d && "error" === this.data[b].type && window.console) {
                    window.console.log('You cannot combine "' +
                      c.type + '" with error chart'); return
                  } "error" === this.data[b].type && (this.data[b].axisPlacement = this.plotInfo.axisPlacement = d || "normal", this.data[b]._linkedSeries = null === this.data[b].linkedDataSeriesIndex ? null : this.data[this.data[b].linkedDataSeriesIndex])
                }
              } this._objectsInitialized = !0; this._plotAreaElements = []
        }; n._supportedChartTypes = Ea("line stepLine spline column area stepArea splineArea bar bubble scatter stackedColumn stackedColumn100 stackedBar stackedBar100 stackedArea stackedArea100 candlestick ohlc boxAndWhisker rangeColumn error rangeBar rangeArea rangeSplineArea pie doughnut funnel pyramid waterfall".split(" "));
        n.prototype.setLayout = function () {
          for (var a = this._plotAreaElements, d = 0; d < this.data.length; d++)if ("normal" === this.plotInfo.axisPlacement || "xySwapped" === this.plotInfo.axisPlacement) {
            if (!this.data[d].axisYType || "primary" === this.data[d].axisYType) if (this.options.axisY && 0 < this.options.axisY.length) {
              if (!this.axisY.length) for (var b = 0; b < this.options.axisY.length; b++)"normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY[b] = new B(this, "axisY", this.options.axisY[b], b, "axisY", "left")) : "xySwapped" ===
                this.plotInfo.axisPlacement && this._axes.push(this.axisY[b] = new B(this, "axisY", this.options.axisY[b], b, "axisY", "bottom")); this.data[d].axisY = this.axisY[0 <= this.data[d].axisYIndex && this.data[d].axisYIndex < this.axisY.length ? this.data[d].axisYIndex : 0]; this.axisY[0 <= this.data[d].axisYIndex && this.data[d].axisYIndex < this.axisY.length ? this.data[d].axisYIndex : 0].dataSeries.push(this.data[d])
            } else this.axisY.length || ("normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY[0] = new B(this, "axisY", this.options.axisY,
              0, "axisY", "left")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisY[0] = new B(this, "axisY", this.options.axisY, 0, "axisY", "bottom"))), this.data[d].axisY = this.axisY[0], this.axisY[0].dataSeries.push(this.data[d]); if ("secondary" === this.data[d].axisYType) if (this.options.axisY2 && 0 < this.options.axisY2.length) {
                if (!this.axisY2.length) for (b = 0; b < this.options.axisY2.length; b++)"normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY2[b] = new B(this, "axisY2", this.options.axisY2[b], b,
                  "axisY", "right")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisY2[b] = new B(this, "axisY2", this.options.axisY2[b], b, "axisY", "top")); this.data[d].axisY = this.axisY2[0 <= this.data[d].axisYIndex && this.data[d].axisYIndex < this.axisY2.length ? this.data[d].axisYIndex : 0]; this.axisY2[0 <= this.data[d].axisYIndex && this.data[d].axisYIndex < this.axisY2.length ? this.data[d].axisYIndex : 0].dataSeries.push(this.data[d])
              } else this.axisY2.length || ("normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY2[0] =
                new B(this, "axisY2", this.options.axisY2, 0, "axisY", "right")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisY2[0] = new B(this, "axisY2", this.options.axisY2, 0, "axisY", "top"))), this.data[d].axisY = this.axisY2[0], this.axisY2[0].dataSeries.push(this.data[d]); if (!this.data[d].axisXType || "primary" === this.data[d].axisXType) if (this.options.axisX && 0 < this.options.axisX.length) {
                  if (!this.axisX.length) for (b = 0; b < this.options.axisX.length; b++)"normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX[b] =
                    new B(this, "axisX", this.options.axisX[b], b, "axisX", "bottom")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisX[b] = new B(this, "axisX", this.options.axisX[b], b, "axisX", "left")); this.data[d].axisX = this.axisX[0 <= this.data[d].axisXIndex && this.data[d].axisXIndex < this.axisX.length ? this.data[d].axisXIndex : 0]; this.axisX[0 <= this.data[d].axisXIndex && this.data[d].axisXIndex < this.axisX.length ? this.data[d].axisXIndex : 0].dataSeries.push(this.data[d])
                } else this.axisX.length || ("normal" === this.plotInfo.axisPlacement ?
                  this._axes.push(this.axisX[0] = new B(this, "axisX", this.options.axisX, 0, "axisX", "bottom")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisX[0] = new B(this, "axisX", this.options.axisX, 0, "axisX", "left"))), this.data[d].axisX = this.axisX[0], this.axisX[0].dataSeries.push(this.data[d]); if ("secondary" === this.data[d].axisXType) if (this.options.axisX2 && 0 < this.options.axisX2.length) {
                    if (!this.axisX2.length) for (b = 0; b < this.options.axisX2.length; b++)"normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX2[b] =
                      new B(this, "axisX2", this.options.axisX2[b], b, "axisX", "top")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisX2[b] = new B(this, "axisX2", this.options.axisX2[b], b, "axisX", "right")); this.data[d].axisX = this.axisX2[0 <= this.data[d].axisXIndex && this.data[d].axisXIndex < this.axisX2.length ? this.data[d].axisXIndex : 0]; this.axisX2[0 <= this.data[d].axisXIndex && this.data[d].axisXIndex < this.axisX2.length ? this.data[d].axisXIndex : 0].dataSeries.push(this.data[d])
                  } else this.axisX2.length || ("normal" ===
                    this.plotInfo.axisPlacement ? this._axes.push(this.axisX2[0] = new B(this, "axisX2", this.options.axisX2, 0, "axisX", "top")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisX2[0] = new B(this, "axisX2", this.options.axisX2, 0, "axisX", "right"))), this.data[d].axisX = this.axisX2[0], this.axisX2[0].dataSeries.push(this.data[d])
          } if (this.axisY) {
            for (b = 1; b < this.axisY.length; b++)"undefined" === typeof this.axisY[b].options.gridThickness && (this.axisY[b].gridThickness = 0); for (b = 0; b < this.axisY.length - 1; b++)"undefined" ===
              typeof this.axisY[b].options.margin && (this.axisY[b].margin = 10)
          } if (this.axisY2) { for (b = 1; b < this.axisY2.length; b++)"undefined" === typeof this.axisY2[b].options.gridThickness && (this.axisY2[b].gridThickness = 0); for (b = 0; b < this.axisY2.length - 1; b++)"undefined" === typeof this.axisY2[b].options.margin && (this.axisY2[b].margin = 10) } this.axisY && 0 < this.axisY.length && (this.axisY2 && 0 < this.axisY2.length) && (0 < this.axisY[0].gridThickness && "undefined" === typeof this.axisY2[0].options.gridThickness ? this.axisY2[0].gridThickness =
            0 : 0 < this.axisY2[0].gridThickness && "undefined" === typeof this.axisY[0].options.gridThickness && (this.axisY[0].gridThickness = 0)); if (this.axisX) for (b = 0; b < this.axisX.length; b++)"undefined" === typeof this.axisX[b].options.gridThickness && (this.axisX[b].gridThickness = 0); if (this.axisX2) for (b = 0; b < this.axisX2.length; b++)"undefined" === typeof this.axisX2[b].options.gridThickness && (this.axisX2[b].gridThickness = 0); this.axisX && 0 < this.axisX.length && (this.axisX2 && 0 < this.axisX2.length) && (0 < this.axisX[0].gridThickness &&
              "undefined" === typeof this.axisX2[0].options.gridThickness ? this.axisX2[0].gridThickness = 0 : 0 < this.axisX2[0].gridThickness && "undefined" === typeof this.axisX[0].options.gridThickness && (this.axisX[0].gridThickness = 0)); b = !1; if (0 < this._axes.length && this.options.zoomEnabled && (this.zoomEnabled || this.panEnabled)) for (d = 0; d < this._axes.length; d++)if (null !== this._axes[d].viewportMinimum || null !== this._axes[d].viewportMaximum) { b = !0; break } b ? (Sa(this._zoomButton, this._resetButton), this._toolBar.style.border = this.toolbar.borderThickness +
                "px solid " + this.toolbar.borderColor, this._zoomButton.style.borderRight = this.toolbar.borderThickness + "px solid " + this.toolbar.borderColor, this._resetButton.style.borderRight = (this.exportEnabled ? this.toolbar.borderThickness : 0) + "px solid " + this.toolbar.borderColor) : (ya(this._zoomButton, this._resetButton), this._toolBar.style.border = this.toolbar.borderThickness + "px solid transparent", this.options.zoomEnabled && (this.zoomEnabled = !0, this.panEnabled = !1)); sb(this); this._processData(); this.options.title && (this.title =
                  new Ia(this, this.options.title), this.title.dockInsidePlotArea ? a.push(this.title) : this.title.setLayout()); this.subtitles = []; if (this.options.subtitles) for (d = 0; d < this.options.subtitles.length; d++)b = new Na(this, this.options.subtitles[d], d), this.subtitles.push(b), b.dockInsidePlotArea ? a.push(b) : b.setLayout(); this.legend = new G(this, this.options.legend); for (d = 0; d < this.data.length; d++)(this.data[d].showInLegend || "pie" === this.data[d].type || "doughnut" === this.data[d].type || "funnel" === this.data[d].type || "pyramid" ===
                    this.data[d].type) && this.legend.dataSeries.push(this.data[d]); this.legend.dockInsidePlotArea ? a.push(this.legend) : this.legend.setLayout(); for (d = 0; d < this._axes.length; d++)if (this._axes[d].scaleBreaks && this._axes[d].scaleBreaks._appliedBreaks.length) { s ? (this._breaksCanvas = pa(this.width, this.height, !0), this._breaksCanvasCtx = this._breaksCanvas.getContext("2d")) : (this._breaksCanvas = this.canvas, this._breaksCanvasCtx = this.ctx); break } this._preRenderCanvas = pa(this.width, this.height); this._preRenderCtx = this._preRenderCanvas.getContext("2d");
          "normal" !== this.plotInfo.axisPlacement && "xySwapped" !== this.plotInfo.axisPlacement || B.setLayout(this.axisX, this.axisX2, this.axisY, this.axisY2, this.plotInfo.axisPlacement, this.layoutManager.getFreeSpace())
        }; n.prototype.renderElements = function () {
          var a = this._plotAreaElements; this.title && !this.title.dockInsidePlotArea && this.title.render(); for (var d = 0; d < this.subtitles.length; d++)this.subtitles[d].dockInsidePlotArea || this.subtitles[d].render(); this.legend.dockInsidePlotArea || this.legend.render(); if ("normal" ===
            this.plotInfo.axisPlacement || "xySwapped" === this.plotInfo.axisPlacement) B.render(this.axisX, this.axisX2, this.axisY, this.axisY2, this.plotInfo.axisPlacement); else if ("none" === this.plotInfo.axisPlacement) this.preparePlotArea(); else return; for (d = 0; d < a.length; d++)a[d].setLayout(), a[d].render(); var b = []; if (this.animatedRender) { var c = pa(this.width, this.height); c.getContext("2d").drawImage(this.canvas, 0, 0, this.width, this.height) } tb(this); var a = this.ctx.miterLimit, e; this.ctx.miterLimit = 3; s && this._breaksCanvas &&
              (this._preRenderCtx.drawImage(this.canvas, 0, 0, this.width, this.height), this._preRenderCtx.drawImage(this._breaksCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx.globalCompositeOperation = "source-atop", this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), this._preRenderCtx.clearRect(0, 0, this.width, this.height)); for (d = 0; d < this.plotInfo.plotTypes.length; d++)for (var g = this.plotInfo.plotTypes[d], A = 0; A < g.plotUnits.length; A++) {
                var u = g.plotUnits[A], h = null; u.targetCanvas =
                  null; this.animatedRender && (u.targetCanvas = pa(this.width, this.height), u.targetCanvasCtx = u.targetCanvas.getContext("2d"), e = u.targetCanvasCtx.miterLimit, u.targetCanvasCtx.miterLimit = 3); "line" === u.type ? h = this.renderLine(u) : "stepLine" === u.type ? h = this.renderStepLine(u) : "spline" === u.type ? h = this.renderSpline(u) : "column" === u.type ? h = this.renderColumn(u) : "bar" === u.type ? h = this.renderBar(u) : "area" === u.type ? h = this.renderArea(u) : "stepArea" === u.type ? h = this.renderStepArea(u) : "splineArea" === u.type ? h = this.renderSplineArea(u) :
                    "stackedColumn" === u.type ? h = this.renderStackedColumn(u) : "stackedColumn100" === u.type ? h = this.renderStackedColumn100(u) : "stackedBar" === u.type ? h = this.renderStackedBar(u) : "stackedBar100" === u.type ? h = this.renderStackedBar100(u) : "stackedArea" === u.type ? h = this.renderStackedArea(u) : "stackedArea100" === u.type ? h = this.renderStackedArea100(u) : "bubble" === u.type ? h = h = this.renderBubble(u) : "scatter" === u.type ? h = this.renderScatter(u) : "pie" === u.type ? this.renderPie(u) : "doughnut" === u.type ? this.renderPie(u) : "funnel" === u.type ?
                      h = this.renderFunnel(u) : "pyramid" === u.type ? h = this.renderFunnel(u) : "candlestick" === u.type ? h = this.renderCandlestick(u) : "ohlc" === u.type ? h = this.renderCandlestick(u) : "rangeColumn" === u.type ? h = this.renderRangeColumn(u) : "error" === u.type ? h = this.renderError(u) : "rangeBar" === u.type ? h = this.renderRangeBar(u) : "rangeArea" === u.type ? h = this.renderRangeArea(u) : "rangeSplineArea" === u.type ? h = this.renderRangeSplineArea(u) : "waterfall" === u.type ? h = this.renderWaterfall(u) : "boxAndWhisker" === u.type && (h = this.renderBoxAndWhisker(u));
                for (var l = 0; l < u.dataSeriesIndexes.length; l++)this._dataInRenderedOrder.push(this.data[u.dataSeriesIndexes[l]]); this.animatedRender && (u.targetCanvasCtx.miterLimit = e, h && b.push(h))
              } this.ctx.miterLimit = a; this.animatedRender && this._breaksCanvasCtx && b.push({ source: this._breaksCanvasCtx, dest: this.plotArea.ctx, animationCallback: v.fadeInAnimation, easingFunction: v.easing.easeInQuad, animationBase: 0, startTimePercent: 0.7 }); this.animatedRender && 0 < this._indexLabels.length && (e = pa(this.width, this.height).getContext("2d"),
                b.push(this.renderIndexLabels(e))); var r = this; if (0 < b.length) r.disableToolTip = !0, r._animator.animate(200, r.animationDuration, function (a) {
                  r.ctx.clearRect(0, 0, r.width, r.height); r.ctx.drawImage(c, 0, 0, Math.floor(r.width * ga), Math.floor(r.height * ga), 0, 0, r.width, r.height); for (var d = 0; d < b.length; d++)h = b[d], 1 > a && "undefined" !== typeof h.startTimePercent ? a >= h.startTimePercent && h.animationCallback(h.easingFunction(a - h.startTimePercent, 0, 1, 1 - h.startTimePercent), h) : h.animationCallback(h.easingFunction(a, 0, 1, 1), h);
                  r.dispatchEvent("dataAnimationIterationEnd", { chart: r })
                }, function () { b = []; for (var a = 0; a < r.plotInfo.plotTypes.length; a++)for (var d = r.plotInfo.plotTypes[a], e = 0; e < d.plotUnits.length; e++)d.plotUnits[e].targetCanvas = null; c = null; r.disableToolTip = !1; r.dispatchEvent("dataAnimationEnd", { chart: r }) }); else {
            if (r._breaksCanvas) if (s) r.plotArea.ctx.drawImage(r._breaksCanvas, 0, 0, this.width, this.height); else for (l = 0; l < r._axes.length; l++)r._axes[l].createMask(); 0 < r._indexLabels.length && r.renderIndexLabels(); r.dispatchEvent("dataAnimationIterationEnd",
              { chart: r }); r.dispatchEvent("dataAnimationEnd", { chart: r })
          } this.attachPlotAreaEventHandlers(); this.zoomEnabled || (this.panEnabled || !this._zoomButton || "none" === this._zoomButton.style.display) || ya(this._zoomButton, this._resetButton); this.toolTip._updateToolTip(); this.renderCount++; Ma && (r = this, setTimeout(function () { var a = document.getElementById("ghostCanvasCopy"); a && (Ta(a, r.width, r.height), a.getContext("2d").drawImage(r._eventManager.ghostCanvas, 0, 0)) }, 2E3)); this._breaksCanvas && (delete this._breaksCanvas,
            delete this._breaksCanvasCtx); for (l = 0; l < this._axes.length; l++)this._axes[l].maskCanvas && (delete this._axes[l].maskCanvas, delete this._axes[l].maskCtx)
        }; n.prototype.render = function (a) { a && (this.options = a); this._initialize(); this.setLayout(); this.renderElements(); this._preRenderCanvas = null }; n.prototype.attachPlotAreaEventHandlers = function () {
          this.attachEvent({
            context: this, chart: this, mousedown: this._plotAreaMouseDown, mouseup: this._plotAreaMouseUp, mousemove: this._plotAreaMouseMove, cursor: this.panEnabled ?
              "move" : "default", capture: !0, bounds: this.plotArea
          })
        }; n.prototype.categoriseDataSeries = function () {
          for (var a = "", d = 0; d < this.data.length; d++)if (a = this.data[d], a.dataPoints && (0 !== a.dataPoints.length && a.visible) && 0 <= n._supportedChartTypes.indexOf(a.type)) {
            for (var b = null, c = !1, e = null, g = !1, A = 0; A < this.plotInfo.plotTypes.length; A++)if (this.plotInfo.plotTypes[A].type === a.type) { c = !0; b = this.plotInfo.plotTypes[A]; break } c || (b = { type: a.type, totalDataSeries: 0, plotUnits: [] }, this.plotInfo.plotTypes.push(b)); for (A = 0; A <
              b.plotUnits.length; A++)if (b.plotUnits[A].axisYType === a.axisYType && b.plotUnits[A].axisXType === a.axisXType && b.plotUnits[A].axisYIndex === a.axisYIndex && b.plotUnits[A].axisXIndex === a.axisXIndex) { g = !0; e = b.plotUnits[A]; break } g || (e = {
                type: a.type, previousDataSeriesCount: 0, index: b.plotUnits.length, plotType: b, axisXType: a.axisXType, axisYType: a.axisYType, axisYIndex: a.axisYIndex, axisXIndex: a.axisXIndex, axisY: "primary" === a.axisYType ? this.axisY[0 <= a.axisYIndex && a.axisYIndex < this.axisY.length ? a.axisYIndex : 0] : this.axisY2[0 <=
                  a.axisYIndex && a.axisYIndex < this.axisY2.length ? a.axisYIndex : 0], axisX: "primary" === a.axisXType ? this.axisX[0 <= a.axisXIndex && a.axisXIndex < this.axisX.length ? a.axisXIndex : 0] : this.axisX2[0 <= a.axisXIndex && a.axisXIndex < this.axisX2.length ? a.axisXIndex : 0], dataSeriesIndexes: [], yTotals: []
              }, b.plotUnits.push(e)); b.totalDataSeries++; e.dataSeriesIndexes.push(d); a.plotUnit = e
          } for (d = 0; d < this.plotInfo.plotTypes.length; d++)for (b = this.plotInfo.plotTypes[d], A = a = 0; A < b.plotUnits.length; A++)b.plotUnits[A].previousDataSeriesCount =
            a, a += b.plotUnits[A].dataSeriesIndexes.length
        }; n.prototype.assignIdToDataPoints = function () { for (var a = 0; a < this.data.length; a++) { var d = this.data[a]; if (d.dataPoints) for (var b = d.dataPoints.length, c = 0; c < b; c++)d.dataPointIds[c] = ++this._eventManager.lastObjectId } }; n.prototype._processData = function () {
          this.assignIdToDataPoints(); this.categoriseDataSeries(); for (var a = 0; a < this.plotInfo.plotTypes.length; a++)for (var d = this.plotInfo.plotTypes[a], b = 0; b < d.plotUnits.length; b++) {
            var c = d.plotUnits[b]; "line" === c.type ||
              "stepLine" === c.type || "spline" === c.type || "column" === c.type || "area" === c.type || "stepArea" === c.type || "splineArea" === c.type || "bar" === c.type || "bubble" === c.type || "scatter" === c.type ? this._processMultiseriesPlotUnit(c) : "stackedColumn" === c.type || "stackedBar" === c.type || "stackedArea" === c.type ? this._processStackedPlotUnit(c) : "stackedColumn100" === c.type || "stackedBar100" === c.type || "stackedArea100" === c.type ? this._processStacked100PlotUnit(c) : "candlestick" === c.type || "ohlc" === c.type || "rangeColumn" === c.type || "rangeBar" ===
                c.type || "rangeArea" === c.type || "rangeSplineArea" === c.type || "error" === c.type || "boxAndWhisker" === c.type ? this._processMultiYPlotUnit(c) : "waterfall" === c.type && this._processSpecificPlotUnit(c)
          } this.calculateAutoBreaks()
        }; n.prototype._processMultiseriesPlotUnit = function (a) {
          if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) for (var d = a.axisY.dataInfo, b = a.axisX.dataInfo, c, e, g = !1, A = 0; A < a.dataSeriesIndexes.length; A++) {
            var u = this.data[a.dataSeriesIndexes[A]], h = 0, l = !1, r = !1, p; if ("normal" === u.axisPlacement ||
              "xySwapped" === u.axisPlacement) var q = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : this.options.axisX && this.options.axisX.viewportMinimum ? this.options.axisX.viewportMinimum : this.options.axisX && this.options.axisX.minimum ? this.options.axisX.minimum : a.axisX.logarithmic ? 0 : -Infinity, k = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : this.options.axisX && this.options.axisX.viewportMaximum ? this.options.axisX.viewportMaximum : this.options.axisX &&
                this.options.axisX.maximum ? this.options.axisX.maximum : Infinity; if (u.dataPoints[h].x && u.dataPoints[h].x.getTime || "dateTime" === u.xValueType) g = !0; for (h = 0; h < u.dataPoints.length; h++) {
                  "undefined" === typeof u.dataPoints[h].x && (u.dataPoints[h].x = h + (a.axisX.logarithmic ? 1 : 0)); u.dataPoints[h].x.getTime ? (g = !0, c = u.dataPoints[h].x.getTime()) : c = u.dataPoints[h].x; e = u.dataPoints[h].y; c < b.min && (b.min = c); c > b.max && (b.max = c); e < d.min && "number" === typeof e && (d.min = e); e > d.max && "number" === typeof e && (d.max = e); if (0 < h) {
                    if (a.axisX.logarithmic) {
                      var f =
                        c / u.dataPoints[h - 1].x; 1 > f && (f = 1 / f); b.minDiff > f && 1 !== f && (b.minDiff = f)
                    } else f = c - u.dataPoints[h - 1].x, 0 > f && (f *= -1), b.minDiff > f && 0 !== f && (b.minDiff = f); null !== e && null !== u.dataPoints[h - 1].y && (a.axisY.logarithmic ? (f = e / u.dataPoints[h - 1].y, 1 > f && (f = 1 / f), d.minDiff > f && 1 !== f && (d.minDiff = f)) : (f = e - u.dataPoints[h - 1].y, 0 > f && (f *= -1), d.minDiff > f && 0 !== f && (d.minDiff = f)))
                  } if (c < q && !l) null !== e && (p = c); else {
                    if (!l && (l = !0, 0 < h)) { h -= 2; continue } if (c > k && !r) r = !0; else if (c > k && r) continue; u.dataPoints[h].label && (a.axisX.labels[c] = u.dataPoints[h].label);
                    c < b.viewPortMin && (b.viewPortMin = c); c > b.viewPortMax && (b.viewPortMax = c); null === e ? b.viewPortMin === c && p < c && (b.viewPortMin = p) : (e < d.viewPortMin && "number" === typeof e && (d.viewPortMin = e), e > d.viewPortMax && "number" === typeof e && (d.viewPortMax = e))
                  }
                } u.axisX.valueType = u.xValueType = g ? "dateTime" : "number"
          }
        }; n.prototype._processStackedPlotUnit = function (a) {
          if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) {
            for (var d = a.axisY.dataInfo, b = a.axisX.dataInfo, c, e, g = !1, A = [], u = [], f = Infinity, l = -Infinity, r = 0; r < a.dataSeriesIndexes.length; r++) {
              var p =
                this.data[a.dataSeriesIndexes[r]], q = 0, k = !1, C = !1, v; if ("normal" === p.axisPlacement || "xySwapped" === p.axisPlacement) var m = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : this.options.axisX && this.options.axisX.viewportMinimum ? this.options.axisX.viewportMinimum : this.options.axisX && this.options.axisX.minimum ? this.options.axisX.minimum : -Infinity, t = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : this.options.axisX && this.options.axisX.viewportMaximum ?
                  this.options.axisX.viewportMaximum : this.options.axisX && this.options.axisX.maximum ? this.options.axisX.maximum : Infinity; if (p.dataPoints[q].x && p.dataPoints[q].x.getTime || "dateTime" === p.xValueType) g = !0; for (q = 0; q < p.dataPoints.length; q++) {
                    "undefined" === typeof p.dataPoints[q].x && (p.dataPoints[q].x = q + (a.axisX.logarithmic ? 1 : 0)); p.dataPoints[q].x.getTime ? (g = !0, c = p.dataPoints[q].x.getTime()) : c = p.dataPoints[q].x; e = h(p.dataPoints[q].y) ? 0 : p.dataPoints[q].y; c < b.min && (b.min = c); c > b.max && (b.max = c); if (0 < q) {
                      if (a.axisX.logarithmic) {
                        var s =
                          c / p.dataPoints[q - 1].x; 1 > s && (s = 1 / s); b.minDiff > s && 1 !== s && (b.minDiff = s)
                      } else s = c - p.dataPoints[q - 1].x, 0 > s && (s *= -1), b.minDiff > s && 0 !== s && (b.minDiff = s); null !== e && null !== p.dataPoints[q - 1].y && (a.axisY.logarithmic ? 0 < e && (s = e / p.dataPoints[q - 1].y, 1 > s && (s = 1 / s), d.minDiff > s && 1 !== s && (d.minDiff = s)) : (s = e - p.dataPoints[q - 1].y, 0 > s && (s *= -1), d.minDiff > s && 0 !== s && (d.minDiff = s)))
                    } if (c < m && !k) null !== p.dataPoints[q].y && (v = c); else {
                      if (!k && (k = !0, 0 < q)) { q -= 2; continue } if (c > t && !C) C = !0; else if (c > t && C) continue; p.dataPoints[q].label && (a.axisX.labels[c] =
                        p.dataPoints[q].label); c < b.viewPortMin && (b.viewPortMin = c); c > b.viewPortMax && (b.viewPortMax = c); null === p.dataPoints[q].y ? b.viewPortMin === c && v < c && (b.viewPortMin = v) : (a.yTotals[c] = (a.yTotals[c] ? a.yTotals[c] : 0) + e, 0 <= e ? A[c] ? A[c] += e : (A[c] = e, f = Math.min(e, f)) : u[c] ? u[c] += e : (u[c] = e, l = Math.max(e, l)))
                    }
                  } a.axisY.scaleBreaks && (a.axisY.scaleBreaks.autoCalculate && 1 <= a.axisY.scaleBreaks.maxNumberOfAutoBreaks) && (d.dataPointYPositiveSums ? (d.dataPointYPositiveSums.push.apply(d.dataPointYPositiveSums, A), d.dataPointYNegativeSums.push.apply(d.dataPointYPositiveSums,
                    u)) : (d.dataPointYPositiveSums = A, d.dataPointYNegativeSums = u)); p.axisX.valueType = p.xValueType = g ? "dateTime" : "number"
            } for (q in A) A.hasOwnProperty(q) && !isNaN(q) && (a = A[q], a < d.min && (d.min = Math.min(a, f)), a > d.max && (d.max = a), q < b.viewPortMin || q > b.viewPortMax || (a < d.viewPortMin && (d.viewPortMin = Math.min(a, f)), a > d.viewPortMax && (d.viewPortMax = a))); for (q in u) u.hasOwnProperty(q) && !isNaN(q) && (a = u[q], a < d.min && (d.min = a), a > d.max && (d.max = Math.max(a, l)), q < b.viewPortMin || q > b.viewPortMax || (a < d.viewPortMin && (d.viewPortMin =
              a), a > d.viewPortMax && (d.viewPortMax = Math.max(a, l))))
          }
        }; n.prototype._processStacked100PlotUnit = function (a) {
          if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) {
            for (var d = a.axisY.dataInfo, b = a.axisX.dataInfo, c, e, g = !1, A = !1, u = !1, f = [], l = 0; l < a.dataSeriesIndexes.length; l++) {
              var r = this.data[a.dataSeriesIndexes[l]], p = 0, q = !1, k = !1, C; if ("normal" === r.axisPlacement || "xySwapped" === r.axisPlacement) var v = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : this.options.axisX &&
                this.options.axisX.viewportMinimum ? this.options.axisX.viewportMinimum : this.options.axisX && this.options.axisX.minimum ? this.options.axisX.minimum : -Infinity, s = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : this.options.axisX && this.options.axisX.viewportMaximum ? this.options.axisX.viewportMaximum : this.options.axisX && this.options.axisX.maximum ? this.options.axisX.maximum : Infinity; if (r.dataPoints[p].x && r.dataPoints[p].x.getTime || "dateTime" === r.xValueType) g = !0; for (p =
                  0; p < r.dataPoints.length; p++) {
                "undefined" === typeof r.dataPoints[p].x && (r.dataPoints[p].x = p + (a.axisX.logarithmic ? 1 : 0)); r.dataPoints[p].x.getTime ? (g = !0, c = r.dataPoints[p].x.getTime()) : c = r.dataPoints[p].x; e = h(r.dataPoints[p].y) ? null : r.dataPoints[p].y; c < b.min && (b.min = c); c > b.max && (b.max = c); if (0 < p) {
                  if (a.axisX.logarithmic) { var t = c / r.dataPoints[p - 1].x; 1 > t && (t = 1 / t); b.minDiff > t && 1 !== t && (b.minDiff = t) } else t = c - r.dataPoints[p - 1].x, 0 > t && (t *= -1), b.minDiff > t && 0 !== t && (b.minDiff = t); h(e) || null === r.dataPoints[p - 1].y ||
                    (a.axisY.logarithmic ? 0 < e && (t = e / r.dataPoints[p - 1].y, 1 > t && (t = 1 / t), d.minDiff > t && 1 !== t && (d.minDiff = t)) : (t = e - r.dataPoints[p - 1].y, 0 > t && (t *= -1), d.minDiff > t && 0 !== t && (d.minDiff = t)))
                } if (c < v && !q) null !== e && (C = c); else {
                  if (!q && (q = !0, 0 < p)) { p -= 2; continue } if (c > s && !k) k = !0; else if (c > s && k) continue; r.dataPoints[p].label && (a.axisX.labels[c] = r.dataPoints[p].label); c < b.viewPortMin && (b.viewPortMin = c); c > b.viewPortMax && (b.viewPortMax = c); null === e ? b.viewPortMin === c && C < c && (b.viewPortMin = C) : (a.yTotals[c] = (a.yTotals[c] ? a.yTotals[c] :
                    0) + e, 0 <= e ? A = !0 : 0 > e && (u = !0), f[c] = f[c] ? f[c] + Math.abs(e) : Math.abs(e))
                }
              } r.axisX.valueType = r.xValueType = g ? "dateTime" : "number"
            } a.axisY.logarithmic ? (d.max = h(d.viewPortMax) ? 99 * Math.pow(a.axisY.logarithmBase, -0.05) : Math.max(d.viewPortMax, 99 * Math.pow(a.axisY.logarithmBase, -0.05)), d.min = h(d.viewPortMin) ? 1 : Math.min(d.viewPortMin, 1)) : A && !u ? (d.max = h(d.viewPortMax) ? 99 : Math.max(d.viewPortMax, 99), d.min = h(d.viewPortMin) ? 1 : Math.min(d.viewPortMin, 1)) : A && u ? (d.max = h(d.viewPortMax) ? 99 : Math.max(d.viewPortMax, 99), d.min = h(d.viewPortMin) ?
              -99 : Math.min(d.viewPortMin, -99)) : !A && u && (d.max = h(d.viewPortMax) ? -1 : Math.max(d.viewPortMax, -1), d.min = h(d.viewPortMin) ? -99 : Math.min(d.viewPortMin, -99)); d.viewPortMin = d.min; d.viewPortMax = d.max; a.dataPointYSums = f
          }
        }; n.prototype._processMultiYPlotUnit = function (a) {
          if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) for (var d = a.axisY.dataInfo, b = a.axisX.dataInfo, c, e, g, A, u = !1, h = 0; h < a.dataSeriesIndexes.length; h++) {
            var l = this.data[a.dataSeriesIndexes[h]], r = 0, p = !1, q = !1, k, f, v; if ("normal" === l.axisPlacement ||
              "xySwapped" === l.axisPlacement) var s = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : this.options.axisX && this.options.axisX.viewportMinimum ? this.options.axisX.viewportMinimum : this.options.axisX && this.options.axisX.minimum ? this.options.axisX.minimum : a.axisX.logarithmic ? 0 : -Infinity, t = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : this.options.axisX && this.options.axisX.viewportMaximum ? this.options.axisX.viewportMaximum : this.options.axisX &&
                this.options.axisX.maximum ? this.options.axisX.maximum : Infinity; if (l.dataPoints[r].x && l.dataPoints[r].x.getTime || "dateTime" === l.xValueType) u = !0; for (r = 0; r < l.dataPoints.length; r++) {
                  "undefined" === typeof l.dataPoints[r].x && (l.dataPoints[r].x = r + (a.axisX.logarithmic ? 1 : 0)); l.dataPoints[r].x.getTime ? (u = !0, c = l.dataPoints[r].x.getTime()) : c = l.dataPoints[r].x; if ((e = l.dataPoints[r].y) && e.length) {
                    g = Math.min.apply(null, e); A = Math.max.apply(null, e); f = !0; for (var m = 0; m < e.length; m++)null === e.k && (f = !1); f && (p || (v = k), k =
                      c)
                  } c < b.min && (b.min = c); c > b.max && (b.max = c); g < d.min && (d.min = g); A > d.max && (d.max = A); 0 < r && (a.axisX.logarithmic ? (f = c / l.dataPoints[r - 1].x, 1 > f && (f = 1 / f), b.minDiff > f && 1 !== f && (b.minDiff = f)) : (f = c - l.dataPoints[r - 1].x, 0 > f && (f *= -1), b.minDiff > f && 0 !== f && (b.minDiff = f)), e && (null !== e[0] && l.dataPoints[r - 1].y && null !== l.dataPoints[r - 1].y[0]) && (a.axisY.logarithmic ? (f = e[0] / l.dataPoints[r - 1].y[0], 1 > f && (f = 1 / f), d.minDiff > f && 1 !== f && (d.minDiff = f)) : (f = e[0] - l.dataPoints[r - 1].y[0], 0 > f && (f *= -1), d.minDiff > f && 0 !== f && (d.minDiff = f))));
                  if (!(c < s) || p) { if (!p && (p = !0, 0 < r)) { r -= 2; k = v; continue } if (c > t && !q) q = !0; else if (c > t && q) continue; l.dataPoints[r].label && (a.axisX.labels[c] = l.dataPoints[r].label); c < b.viewPortMin && (b.viewPortMin = c); c > b.viewPortMax && (b.viewPortMax = c); if (b.viewPortMin === c && e) for (m = 0; m < e.length; m++)if (null === e[m] && k < c) { b.viewPortMin = k; break } null === e ? b.viewPortMin === c && k < c && (b.viewPortMin = k) : (g < d.viewPortMin && (d.viewPortMin = g), A > d.viewPortMax && (d.viewPortMax = A)) }
                } l.axisX.valueType = l.xValueType = u ? "dateTime" : "number"
          }
        }; n.prototype._processSpecificPlotUnit =
          function (a) {
            if ("waterfall" === a.type && a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) for (var d = a.axisY.dataInfo, b = a.axisX.dataInfo, c, e, g = !1, A = 0; A < a.dataSeriesIndexes.length; A++) {
              var u = this.data[a.dataSeriesIndexes[A]], h = 0, l = !1, r = !1, p = c = 0; if ("normal" === u.axisPlacement || "xySwapped" === u.axisPlacement) var q = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : this.options.axisX && this.options.axisX.viewportMinimum ? this.options.axisX.viewportMinimum : this.options.axisX &&
                this.options.axisX.minimum ? this.options.axisX.minimum : a.axisX.logarithmic ? 0 : -Infinity, k = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : this.options.axisX && this.options.axisX.viewportMaximum ? this.options.axisX.viewportMaximum : this.options.axisX && this.options.axisX.maximum ? this.options.axisX.maximum : Infinity; if (u.dataPoints[h].x && u.dataPoints[h].x.getTime || "dateTime" === u.xValueType) g = !0; for (h = 0; h < u.dataPoints.length; h++)"undefined" !== typeof u.dataPoints[h].isCumulativeSum &&
                  !0 === u.dataPoints[h].isCumulativeSum ? (u.dataPointEOs[h].cumulativeSumYStartValue = 0, u.dataPointEOs[h].cumulativeSum = 0 === h ? 0 : u.dataPointEOs[h - 1].cumulativeSum, u.dataPoints[h].y = 0 === h ? 0 : u.dataPointEOs[h - 1].cumulativeSum) : "undefined" !== typeof u.dataPoints[h].isIntermediateSum && !0 === u.dataPoints[h].isIntermediateSum ? (u.dataPointEOs[h].cumulativeSumYStartValue = p, u.dataPointEOs[h].cumulativeSum = 0 === h ? 0 : u.dataPointEOs[h - 1].cumulativeSum, u.dataPoints[h].y = 0 === h ? 0 : c, p = 0 === h ? 0 : u.dataPointEOs[h - 1].cumulativeSum,
                    c = 0) : (e = "number" !== typeof u.dataPoints[h].y ? 0 : u.dataPoints[h].y, u.dataPointEOs[h].cumulativeSumYStartValue = 0 === h ? 0 : u.dataPointEOs[h - 1].cumulativeSum, u.dataPointEOs[h].cumulativeSum = 0 === h ? e : u.dataPointEOs[h - 1].cumulativeSum + e, c += e); for (h = 0; h < u.dataPoints.length; h++)if ("undefined" === typeof u.dataPoints[h].x && (u.dataPoints[h].x = h + (a.axisX.logarithmic ? 1 : 0)), u.dataPoints[h].x.getTime ? (g = !0, c = u.dataPoints[h].x.getTime()) : c = u.dataPoints[h].x, e = u.dataPoints[h].y, c < b.min && (b.min = c), c > b.max && (b.max = c), u.dataPointEOs[h].cumulativeSum <
                      d.min && (d.min = u.dataPointEOs[h].cumulativeSum), u.dataPointEOs[h].cumulativeSum > d.max && (d.max = u.dataPointEOs[h].cumulativeSum), 0 < h && (a.axisX.logarithmic ? (p = c / u.dataPoints[h - 1].x, 1 > p && (p = 1 / p), b.minDiff > p && 1 !== p && (b.minDiff = p)) : (p = c - u.dataPoints[h - 1].x, 0 > p && (p *= -1), b.minDiff > p && 0 !== p && (b.minDiff = p)), null !== e && null !== u.dataPoints[h - 1].y && (a.axisY.logarithmic ? (e = u.dataPointEOs[h].cumulativeSum / u.dataPointEOs[h - 1].cumulativeSum, 1 > e && (e = 1 / e), d.minDiff > e && 1 !== e && (d.minDiff = e)) : (e = u.dataPointEOs[h].cumulativeSum -
                        u.dataPointEOs[h - 1].cumulativeSum, 0 > e && (e *= -1), d.minDiff > e && 0 !== e && (d.minDiff = e)))), !(c < q) || l) {
                      if (!l && (l = !0, 0 < h)) { h -= 2; continue } if (c > k && !r) r = !0; else if (c > k && r) continue; u.dataPoints[h].label && (a.axisX.labels[c] = u.dataPoints[h].label); c < b.viewPortMin && (b.viewPortMin = c); c > b.viewPortMax && (b.viewPortMax = c); 0 < h && (u.dataPointEOs[h - 1].cumulativeSum < d.viewPortMin && (d.viewPortMin = u.dataPointEOs[h - 1].cumulativeSum), u.dataPointEOs[h - 1].cumulativeSum > d.viewPortMax && (d.viewPortMax = u.dataPointEOs[h - 1].cumulativeSum));
                      u.dataPointEOs[h].cumulativeSum < d.viewPortMin && (d.viewPortMin = u.dataPointEOs[h].cumulativeSum); u.dataPointEOs[h].cumulativeSum > d.viewPortMax && (d.viewPortMax = u.dataPointEOs[h].cumulativeSum)
                    } u.axisX.valueType = u.xValueType = g ? "dateTime" : "number"
            }
          }; n.prototype.calculateAutoBreaks = function () {
            function a(a, c, b, d) {
              if (d) return b = Math.pow(Math.min(b * a / c, c / a), 0.2), 1 >= b && (b = Math.pow(1 > a ? 1 / a : Math.min(c / a, a), 0.25)), { startValue: a * b, endValue: c / b }; b = 0.2 * Math.min(b - c + a, c - a); 0 >= b && (b = 0.25 * Math.min(c - a, Math.abs(a)));
              return { startValue: a + b, endValue: c - b }
            } function d(a) {
              if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) {
                var c = a.axisX.scaleBreaks && a.axisX.scaleBreaks.autoCalculate && 1 <= a.axisX.scaleBreaks.maxNumberOfAutoBreaks, b = a.axisY.scaleBreaks && a.axisY.scaleBreaks.autoCalculate && 1 <= a.axisY.scaleBreaks.maxNumberOfAutoBreaks; if (c || b) for (var d = a.axisY.dataInfo, g = a.axisX.dataInfo, k, l = g.min, A = g.max, u = d.min, r = d.max, g = g._dataRanges, d = d._dataRanges, q, p = 0, f = 0; f < a.dataSeriesIndexes.length; f++) {
                  var v = e.data[a.dataSeriesIndexes[f]];
                  if (!(4 > v.dataPoints.length)) for (p = 0; p < v.dataPoints.length; p++)if (c && (q = (A + 1 - l) * Math.max(parseFloat(a.axisX.scaleBreaks.collapsibleThreshold) || 10, 10) / 100, k = v.dataPoints[p].x.getTime ? v.dataPoints[p].x.getTime() : v.dataPoints[p].x, q = Math.floor((k - l) / q), k < g[q].min && (g[q].min = k), k > g[q].max && (g[q].max = k)), b) {
                    var pb = (r + 1 - u) * Math.max(parseFloat(a.axisY.scaleBreaks.collapsibleThreshold) || 10, 10) / 100; if ((k = "waterfall" === a.type ? v.dataPointEOs[p].cumulativeSum : v.dataPoints[p].y) && k.length) for (var s = 0; s < k.length; s++)q =
                      Math.floor((k[s] - u) / pb), k[s] < d[q].min && (d[q].min = k[s]), k[s] > d[q].max && (d[q].max = k[s]); else h(k) || (q = Math.floor((k - u) / pb), k < d[q].min && (d[q].min = k), k > d[q].max && (d[q].max = k))
                  }
                }
              }
            } function b(a) {
              if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length) && a.axisX.scaleBreaks && a.axisX.scaleBreaks.autoCalculate && 1 <= a.axisX.scaleBreaks.maxNumberOfAutoBreaks) for (var c = a.axisX.dataInfo, b = c.min, d = c.max, g = c._dataRanges, k, l = 0, A = 0; A < a.dataSeriesIndexes.length; A++) {
                var u = e.data[a.dataSeriesIndexes[A]]; if (!(4 > u.dataPoints.length)) for (l =
                  0; l < u.dataPoints.length; l++)k = (d + 1 - b) * Math.max(parseFloat(a.axisX.scaleBreaks.collapsibleThreshold) || 10, 10) / 100, c = u.dataPoints[l].x.getTime ? u.dataPoints[l].x.getTime() : u.dataPoints[l].x, k = Math.floor((c - b) / k), c < g[k].min && (g[k].min = c), c > g[k].max && (g[k].max = c)
              }
            } for (var c, e = this, g = !1, A = 0; A < this._axes.length; A++)if (this._axes[A].scaleBreaks && this._axes[A].scaleBreaks.autoCalculate && 1 <= this._axes[A].scaleBreaks.maxNumberOfAutoBreaks) {
              g = !0; this._axes[A].dataInfo._dataRanges = []; for (var u = 0; u < 100 / Math.max(parseFloat(this._axes[A].scaleBreaks.collapsibleThreshold) ||
                10, 10); u++)this._axes[A].dataInfo._dataRanges.push({ min: Infinity, max: -Infinity })
            } if (g) {
              for (A = 0; A < this.plotInfo.plotTypes.length; A++)for (g = this.plotInfo.plotTypes[A], u = 0; u < g.plotUnits.length; u++)c = g.plotUnits[u], "line" === c.type || "stepLine" === c.type || "spline" === c.type || "column" === c.type || "area" === c.type || "stepArea" === c.type || "splineArea" === c.type || "bar" === c.type || "bubble" === c.type || "scatter" === c.type || "candlestick" === c.type || "ohlc" === c.type || "rangeColumn" === c.type || "rangeBar" === c.type || "rangeArea" ===
                c.type || "rangeSplineArea" === c.type || "waterfall" === c.type || "error" === c.type || "boxAndWhisker" === c.type ? d(c) : 0 <= c.type.indexOf("stacked") && b(c); for (A = 0; A < this._axes.length; A++)if (this._axes[A].dataInfo._dataRanges) {
                  var f = this._axes[A].dataInfo.min; c = (this._axes[A].dataInfo.max + 1 - f) * Math.max(parseFloat(this._axes[A].scaleBreaks.collapsibleThreshold) || 10, 10) / 100; var l = this._axes[A].dataInfo._dataRanges, r, p, g = []; if (this._axes[A].dataInfo.dataPointYPositiveSums) {
                    var q = this._axes[A].dataInfo.dataPointYPositiveSums;
                    r = l; for (u in q) if (q.hasOwnProperty(u) && !isNaN(u) && (p = q[u], !h(p))) { var k = Math.floor((p - f) / c); p < r[k].min && (r[k].min = p); p > r[k].max && (r[k].max = p) } delete this._axes[A].dataInfo.dataPointYPositiveSums
                  } if (this._axes[A].dataInfo.dataPointYNegativeSums) { q = this._axes[A].dataInfo.dataPointYNegativeSums; r = l; for (u in q) q.hasOwnProperty(u) && !isNaN(u) && (p = -1 * q[u], h(p) || (k = Math.floor((p - f) / c), p < r[k].min && (r[k].min = p), p > r[k].max && (r[k].max = p))); delete this._axes[A].dataInfo.dataPointYNegativeSums } for (u = 0; u < l.length -
                    1; u++)if (r = l[u].max, isFinite(r)) for (; u < l.length - 1;)if (f = l[u + 1].min, isFinite(f)) { p = f - r; p > c && g.push({ diff: p, start: r, end: f }); break } else u++; if (this._axes[A].scaleBreaks.customBreaks) for (u = 0; u < this._axes[A].scaleBreaks.customBreaks.length; u++)for (c = 0; c < g.length; c++)if (this._axes[A].scaleBreaks.customBreaks[u].startValue <= g[c].start && g[c].start <= this._axes[A].scaleBreaks.customBreaks[u].endValue || this._axes[A].scaleBreaks.customBreaks[u].startValue <= g[c].start && g[c].start <= this._axes[A].scaleBreaks.customBreaks[u].endValue ||
                      g[c].start <= this._axes[A].scaleBreaks.customBreaks[u].startValue && this._axes[A].scaleBreaks.customBreaks[u].startValue <= g[c].end || g[c].start <= this._axes[A].scaleBreaks.customBreaks[u].endValue && this._axes[A].scaleBreaks.customBreaks[u].endValue <= g[c].end) g.splice(c, 1), c--; g.sort(function (a, c) { return c.diff - a.diff }); for (u = 0; u < Math.min(g.length, this._axes[A].scaleBreaks.maxNumberOfAutoBreaks); u++)c = a(g[u].start, g[u].end, this._axes[A].logarithmic ? this._axes[A].dataInfo.max / this._axes[A].dataInfo.min :
                        this._axes[A].dataInfo.max - this._axes[A].dataInfo.min, this._axes[A].logarithmic), this._axes[A].scaleBreaks.autoBreaks.push(new W(this, "autoBreaks", c, u, ++this._eventManager.lastObjectId, this._axes[A].scaleBreaks)), this._axes[A].scaleBreaks._appliedBreaks.push(this._axes[A].scaleBreaks.autoBreaks[this._axes[A].scaleBreaks.autoBreaks.length - 1]); this._axes[A].scaleBreaks._appliedBreaks.sort(function (a, c) { return a.startValue - c.startValue })
                }
            }
          }; n.prototype.renderCrosshairs = function (a) {
            for (var d = 0; d < this.axisX.length; d++)this.axisX[d] !=
              a && (this.axisX[d].crosshair && this.axisX[d].crosshair.enabled && !this.axisX[d].crosshair._hidden) && this.axisX[d].showCrosshair(this.axisX[d].crosshair._updatedValue); for (d = 0; d < this.axisX2.length; d++)this.axisX2[d] != a && (this.axisX2[d].crosshair && this.axisX2[d].crosshair.enabled && !this.axisX2[d].crosshair._hidden) && this.axisX2[d].showCrosshair(this.axisX2[d].crosshair._updatedValue); for (d = 0; d < this.axisY.length; d++)this.axisY[d] != a && (this.axisY[d].crosshair && this.axisY[d].crosshair.enabled && !this.axisY[d].crosshair._hidden) &&
                this.axisY[d].showCrosshair(this.axisY[d].crosshair._updatedValue); for (d = 0; d < this.axisY2.length; d++)this.axisY2[d] != a && (this.axisY2[d].crosshair && this.axisY2[d].crosshair.enabled && !this.axisY2[d].crosshair._hidden) && this.axisY2[d].showCrosshair(this.axisY2[d].crosshair._updatedValue)
          }; n.prototype.getDataPointAtXY = function (a, d, b) {
            b = b || !1; for (var c = [], e = this._dataInRenderedOrder.length - 1; 0 <= e; e--) { var g = null; (g = this._dataInRenderedOrder[e].getDataPointAtXY(a, d, b)) && c.push(g) } a = null; d = !1; for (b = 0; b < c.length; b++)if ("line" ===
              c[b].dataSeries.type || "stepLine" === c[b].dataSeries.type || "area" === c[b].dataSeries.type || "stepArea" === c[b].dataSeries.type) if (e = oa("markerSize", c[b].dataPoint, c[b].dataSeries) || 8, c[b].distance <= e / 2) { d = !0; break } for (b = 0; b < c.length; b++)d && "line" !== c[b].dataSeries.type && "stepLine" !== c[b].dataSeries.type && "area" !== c[b].dataSeries.type && "stepArea" !== c[b].dataSeries.type || (a ? c[b].distance <= a.distance && (a = c[b]) : a = c[b]); return a
          }; n.prototype.getObjectAtXY = function (a, d, b) {
            var c = null; if (b = this.getDataPointAtXY(a,
              d, b || !1)) c = b.dataSeries.dataPointIds[b.dataPointIndex]; else if (s) c = jb(a, d, this._eventManager.ghostCtx); else for (b = 0; b < this.legend.items.length; b++) { var e = this.legend.items[b]; a >= e.x1 && (a <= e.x2 && d >= e.y1 && d <= e.y2) && (c = e.id) } return c
          }; n.prototype.getAutoFontSize = ob; n.prototype.resetOverlayedCanvas = function () { this.overlaidCanvasCtx.clearRect(0, 0, this.width, this.height) }; n.prototype.clearCanvas = nb; n.prototype.attachEvent = function (a) { this._events.push(a) }; n.prototype._touchEventHandler = function (a) {
            if (a.changedTouches &&
              this.interactivityEnabled) {
              var d = [], b = a.changedTouches, c = b ? b[0] : a, e = null; switch (a.type) {
                case "touchstart": case "MSPointerDown": d = ["mousemove", "mousedown"]; this._lastTouchData = Aa(c); this._lastTouchData.time = new Date; break; case "touchmove": case "MSPointerMove": d = ["mousemove"]; break; case "touchend": case "MSPointerUp": var g = this._lastTouchData && this._lastTouchData.time ? new Date - this._lastTouchData.time : 0, d = "touchstart" === this._lastTouchEventType || "MSPointerDown" === this._lastTouchEventType || 300 > g ? ["mouseup",
                  "click"] : ["mouseup"]; break; default: return
              }if (!(b && 1 < b.length)) {
                e = Aa(c); e.time = new Date; try { var A = e.y - this._lastTouchData.y, g = e.time - this._lastTouchData.time; if (1 < Math.abs(A) && this._lastTouchData.scroll || 5 < Math.abs(A) && 250 > g) this._lastTouchData.scroll = !0 } catch (u) { } this._lastTouchEventType = a.type; if (this._lastTouchData.scroll && this.zoomEnabled) this.isDrag && this.resetOverlayedCanvas(), this.isDrag = !1; else for (b = 0; b < d.length; b++)if (e = d[b], A = document.createEvent("MouseEvent"), A.initMouseEvent(e, !0, !0, window,
                  1, c.screenX, c.screenY, c.clientX, c.clientY, !1, !1, !1, !1, 0, null), c.target.dispatchEvent(A), !h(this._lastTouchData.scroll) && !this._lastTouchData.scroll || !this._lastTouchData.scroll && 250 < g || "click" === e) a.preventManipulation && a.preventManipulation(), a.preventDefault && a.preventDefault()
              }
            }
          }; n.prototype._dispatchRangeEvent = function (a, d) {
            var b = { chart: this }; b.type = a; b.trigger = d; var c = []; this.axisX && 0 < this.axisX.length && c.push("axisX"); this.axisX2 && 0 < this.axisX2.length && c.push("axisX2"); this.axisY && 0 < this.axisY.length &&
              c.push("axisY"); this.axisY2 && 0 < this.axisY2.length && c.push("axisY2"); for (var e = 0; e < c.length; e++)if (h(b[c[e]]) && (b[c[e]] = []), "axisY" === c[e]) for (var g = 0; g < this.axisY.length; g++)b[c[e]].push({ viewportMinimum: this[c[e]][g].sessionVariables.newViewportMinimum, viewportMaximum: this[c[e]][g].sessionVariables.newViewportMaximum }); else if ("axisY2" === c[e]) for (g = 0; g < this.axisY2.length; g++)b[c[e]].push({ viewportMinimum: this[c[e]][g].sessionVariables.newViewportMinimum, viewportMaximum: this[c[e]][g].sessionVariables.newViewportMaximum });
              else if ("axisX" === c[e]) for (g = 0; g < this.axisX.length; g++)b[c[e]].push({ viewportMinimum: this[c[e]][g].sessionVariables.newViewportMinimum, viewportMaximum: this[c[e]][g].sessionVariables.newViewportMaximum }); else if ("axisX2" === c[e]) for (g = 0; g < this.axisX2.length; g++)b[c[e]].push({ viewportMinimum: this[c[e]][g].sessionVariables.newViewportMinimum, viewportMaximum: this[c[e]][g].sessionVariables.newViewportMaximum }); this.dispatchEvent(a, b, this)
          }; n.prototype._mouseEventHandler = function (a) {
            "undefined" === typeof a.target &&
              a.srcElement && (a.target = a.srcElement); var d = Aa(a), b = a.type, c, e; a.which ? e = 3 == a.which : a.button && (e = 2 == a.button); n.capturedEventParam && (c = n.capturedEventParam, "mouseup" === b && (n.capturedEventParam = null, c.chart.overlaidCanvas.releaseCapture ? c.chart.overlaidCanvas.releaseCapture() : document.documentElement.removeEventListener("mouseup", c.chart._mouseEventHandler, !1)), c.hasOwnProperty(b) && ("mouseup" !== b || c.chart.overlaidCanvas.releaseCapture ? a.target !== c.chart.overlaidCanvas && s || c[b].call(c.context, d.x, d.y) :
                a.target !== c.chart.overlaidCanvas && (c.chart.isDrag = !1))); if (this.interactivityEnabled) if (this._ignoreNextEvent) this._ignoreNextEvent = !1; else if (a.preventManipulation && a.preventManipulation(), a.preventDefault && a.preventDefault(), Ma && window.console && (window.console.log(b + " --\x3e x: " + d.x + "; y:" + d.y), e && window.console.log(a.which), "mouseup" === b && window.console.log("mouseup")), !e) {
                  if (!n.capturedEventParam && this._events) {
                    for (var g = 0; g < this._events.length; g++)if (this._events[g].hasOwnProperty(b)) if (c =
                      this._events[g], e = c.bounds, d.x >= e.x1 && d.x <= e.x2 && d.y >= e.y1 && d.y <= e.y2) { c[b].call(c.context, d.x, d.y); "mousedown" === b && !0 === c.capture ? (n.capturedEventParam = c, this.overlaidCanvas.setCapture ? this.overlaidCanvas.setCapture() : document.documentElement.addEventListener("mouseup", this._mouseEventHandler, !1)) : "mouseup" === b && (c.chart.overlaidCanvas.releaseCapture ? c.chart.overlaidCanvas.releaseCapture() : document.documentElement.removeEventListener("mouseup", this._mouseEventHandler, !1)); break } else c = null; a.target.style.cursor =
                        c && c.cursor ? c.cursor : this._defaultCursor
                  } b = this.plotArea; if (d.x < b.x1 || d.x > b.x2 || d.y < b.y1 || d.y > b.y2) if (this.toolTip && this.toolTip.enabled) {
                    this.toolTip.hide(); this.toolTip.dispatchEvent("hidden", { chart: this, toolTip: this.toolTip }, this.toolTip); for (g = 0; g < this.axisX.length; g++)this.axisX[g].crosshair && this.axisX[g].crosshair.enabled && this.axisX[g].crosshair.dispatchEvent("hidden", { chart: this, axis: this.axisX[g].options }, this.axisX[g].crosshair); for (g = 0; g < this.axisX2.length; g++)this.axisX2[g].crosshair &&
                      this.axisX2[g].crosshair.enabled && this.axisX2[g].crosshair.dispatchEvent("hidden", { chart: this, axis: this.axisX2[g].options }, this.axisX2[g].crosshair); for (g = 0; g < this.axisY.length; g++)this.axisY[g].crosshair && this.axisY[g].crosshair.enabled && this.axisY[g].crosshair.dispatchEvent("hidden", { chart: this, axis: this.axisY[g].options }, this.axisY[g].crosshair); for (g = 0; g < this.axisY2.length; g++)this.axisY2[g].crosshair && this.axisY2[g].crosshair.enabled && this.axisY2[g].crosshair.dispatchEvent("hidden", {
                        chart: this,
                        axis: this.axisY2[g].options
                      }, this.axisY2[g].crosshair)
                  } else this.resetOverlayedCanvas(); this.isDrag && this.zoomEnabled || !this._eventManager || this._eventManager.mouseEventHandler(a)
                }
          }; n.prototype._plotAreaMouseDown = function (a, d) { this.isDrag = !0; this.dragStartPoint = { x: a, y: d } }; n.prototype._plotAreaMouseUp = function (a, d) {
            if (("normal" === this.plotInfo.axisPlacement || "xySwapped" === this.plotInfo.axisPlacement) && this.isDrag) {
              var b = d - this.dragStartPoint.y, c = a - this.dragStartPoint.x, e = 0 <= this.zoomType.indexOf("x"),
                g = 0 <= this.zoomType.indexOf("y"), A = !1; this.resetOverlayedCanvas(); if ("xySwapped" === this.plotInfo.axisPlacement) var u = g, g = e, e = u; if (this.panEnabled || this.zoomEnabled) {
                  if (this.panEnabled) for (e = g = 0; e < this._axes.length; e++)b = this._axes[e], b.logarithmic ? b.viewportMinimum < b.minimum ? (g = b.minimum / b.viewportMinimum, b.sessionVariables.newViewportMinimum = b.viewportMinimum * g, b.sessionVariables.newViewportMaximum = b.viewportMaximum * g, A = !0) : b.viewportMaximum > b.maximum && (g = b.viewportMaximum / b.maximum, b.sessionVariables.newViewportMinimum =
                    b.viewportMinimum / g, b.sessionVariables.newViewportMaximum = b.viewportMaximum / g, A = !0) : b.viewportMinimum < b.minimum ? (g = b.minimum - b.viewportMinimum, b.sessionVariables.newViewportMinimum = b.viewportMinimum + g, b.sessionVariables.newViewportMaximum = b.viewportMaximum + g, A = !0) : b.viewportMaximum > b.maximum && (g = b.viewportMaximum - b.maximum, b.sessionVariables.newViewportMinimum = b.viewportMinimum - g, b.sessionVariables.newViewportMaximum = b.viewportMaximum - g, A = !0); else if ((!e || 2 < Math.abs(c)) && (!g || 2 < Math.abs(b)) && this.zoomEnabled) {
                      if (!this.dragStartPoint) return;
                      b = e ? this.dragStartPoint.x : this.plotArea.x1; c = g ? this.dragStartPoint.y : this.plotArea.y1; e = e ? a : this.plotArea.x2; g = g ? d : this.plotArea.y2; 2 < Math.abs(b - e) && 2 < Math.abs(c - g) && this._zoomPanToSelectedRegion(b, c, e, g) && (A = !0)
                    } A && (this._ignoreNextEvent = !0, this._dispatchRangeEvent("rangeChanging", "zoom"), this.stockChart && (this.stockChart.navigator && this.stockChart.navigator.enabled) && (this.stockChart._rangeEventParameter.type = "rangeChanging", this.stockChart.dispatchEvent("rangeChanging", this.stockChart._rangeEventParameter,
                      this.stockChart)), this.render(), this._dispatchRangeEvent("rangeChanged", "zoom"), this.stockChart && (this.stockChart.navigator && this.stockChart.navigator.enabled) && (this.stockChart._rangeEventParameter.type = "rangeChanged", this.stockChart.dispatchEvent("rangeChanged", this.stockChart._rangeEventParameter, this.stockChart)), A && (this.zoomEnabled && "none" === this._zoomButton.style.display) && (Sa(this._zoomButton, this._resetButton), Ba(this, this._zoomButton, "pan"), Ba(this, this._resetButton, "reset")))
                }
            } this.isDrag =
              !1; if ("none" !== this.plotInfo.axisPlacement) {
                this.resetOverlayedCanvas(); if (this.axisX && 0 < this.axisX.length) for (A = 0; A < this.axisX.length; A++)this.axisX[A].crosshair && this.axisX[A].crosshair.enabled && this.axisX[A].renderCrosshair(a, d); if (this.axisX2 && 0 < this.axisX2.length) for (A = 0; A < this.axisX2.length; A++)this.axisX2[A].crosshair && this.axisX2[A].crosshair.enabled && this.axisX2[A].renderCrosshair(a, d); if (this.axisY && 0 < this.axisY.length) for (A = 0; A < this.axisY.length; A++)this.axisY[A].crosshair && this.axisY[A].crosshair.enabled &&
                  this.axisY[A].renderCrosshair(a, d); if (this.axisY2 && 0 < this.axisY2.length) for (A = 0; A < this.axisY2.length; A++)this.axisY2[A].crosshair && this.axisY2[A].crosshair.enabled && this.axisY2[A].renderCrosshair(a, d)
              }
          }; n.prototype._plotAreaMouseMove = function (a, d) {
            if (this.isDrag && "none" !== this.plotInfo.axisPlacement) {
              var b = 0, c = 0, e = b = null, e = 0 <= this.zoomType.indexOf("x"), g = 0 <= this.zoomType.indexOf("y"), A = this; "xySwapped" === this.plotInfo.axisPlacement && (b = g, g = e, e = b); b = this.dragStartPoint.x - a; c = this.dragStartPoint.y -
                d; 2 < Math.abs(b) && 8 > Math.abs(b) && (this.panEnabled || this.zoomEnabled) ? (this.toolTip.hide(), this.toolTip.dispatchEvent("hidden", { chart: this, toolTip: this.toolTip }, this.toolTip)) : this.panEnabled || this.zoomEnabled || this.toolTip.mouseMoveHandler(a, d); if ((!e || 2 < Math.abs(b) || !g || 2 < Math.abs(c)) && (this.panEnabled || this.zoomEnabled)) if (this.panEnabled) e = { x1: e ? this.plotArea.x1 + b : this.plotArea.x1, y1: g ? this.plotArea.y1 + c : this.plotArea.y1, x2: e ? this.plotArea.x2 + b : this.plotArea.x2, y2: g ? this.plotArea.y2 + c : this.plotArea.y2 },
                  clearTimeout(A._panTimerId), A._panTimerId = setTimeout(function (c, b, e, g) {
                    return function () {
                      A._zoomPanToSelectedRegion(c, b, e, g, !0) && (A._dispatchRangeEvent("rangeChanging", "pan"), A.stockChart && (A.stockChart.navigator && A.stockChart.navigator.enabled) && (A.stockChart._rangeEventParameter.type = "rangeChanging", A.stockChart.dispatchEvent("rangeChanging", A.stockChart._rangeEventParameter, A.stockChart)), A.render(), A._dispatchRangeEvent("rangeChanged", "pan"), A.stockChart && (A.stockChart.navigator && A.stockChart.navigator.enabled) &&
                        (A.stockChart._rangeEventParameter.type = "rangeChanged", A.stockChart.dispatchEvent("rangeChanged", A.stockChart._rangeEventParameter, A.stockChart)), A.dragStartPoint.x = a, A.dragStartPoint.y = d)
                    }
                  }(e.x1, e.y1, e.x2, e.y2), 0); else if (this.zoomEnabled) {
                    this.resetOverlayedCanvas(); b = this.overlaidCanvasCtx.globalAlpha; this.overlaidCanvasCtx.fillStyle = "#A89896"; var c = e ? this.dragStartPoint.x : this.plotArea.x1, u = g ? this.dragStartPoint.y : this.plotArea.y1, h = e ? a - this.dragStartPoint.x : this.plotArea.x2 - this.plotArea.x1,
                      l = g ? d - this.dragStartPoint.y : this.plotArea.y2 - this.plotArea.y1; this.validateRegion(c, u, e ? a : this.plotArea.x2 - this.plotArea.x1, g ? d : this.plotArea.y2 - this.plotArea.y1, "xy" !== this.zoomType).isValid && (this.resetOverlayedCanvas(), this.overlaidCanvasCtx.fillStyle = "#99B2B5"); this.overlaidCanvasCtx.globalAlpha = 0.7; this.overlaidCanvasCtx.fillRect(c, u, h, l); this.overlaidCanvasCtx.globalAlpha = b
                  }
            } else if (this.toolTip.mouseMoveHandler(a, d), "none" !== this.plotInfo.axisPlacement) {
              if (this.axisX && 0 < this.axisX.length) for (e =
                0; e < this.axisX.length; e++)this.axisX[e].crosshair && this.axisX[e].crosshair.enabled && this.axisX[e].renderCrosshair(a, d); if (this.axisX2 && 0 < this.axisX2.length) for (e = 0; e < this.axisX2.length; e++)this.axisX2[e].crosshair && this.axisX2[e].crosshair.enabled && this.axisX2[e].renderCrosshair(a, d); if (this.axisY && 0 < this.axisY.length) for (e = 0; e < this.axisY.length; e++)this.axisY[e].crosshair && this.axisY[e].crosshair.enabled && this.axisY[e].renderCrosshair(a, d); if (this.axisY2 && 0 < this.axisY2.length) for (e = 0; e < this.axisY2.length; e++)this.axisY2[e].crosshair &&
                  this.axisY2[e].crosshair.enabled && this.axisY2[e].renderCrosshair(a, d)
            }
          }; n.prototype._zoomPanToSelectedRegion = function (a, d, b, c, e) {
            a = this.validateRegion(a, d, b, c, e); d = a.axesWithValidRange; b = a.axesRanges; if (a.isValid) for (c = 0; c < d.length; c++)e = b[c], d[c].setViewPortRange(e.val1, e.val2), this.syncCharts && "y" != this.zoomType && this.syncCharts(e.val1, e.val2), this.stockChart && (this.stockChart._rangeEventParameter = {
              stockChart: this.stockChart, source: "chart", index: this.stockChart.charts.indexOf(this), minimum: e.val1,
              maximum: e.val2
            }); return a.isValid
          }; n.prototype.validateRegion = function (a, d, b, c, e) {
            e = e || !1; for (var g = 0 <= this.zoomType.indexOf("x"), A = 0 <= this.zoomType.indexOf("y"), u = !1, h = [], l = [], r = [], p = 0; p < this._axes.length; p++)("axisX" === this._axes[p].type && g || "axisY" === this._axes[p].type && A) && l.push(this._axes[p]); for (A = 0; A < l.length; A++) {
              var p = l[A], g = !1, q = p.convertPixelToValue({ x: a, y: d }), k = p.convertPixelToValue({ x: b, y: c }); if (q > k) var f = k, k = q, q = f; if (p.scaleBreaks) for (f = 0; !g && f < p.scaleBreaks._appliedBreaks.length; f++)g =
                p.scaleBreaks._appliedBreaks[f].startValue <= q && p.scaleBreaks._appliedBreaks[f].endValue >= k; if (isFinite(p.dataInfo.minDiff)) if (f = p.getApparentDifference(q, k, null, !0), !(g || !(this.panEnabled && p.scaleBreaks && p.scaleBreaks._appliedBreaks.length) && (p.logarithmic && f < Math.pow(p.dataInfo.minDiff, 3) || !p.logarithmic && f < 3 * Math.abs(p.dataInfo.minDiff)) || q < p.minimum || k > p.maximum)) h.push(p), r.push({ val1: q, val2: k }), u = !0; else if (!e) { u = !1; break }
            } return { isValid: u, axesWithValidRange: h, axesRanges: r }
          }; n.prototype.preparePlotArea =
            function () {
              var a = this.plotArea; !s && (0 < a.x1 || 0 < a.y1) && a.ctx.translate(a.x1, a.y1); if ((this.axisX[0] || this.axisX2[0]) && (this.axisY[0] || this.axisY2[0])) {
                var d = this.axisX[0] ? this.axisX[0].lineCoordinates : this.axisX2[0].lineCoordinates; if (this.axisY && 0 < this.axisY.length && this.axisY[0]) {
                  var b = this.axisY[0]; a.x1 = d.x1 < d.x2 ? d.x1 : b.lineCoordinates.x1; a.y1 = d.y1 < b.lineCoordinates.y1 ? d.y1 : b.lineCoordinates.y1; a.x2 = d.x2 > b.lineCoordinates.x2 ? d.x2 : b.lineCoordinates.x2; a.y2 = d.y2 > d.y1 ? d.y2 : b.lineCoordinates.y2; a.width =
                    a.x2 - a.x1; a.height = a.y2 - a.y1
                } this.axisY2 && 0 < this.axisY2.length && this.axisY2[0] && (b = this.axisY2[0], a.x1 = d.x1 < d.x2 ? d.x1 : b.lineCoordinates.x1, a.y1 = d.y1 < b.lineCoordinates.y1 ? d.y1 : b.lineCoordinates.y1, a.x2 = d.x2 > b.lineCoordinates.x2 ? d.x2 : b.lineCoordinates.x2, a.y2 = d.y2 > d.y1 ? d.y2 : b.lineCoordinates.y2, a.width = a.x2 - a.x1, a.height = a.y2 - a.y1)
              } else d = this.layoutManager.getFreeSpace(), a.x1 = d.x1, a.x2 = d.x2, a.y1 = d.y1, a.y2 = d.y2, a.width = d.width, a.height = d.height; s || (a.canvas.width = a.width, a.canvas.height = a.height, a.canvas.style.left =
                a.x1 + "px", a.canvas.style.top = a.y1 + "px", (0 < a.x1 || 0 < a.y1) && a.ctx.translate(-a.x1, -a.y1)); a.layoutManager = new La(a.x1, a.y1, a.x2, a.y2, 2)
            }; n.prototype.renderIndexLabels = function (a) {
              var d = a || this.plotArea.ctx, b = this.plotArea, c = 0, e = 0, g = 0, A = 0, u = c = A = e = g = 0, f = 0; for (a = 0; a < this._indexLabels.length; a++) {
                var l = this._indexLabels[a], r = l.chartType.toLowerCase(), p, q, u = oa("indexLabelFontColor", l.dataPoint, l.dataSeries), f = oa("indexLabelFontSize", l.dataPoint, l.dataSeries); p = oa("indexLabelFontFamily", l.dataPoint, l.dataSeries);
                q = oa("indexLabelFontStyle", l.dataPoint, l.dataSeries); var A = oa("indexLabelFontWeight", l.dataPoint, l.dataSeries), k = oa("indexLabelBackgroundColor", l.dataPoint, l.dataSeries), e = oa("indexLabelMaxWidth", l.dataPoint, l.dataSeries), g = oa("indexLabelWrap", l.dataPoint, l.dataSeries), C = oa("indexLabelLineDashType", l.dataPoint, l.dataSeries), m = oa("indexLabelLineColor", l.dataPoint, l.dataSeries), F = h(l.dataPoint.indexLabelLineThickness) ? h(l.dataSeries.options.indexLabelLineThickness) ? 0 : l.dataSeries.options.indexLabelLineThickness :
                  l.dataPoint.indexLabelLineThickness, c = 0 < F ? Math.min(10, ("normal" === this.plotInfo.axisPlacement ? this.plotArea.height : this.plotArea.width) << 0) : 0, t = { percent: null, total: null }, L = null; if (0 <= l.dataSeries.type.indexOf("stacked") || "pie" === l.dataSeries.type || "doughnut" === l.dataSeries.type) t = this.getPercentAndTotal(l.dataSeries, l.dataPoint); if (l.dataSeries.indexLabelFormatter || l.dataPoint.indexLabelFormatter) L = { chart: this, dataSeries: l.dataSeries, dataPoint: l.dataPoint, index: l.indexKeyword, total: t.total, percent: t.percent };
                var x = l.dataPoint.indexLabelFormatter ? l.dataPoint.indexLabelFormatter(L) : l.dataPoint.indexLabel ? this.replaceKeywordsWithValue(l.dataPoint.indexLabel, l.dataPoint, l.dataSeries, null, l.indexKeyword) : l.dataSeries.indexLabelFormatter ? l.dataSeries.indexLabelFormatter(L) : l.dataSeries.indexLabel ? this.replaceKeywordsWithValue(l.dataSeries.indexLabel, l.dataPoint, l.dataSeries, null, l.indexKeyword) : null; if (null !== x && "" !== x) {
                  var t = oa("indexLabelPlacement", l.dataPoint, l.dataSeries), L = oa("indexLabelOrientation", l.dataPoint,
                    l.dataSeries), z = l.direction, n = l.dataSeries.axisX, E = l.dataSeries.axisY, w = !1, k = new ja(d, { x: 0, y: 0, maxWidth: e ? e : 0.5 * this.width, maxHeight: g ? 5 * f : 1.5 * f, angle: "horizontal" === L ? 0 : -90, text: x, padding: 0, backgroundColor: k, horizontalAlign: "left", fontSize: f, fontFamily: p, fontWeight: A, fontColor: u, fontStyle: q, textBaseline: "top" }); k.measureText(); l.dataSeries.indexLabelMaxWidth = k.maxWidth; if ("stackedarea100" === r) { if (l.point.x < b.x1 || l.point.x > b.x2 || l.point.y < b.y1 - 1 || l.point.y > b.y2 + 1) continue } else if ("rangearea" === r ||
                      "rangesplinearea" === r) { if (l.dataPoint.x < n.viewportMinimum || l.dataPoint.x > n.viewportMaximum || Math.max.apply(null, l.dataPoint.y) < E.viewportMinimum || Math.min.apply(null, l.dataPoint.y) > E.viewportMaximum) continue } else if (0 <= r.indexOf("line") || 0 <= r.indexOf("area") || 0 <= r.indexOf("bubble") || 0 <= r.indexOf("scatter")) { if (l.dataPoint.x < n.viewportMinimum || l.dataPoint.x > n.viewportMaximum || l.dataPoint.y < E.viewportMinimum || l.dataPoint.y > E.viewportMaximum) continue } else if (0 <= r.indexOf("column") || "waterfall" === r ||
                        "error" === r && !l.axisSwapped) { if (l.dataPoint.x < n.viewportMinimum || l.dataPoint.x > n.viewportMaximum || l.bounds.y1 > b.y2 || l.bounds.y2 < b.y1) continue } else if (0 <= r.indexOf("bar") || "error" === r) { if (l.dataPoint.x < n.viewportMinimum || l.dataPoint.x > n.viewportMaximum || l.bounds.x1 > b.x2 || l.bounds.x2 < b.x1) continue } else if ("candlestick" === r || "ohlc" === r) { if (l.dataPoint.x < n.viewportMinimum || l.dataPoint.x > n.viewportMaximum || Math.max.apply(null, l.dataPoint.y) < E.viewportMinimum || Math.min.apply(null, l.dataPoint.y) > E.viewportMaximum) continue } else if (l.dataPoint.x <
                          n.viewportMinimum || l.dataPoint.x > n.viewportMaximum) continue; e = A = 2; "horizontal" === L ? (u = k.width, f = k.height) : (f = k.width, u = k.height); if ("normal" === this.plotInfo.axisPlacement) {
                            if (0 <= r.indexOf("line") || 0 <= r.indexOf("area")) t = "auto", A = 4; else if (0 <= r.indexOf("stacked")) "auto" === t && (t = "inside"); else if ("bubble" === r || "scatter" === r) t = "inside"; p = l.point.x - u / 2; "inside" !== t ? (e = b.y1, g = b.y2, 0 < z ? (q = l.point.y - f - A - c, q < e && (q = "auto" === t ? Math.max(l.point.y, e) + A + c : e + A + c, w = q + f > l.point.y)) : (q = l.point.y + A + c, q > g - f - A - c && (q =
                              "auto" === t ? Math.min(l.point.y, g) - f - A - c : g - f - A - c, w = q < l.point.y))) : (e = Math.max(l.bounds.y1, b.y1), g = Math.min(l.bounds.y2, b.y2), c = 0 <= r.indexOf("range") || "error" === r ? 0 < z ? Math.max(l.bounds.y1, b.y1) + f / 2 + A : Math.min(l.bounds.y2, b.y2) - f / 2 - A : (Math.max(l.bounds.y1, b.y1) + Math.min(l.bounds.y2, b.y2)) / 2, 0 < z ? (q = Math.max(l.point.y, c) - f / 2, q < e && ("bubble" === r || "scatter" === r) && (q = Math.max(l.point.y - f - A, b.y1 + A))) : (q = Math.min(l.point.y, c) - f / 2, q > g - f - A && ("bubble" === r || "scatter" === r) && (q = Math.min(l.point.y + A, b.y2 - f - A))), q = Math.min(q,
                                g - f))
                          } else 0 <= r.indexOf("line") || 0 <= r.indexOf("area") || 0 <= r.indexOf("scatter") ? (t = "auto", e = 4) : 0 <= r.indexOf("stacked") ? "auto" === t && (t = "inside") : "bubble" === r && (t = "inside"), q = l.point.y - f / 2, "inside" !== t ? (A = b.x1, g = b.x2, 0 > z ? (p = l.point.x - u - e - c, p < A && (p = "auto" === t ? Math.max(l.point.x, A) + e + c : A + e + c, w = p + u > l.point.x)) : (p = l.point.x + e + c, p > g - u - e - c && (p = "auto" === t ? Math.min(l.point.x, g) - u - e - c : g - u - e - c, w = p < l.point.x))) : (A = Math.max(l.bounds.x1, b.x1), Math.min(l.bounds.x2, b.x2), c = 0 <= r.indexOf("range") || "error" === r ? 0 > z ? Math.max(l.bounds.x1,
                            b.x1) + u / 2 + e : Math.min(l.bounds.x2, b.x2) - u / 2 - e : (Math.max(l.bounds.x1, b.x1) + Math.min(l.bounds.x2, b.x2)) / 2, p = 0 > z ? Math.max(l.point.x, c) - u / 2 : Math.min(l.point.x, c) - u / 2, p = Math.max(p, A)); "vertical" === L && (q += f); k.x = p; k.y = q; k.render(!0); F && ("inside" !== t && (0 > r.indexOf("bar") && ("error" !== r || !l.axisSwapped) && l.point.x > b.x1 && l.point.x < b.x2 || !w) && (0 > r.indexOf("column") && ("error" !== r || l.axisSwapped) && l.point.y > b.y1 && l.point.y < b.y2 || !w)) && (d.lineWidth = F, d.strokeStyle = m ? m : "gray", d.setLineDash && d.setLineDash(R(C, F)),
                              d.beginPath(), d.moveTo(l.point.x, l.point.y), 0 <= r.indexOf("bar") || "error" === r && l.axisSwapped ? d.lineTo(p + (0 < l.direction ? 0 : u), q + ("horizontal" === L ? f : -f) / 2) : 0 <= r.indexOf("column") || "error" === r && !l.axisSwapped ? d.lineTo(p + u / 2, q + ((0 < l.direction ? f : -f) + ("horizontal" === L ? f : -f)) / 2) : d.lineTo(p + u / 2, q + ((q < l.point.y ? f : -f) + ("horizontal" === L ? f : -f)) / 2), d.stroke())
                }
              } d = { source: d, dest: this.plotArea.ctx, animationCallback: v.fadeInAnimation, easingFunction: v.easing.easeInQuad, animationBase: 0, startTimePercent: 0.7 }; for (a = 0; a <
                this._indexLabels.length; a++)l = this._indexLabels[a], k = oa("indexLabelBackgroundColor", l.dataPoint, l.dataSeries), l.dataSeries.indexLabelBackgroundColor = h(k) ? s ? "transparent" : null : k; return d
            }; n.prototype.renderLine = function (a) {
              var d = a.targetCanvasCtx || this.plotArea.ctx, b = s ? this._preRenderCtx : d; if (!(0 >= a.dataSeriesIndexes.length)) {
                var c = this._eventManager.ghostCtx; b.save(); var e = this.plotArea; b.beginPath(); b.rect(e.x1, e.y1, e.width, e.height); b.clip(); for (var g = [], A, u = 0; u < a.dataSeriesIndexes.length; u++) {
                  var h =
                    a.dataSeriesIndexes[u], l = this.data[h]; b.lineWidth = l.lineThickness; var r = l.dataPoints, f = "solid"; if (b.setLineDash) { var q = R(l.nullDataLineDashType, l.lineThickness), f = l.lineDashType, k = R(f, l.lineThickness); b.setLineDash(k) } var C = l.id; this._eventManager.objectMap[C] = { objectType: "dataSeries", dataSeriesIndex: h }; C = Q(C); c.strokeStyle = C; c.lineWidth = 0 < l.lineThickness ? Math.max(l.lineThickness, 4) : 0; var C = l._colorSet, m = C = l.lineColor = l.options.lineColor ? l.options.lineColor : C[0]; b.strokeStyle = C; var F = !0, t = 0, L, x; b.beginPath();
                  if (0 < r.length) {
                    for (var n = !1, t = 0; t < r.length; t++)if (L = r[t].x.getTime ? r[t].x.getTime() : r[t].x, !(L < a.axisX.dataInfo.viewPortMin || L > a.axisX.dataInfo.viewPortMax && (!l.connectNullData || !n))) if ("number" !== typeof r[t].y) 0 < t && !(l.connectNullData || n || F) && (b.stroke(), s && c.stroke()), n = !0; else {
                      L = a.axisX.convertValueToPixel(L); x = a.axisY.convertValueToPixel(r[t].y); var w = l.dataPointIds[t]; this._eventManager.objectMap[w] = { id: w, objectType: "dataPoint", dataSeriesIndex: h, dataPointIndex: t, x1: L, y1: x }; F || n ? (!F && l.connectNullData ?
                        (b.setLineDash && (l.options.nullDataLineDashType || f === l.lineDashType && l.lineDashType !== l.nullDataLineDashType) && (b.stroke(), b.beginPath(), b.moveTo(A.x, A.y), f = l.nullDataLineDashType, b.setLineDash(q)), b.lineTo(L, x), s && c.lineTo(L, x)) : (b.beginPath(), b.moveTo(L, x), s && (c.beginPath(), c.moveTo(L, x))), n = F = !1) : (b.lineTo(L, x), s && c.lineTo(L, x), 0 == t % 500 && (b.stroke(), b.beginPath(), b.moveTo(L, x), s && (c.stroke(), c.beginPath(), c.moveTo(L, x)))); A = { x: L, y: x }; t < r.length - 1 && (m !== (r[t].lineColor || C) || f !== (r[t].lineDashType ||
                          l.lineDashType)) && (b.stroke(), b.beginPath(), b.moveTo(L, x), m = r[t].lineColor || C, b.strokeStyle = m, b.setLineDash && (r[t].lineDashType ? (f = r[t].lineDashType, b.setLineDash(R(f, l.lineThickness))) : (f = l.lineDashType, b.setLineDash(k)))); if (0 < r[t].markerSize || 0 < l.markerSize) { var E = l.getMarkerProperties(t, L, x, b); g.push(E); w = Q(w); s && g.push({ x: L, y: x, ctx: c, type: E.type, size: E.size, color: w, borderColor: w, borderThickness: E.borderThickness }) } (r[t].indexLabel || l.indexLabel || r[t].indexLabelFormatter || l.indexLabelFormatter) &&
                            this._indexLabels.push({ chartType: "line", dataPoint: r[t], dataSeries: l, point: { x: L, y: x }, direction: 0 > r[t].y === a.axisY.reversed ? 1 : -1, color: C })
                    } b.stroke(); s && c.stroke()
                  }
                } z.drawMarkers(g); s && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas,
                  0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), c.beginPath()); b.restore(); b.beginPath(); return { source: d, dest: this.plotArea.ctx, animationCallback: v.xClipAnimation, easingFunction: v.easing.linear, animationBase: 0 }
              }
            }; n.prototype.renderStepLine = function (a) {
              var d = a.targetCanvasCtx || this.plotArea.ctx, b = s ? this._preRenderCtx : d; if (!(0 >= a.dataSeriesIndexes.length)) {
                var c = this._eventManager.ghostCtx; b.save(); var e = this.plotArea; b.beginPath(); b.rect(e.x1, e.y1, e.width, e.height); b.clip(); for (var g =
                  [], A, u = 0; u < a.dataSeriesIndexes.length; u++) {
                  var h = a.dataSeriesIndexes[u], l = this.data[h]; b.lineWidth = l.lineThickness; var r = l.dataPoints, f = "solid"; if (b.setLineDash) { var q = R(l.nullDataLineDashType, l.lineThickness), f = l.lineDashType, k = R(f, l.lineThickness); b.setLineDash(k) } var C = l.id; this._eventManager.objectMap[C] = { objectType: "dataSeries", dataSeriesIndex: h }; C = Q(C); c.strokeStyle = C; c.lineWidth = 0 < l.lineThickness ? Math.max(l.lineThickness, 4) : 0; var C = l._colorSet, m = C = l.lineColor = l.options.lineColor ? l.options.lineColor :
                    C[0]; b.strokeStyle = C; var F = !0, t = 0, L, x; b.beginPath(); if (0 < r.length) {
                      for (var n = !1, t = 0; t < r.length; t++)if (L = r[t].getTime ? r[t].x.getTime() : r[t].x, !(L < a.axisX.dataInfo.viewPortMin || L > a.axisX.dataInfo.viewPortMax && (!l.connectNullData || !n))) if ("number" !== typeof r[t].y) 0 < t && !(l.connectNullData || n || F) && (b.stroke(), s && c.stroke()), n = !0; else {
                        var w = x; L = a.axisX.convertValueToPixel(L); x = a.axisY.convertValueToPixel(r[t].y); var E = l.dataPointIds[t]; this._eventManager.objectMap[E] = {
                          id: E, objectType: "dataPoint", dataSeriesIndex: h,
                          dataPointIndex: t, x1: L, y1: x
                        }; F || n ? (!F && l.connectNullData ? (b.setLineDash && (l.options.nullDataLineDashType || f === l.lineDashType && l.lineDashType !== l.nullDataLineDashType) && (b.stroke(), b.beginPath(), b.moveTo(A.x, A.y), f = l.nullDataLineDashType, b.setLineDash(q)), b.lineTo(L, w), b.lineTo(L, x), s && (c.lineTo(L, w), c.lineTo(L, x))) : (b.beginPath(), b.moveTo(L, x), s && (c.beginPath(), c.moveTo(L, x))), n = F = !1) : (b.lineTo(L, w), s && c.lineTo(L, w), b.lineTo(L, x), s && c.lineTo(L, x), 0 == t % 500 && (b.stroke(), b.beginPath(), b.moveTo(L, x), s &&
                          (c.stroke(), c.beginPath(), c.moveTo(L, x)))); A = { x: L, y: x }; t < r.length - 1 && (m !== (r[t].lineColor || C) || f !== (r[t].lineDashType || l.lineDashType)) && (b.stroke(), b.beginPath(), b.moveTo(L, x), m = r[t].lineColor || C, b.strokeStyle = m, b.setLineDash && (r[t].lineDashType ? (f = r[t].lineDashType, b.setLineDash(R(f, l.lineThickness))) : (f = l.lineDashType, b.setLineDash(k)))); if (0 < r[t].markerSize || 0 < l.markerSize) w = l.getMarkerProperties(t, L, x, b), g.push(w), E = Q(E), s && g.push({
                            x: L, y: x, ctx: c, type: w.type, size: w.size, color: E, borderColor: E,
                            borderThickness: w.borderThickness
                          }); (r[t].indexLabel || l.indexLabel || r[t].indexLabelFormatter || l.indexLabelFormatter) && this._indexLabels.push({ chartType: "stepLine", dataPoint: r[t], dataSeries: l, point: { x: L, y: x }, direction: 0 > r[t].y === a.axisY.reversed ? 1 : -1, color: C })
                      } b.stroke(); s && c.stroke()
                    }
                } z.drawMarkers(g); s && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas &&
                  b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), c.beginPath()); b.restore(); b.beginPath(); return { source: d, dest: this.plotArea.ctx, animationCallback: v.xClipAnimation, easingFunction: v.easing.linear, animationBase: 0 }
              }
            }; n.prototype.renderSpline = function (a) {
              function d(a) {
                a = w(a, 2); if (0 < a.length) {
                  c.beginPath(); s && e.beginPath(); c.moveTo(a[0].x, a[0].y); a[0].newStrokeStyle &&
                    (c.strokeStyle = a[0].newStrokeStyle); a[0].newLineDashArray && c.setLineDash(a[0].newLineDashArray); s && e.moveTo(a[0].x, a[0].y); for (var b = 0; b < a.length - 3; b += 3)if (c.bezierCurveTo(a[b + 1].x, a[b + 1].y, a[b + 2].x, a[b + 2].y, a[b + 3].x, a[b + 3].y), s && e.bezierCurveTo(a[b + 1].x, a[b + 1].y, a[b + 2].x, a[b + 2].y, a[b + 3].x, a[b + 3].y), 0 < b && 0 === b % 3E3 || a[b + 3].newStrokeStyle || a[b + 3].newLineDashArray) c.stroke(), c.beginPath(), c.moveTo(a[b + 3].x, a[b + 3].y), a[b + 3].newStrokeStyle && (c.strokeStyle = a[b + 3].newStrokeStyle), a[b + 3].newLineDashArray &&
                      c.setLineDash(a[b + 3].newLineDashArray), s && (e.stroke(), e.beginPath(), e.moveTo(a[b + 3].x, a[b + 3].y)); c.stroke(); s && e.stroke()
                }
              } var b = a.targetCanvasCtx || this.plotArea.ctx, c = s ? this._preRenderCtx : b; if (!(0 >= a.dataSeriesIndexes.length)) {
                var e = this._eventManager.ghostCtx; c.save(); var g = this.plotArea; c.beginPath(); c.rect(g.x1, g.y1, g.width, g.height); c.clip(); for (var A = [], u = 0; u < a.dataSeriesIndexes.length; u++) {
                  var h = a.dataSeriesIndexes[u], l = this.data[h]; c.lineWidth = l.lineThickness; var f = l.dataPoints, p = "solid";
                  if (c.setLineDash) { var q = R(l.nullDataLineDashType, l.lineThickness), p = l.lineDashType, k = R(p, l.lineThickness); c.setLineDash(k) } var C = l.id; this._eventManager.objectMap[C] = { objectType: "dataSeries", dataSeriesIndex: h }; C = Q(C); e.strokeStyle = C; e.lineWidth = 0 < l.lineThickness ? Math.max(l.lineThickness, 4) : 0; var C = l._colorSet, m = C = l.lineColor = l.options.lineColor ? l.options.lineColor : C[0]; c.strokeStyle = C; var F = 0, t, x, va = []; c.beginPath(); if (0 < f.length) for (x = !1, F = 0; F < f.length; F++)if (t = f[F].getTime ? f[F].x.getTime() : f[F].x,
                    !(t < a.axisX.dataInfo.viewPortMin || t > a.axisX.dataInfo.viewPortMax && (!l.connectNullData || !x))) if ("number" !== typeof f[F].y) 0 < F && !x && (l.connectNullData ? c.setLineDash && (0 < va.length && (l.options.nullDataLineDashType || !f[F - 1].lineDashType)) && (va[va.length - 1].newLineDashArray = q, p = l.nullDataLineDashType) : (d(va), va = [])), x = !0; else {
                      t = a.axisX.convertValueToPixel(t); x = a.axisY.convertValueToPixel(f[F].y); var n = l.dataPointIds[F]; this._eventManager.objectMap[n] = {
                        id: n, objectType: "dataPoint", dataSeriesIndex: h, dataPointIndex: F,
                        x1: t, y1: x
                      }; va[va.length] = { x: t, y: x }; F < f.length - 1 && (m !== (f[F].lineColor || C) || p !== (f[F].lineDashType || l.lineDashType)) && (m = f[F].lineColor || C, va[va.length - 1].newStrokeStyle = m, c.setLineDash && (f[F].lineDashType ? (p = f[F].lineDashType, va[va.length - 1].newLineDashArray = R(p, l.lineThickness)) : (p = l.lineDashType, va[va.length - 1].newLineDashArray = k))); if (0 < f[F].markerSize || 0 < l.markerSize) {
                        var Da = l.getMarkerProperties(F, t, x, c); A.push(Da); n = Q(n); s && A.push({
                          x: t, y: x, ctx: e, type: Da.type, size: Da.size, color: n, borderColor: n,
                          borderThickness: Da.borderThickness
                        })
                      } (f[F].indexLabel || l.indexLabel || f[F].indexLabelFormatter || l.indexLabelFormatter) && this._indexLabels.push({ chartType: "spline", dataPoint: f[F], dataSeries: l, point: { x: t, y: x }, direction: 0 > f[F].y === a.axisY.reversed ? 1 : -1, color: C }); x = !1
                    } d(va)
                } z.drawMarkers(A); s && (b.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas,
                  0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(g.x1, g.y1, g.width, g.height), e.beginPath()); c.restore(); c.beginPath(); return { source: b, dest: this.plotArea.ctx, animationCallback: v.xClipAnimation, easingFunction: v.easing.linear, animationBase: 0 }
              }
            }; n.prototype.renderColumn = function (a) {
              var d = a.targetCanvasCtx || this.plotArea.ctx, b = s ? this._preRenderCtx : d; if (!(0 >= a.dataSeriesIndexes.length)) {
                var c = null, e = this.plotArea,
                  g = 0, A, u, h, l = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), g = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, f = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : Math.min(0.15 * this.width, 0.9 * (this.plotArea.width / a.plotType.totalDataSeries)) << 0, p = a.axisX.dataInfo.minDiff; isFinite(p) || (p = 0.3 * Math.abs(a.axisX.range)); p = this.dataPointWidth = this.options.dataPointWidth ?
                    this.dataPointWidth : 0.9 * (e.width * (a.axisX.logarithmic ? Math.log(p) / Math.log(a.axisX.range) : Math.abs(p) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0; this.dataPointMaxWidth && g > f && (g = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, f)); !this.dataPointMaxWidth && (this.dataPointMinWidth && f < g) && (f = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, g)); p < g && (p = g); p > f && (p = f); b.save(); s && this._eventManager.ghostCtx.save(); b.beginPath(); b.rect(e.x1, e.y1, e.width, e.height);
                b.clip(); s && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip()); for (f = 0; f < a.dataSeriesIndexes.length; f++) {
                  var q = a.dataSeriesIndexes[f], k = this.data[q], C = k.dataPoints; if (0 < C.length) for (var m = 5 < p && k.bevelEnabled ? !0 : !1, g = 0; g < C.length; g++)if (C[g].getTime ? h = C[g].x.getTime() : h = C[g].x, !(h < a.axisX.dataInfo.viewPortMin || h > a.axisX.dataInfo.viewPortMax) && "number" === typeof C[g].y) {
                    A = a.axisX.convertValueToPixel(h); u = a.axisY.convertValueToPixel(C[g].y);
                    A = a.axisX.reversed ? A + a.plotType.totalDataSeries * p / 2 - (a.previousDataSeriesCount + f) * p << 0 : A - a.plotType.totalDataSeries * p / 2 + (a.previousDataSeriesCount + f) * p << 0; var F = a.axisX.reversed ? A - p << 0 : A + p << 0, t; 0 <= C[g].y ? t = l : (t = u, u = l); u > t && (c = u, u = t, t = c); c = C[g].color ? C[g].color : k._colorSet[g % k._colorSet.length]; X(b, A, u, F, t, c, 0, null, m && 0 <= C[g].y, 0 > C[g].y && m, !1, !1, k.fillOpacity); c = k.dataPointIds[g]; this._eventManager.objectMap[c] = { id: c, objectType: "dataPoint", dataSeriesIndex: q, dataPointIndex: g, x1: A, y1: u, x2: F, y2: t }; c =
                      Q(c); s && X(this._eventManager.ghostCtx, A, u, F, t, c, 0, null, !1, !1, !1, !1); (C[g].indexLabel || k.indexLabel || C[g].indexLabelFormatter || k.indexLabelFormatter) && this._indexLabels.push({ chartType: "column", dataPoint: C[g], dataSeries: k, point: { x: A + (F - A) / 2, y: 0 > C[g].y === a.axisY.reversed ? u : t }, direction: 0 > C[g].y === a.axisY.reversed ? 1 : -1, bounds: { x1: A, y1: Math.min(u, t), x2: F, y2: Math.max(u, t) }, color: c })
                  }
                } s && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas &&
                  b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore()); b.restore(); return {
                    source: d, dest: this.plotArea.ctx, animationCallback: v.yScaleAnimation, easingFunction: v.easing.easeOutQuart, animationBase: l < a.axisY.bounds.y1 ? a.axisY.bounds.y1 : l > a.axisY.bounds.y2 ?
                      a.axisY.bounds.y2 : l
                  }
              }
            }; n.prototype.renderStackedColumn = function (a) {
              var d = a.targetCanvasCtx || this.plotArea.ctx, b = s ? this._preRenderCtx : d; if (!(0 >= a.dataSeriesIndexes.length)) {
                var c = null, e = this.plotArea, g = [], A = [], u = [], h = [], l = 0, f, p, q = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), l = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1; f = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth :
                  0.15 * this.width << 0; var k = a.axisX.dataInfo.minDiff; isFinite(k) || (k = 0.3 * Math.abs(a.axisX.range)); k = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (e.width * (a.axisX.logarithmic ? Math.log(k) / Math.log(a.axisX.range) : Math.abs(k) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0; this.dataPointMaxWidth && l > f && (l = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, f)); !this.dataPointMaxWidth && (this.dataPointMinWidth && f < l) && (f = Math.max(this.options.dataPointWidth ? this.dataPointWidth :
                    -Infinity, l)); k < l && (k = l); k > f && (k = f); b.save(); s && this._eventManager.ghostCtx.save(); b.beginPath(); b.rect(e.x1, e.y1, e.width, e.height); b.clip(); s && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip()); for (var C = 0; C < a.dataSeriesIndexes.length; C++) {
                      var m = a.dataSeriesIndexes[C], F = this.data[m], t = F.dataPoints; if (0 < t.length) {
                        var x = 5 < k && F.bevelEnabled ? !0 : !1; b.strokeStyle = "#4572A7 "; for (l = 0; l < t.length; l++)if (c = t[l].x.getTime ?
                          t[l].x.getTime() : t[l].x, !(c < a.axisX.dataInfo.viewPortMin || c > a.axisX.dataInfo.viewPortMax) && "number" === typeof t[l].y) {
                          f = a.axisX.convertValueToPixel(c); var z = f - a.plotType.plotUnits.length * k / 2 + a.index * k << 0, n = z + k << 0, w; if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 < t[l].y) u[c] = t[l].y + (u[c] ? u[c] : 0), 0 < u[c] && (p = a.axisY.convertValueToPixel(u[c]), w = "undefined" !== typeof g[c] ? g[c] : q, g[c] = p); else if (a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length &&
                            0 >= t[l].y) h[c] = t[l].y + (h[c] ? h[c] : 0), w = a.axisY.convertValueToPixel(h[c]), p = "undefined" !== typeof A[c] ? A[c] : q, A[c] = w; else if (p = a.axisY.convertValueToPixel(t[l].y), 0 <= t[l].y) { var E = "undefined" !== typeof g[c] ? g[c] : 0; p -= E; w = q - E; g[c] = E + (w - p) } else E = A[c] ? A[c] : 0, w = p + E, p = q + E, A[c] = E + (w - p); c = t[l].color ? t[l].color : F._colorSet[l % F._colorSet.length]; X(b, z, p, n, w, c, 0, null, x && 0 <= t[l].y, 0 > t[l].y && x, !1, !1, F.fillOpacity); c = F.dataPointIds[l]; this._eventManager.objectMap[c] = {
                              id: c, objectType: "dataPoint", dataSeriesIndex: m,
                              dataPointIndex: l, x1: z, y1: p, x2: n, y2: w
                            }; c = Q(c); s && X(this._eventManager.ghostCtx, z, p, n, w, c, 0, null, !1, !1, !1, !1); (t[l].indexLabel || F.indexLabel || t[l].indexLabelFormatter || F.indexLabelFormatter) && this._indexLabels.push({ chartType: "stackedColumn", dataPoint: t[l], dataSeries: F, point: { x: f, y: 0 <= t[l].y ? p : w }, direction: 0 > t[l].y === a.axisY.reversed ? 1 : -1, bounds: { x1: z, y1: Math.min(p, w), x2: n, y2: Math.max(p, w) }, color: c })
                        }
                      }
                    } s && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop",
                      a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore()); b.restore(); return {
                        source: d, dest: this.plotArea.ctx, animationCallback: v.yScaleAnimation, easingFunction: v.easing.easeOutQuart, animationBase: q < a.axisY.bounds.y1 ? a.axisY.bounds.y1 :
                          q > a.axisY.bounds.y2 ? a.axisY.bounds.y2 : q
                      }
              }
            }; n.prototype.renderStackedColumn100 = function (a) {
              var d = a.targetCanvasCtx || this.plotArea.ctx, b = s ? this._preRenderCtx : d; if (!(0 >= a.dataSeriesIndexes.length)) {
                var c = null, e = this.plotArea, g = [], A = [], h = [], f = [], l = 0, r, p, q = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), l = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1; r = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ?
                  this.dataPointWidth : 0.15 * this.width << 0; var k = a.axisX.dataInfo.minDiff; isFinite(k) || (k = 0.3 * Math.abs(a.axisX.range)); k = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (e.width * (a.axisX.logarithmic ? Math.log(k) / Math.log(a.axisX.range) : Math.abs(k) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0; this.dataPointMaxWidth && l > r && (l = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, r)); !this.dataPointMaxWidth && (this.dataPointMinWidth && r < l) && (r = Math.max(this.options.dataPointWidth ?
                    this.dataPointWidth : -Infinity, l)); k < l && (k = l); k > r && (k = r); b.save(); s && this._eventManager.ghostCtx.save(); b.beginPath(); b.rect(e.x1, e.y1, e.width, e.height); b.clip(); s && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip()); for (var C = 0; C < a.dataSeriesIndexes.length; C++) {
                      var m = a.dataSeriesIndexes[C], F = this.data[m], t = F.dataPoints; if (0 < t.length) for (var x = 5 < k && F.bevelEnabled ? !0 : !1, l = 0; l < t.length; l++)if (c = t[l].x.getTime ? t[l].x.getTime() :
                        t[l].x, !(c < a.axisX.dataInfo.viewPortMin || c > a.axisX.dataInfo.viewPortMax) && "number" === typeof t[l].y) {
                        r = a.axisX.convertValueToPixel(c); p = 0 !== a.dataPointYSums[c] ? 100 * (t[l].y / a.dataPointYSums[c]) : 0; var z = r - a.plotType.plotUnits.length * k / 2 + a.index * k << 0, n = z + k << 0, w; if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 < t[l].y) { h[c] = p + ("undefined" !== typeof h[c] ? h[c] : 0); if (0 >= h[c]) continue; p = a.axisY.convertValueToPixel(h[c]); w = g[c] ? g[c] : q; g[c] = p } else if (a.axisY.scaleBreaks &&
                          0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 >= t[l].y) f[c] = p + ("undefined" !== typeof f[c] ? f[c] : 0), w = a.axisY.convertValueToPixel(f[c]), p = A[c] ? A[c] : q, A[c] = w; else if (p = a.axisY.convertValueToPixel(p), 0 <= t[l].y) { var E = "undefined" !== typeof g[c] ? g[c] : 0; p -= E; w = q - E; a.dataSeriesIndexes.length - 1 === C && 1 >= Math.abs(e.y1 - p) && (p = e.y1); g[c] = E + (w - p) } else E = "undefined" !== typeof A[c] ? A[c] : 0, w = p + E, p = q + E, a.dataSeriesIndexes.length - 1 === C && 1 >= Math.abs(e.y2 - w) && (w = e.y2), A[c] = E + (w - p); c = t[l].color ? t[l].color : F._colorSet[l % F._colorSet.length];
                        X(b, z, p, n, w, c, 0, null, x && 0 <= t[l].y, 0 > t[l].y && x, !1, !1, F.fillOpacity); c = F.dataPointIds[l]; this._eventManager.objectMap[c] = { id: c, objectType: "dataPoint", dataSeriesIndex: m, dataPointIndex: l, x1: z, y1: p, x2: n, y2: w }; c = Q(c); s && X(this._eventManager.ghostCtx, z, p, n, w, c, 0, null, !1, !1, !1, !1); (t[l].indexLabel || F.indexLabel || t[l].indexLabelFormatter || F.indexLabelFormatter) && this._indexLabels.push({
                          chartType: "stackedColumn100", dataPoint: t[l], dataSeries: F, point: { x: r, y: 0 <= t[l].y ? p : w }, direction: 0 > t[l].y === a.axisY.reversed ?
                            1 : -1, bounds: { x1: z, y1: Math.min(p, w), x2: n, y2: Math.max(p, w) }, color: c
                        })
                      }
                    } s && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());
                b.restore(); return { source: d, dest: this.plotArea.ctx, animationCallback: v.yScaleAnimation, easingFunction: v.easing.easeOutQuart, animationBase: q < a.axisY.bounds.y1 ? a.axisY.bounds.y1 : q > a.axisY.bounds.y2 ? a.axisY.bounds.y2 : q }
              }
            }; n.prototype.renderBar = function (a) {
              var d = a.targetCanvasCtx || this.plotArea.ctx, b = s ? this._preRenderCtx : d; if (!(0 >= a.dataSeriesIndexes.length)) {
                var c = null, e = this.plotArea, g = 0, A, h, f, l = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), g = this.options.dataPointMinWidth ?
                  this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, r = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : Math.min(0.15 * this.height, 0.9 * (this.plotArea.height / a.plotType.totalDataSeries)) << 0, p = a.axisX.dataInfo.minDiff; isFinite(p) || (p = 0.3 * Math.abs(a.axisX.range)); p = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (e.height * (a.axisX.logarithmic ? Math.log(p) / Math.log(a.axisX.range) : Math.abs(p) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) <<
                    0; this.dataPointMaxWidth && g > r && (g = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, r)); !this.dataPointMaxWidth && (this.dataPointMinWidth && r < g) && (r = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, g)); p < g && (p = g); p > r && (p = r); b.save(); s && this._eventManager.ghostCtx.save(); b.beginPath(); b.rect(e.x1, e.y1, e.width, e.height); b.clip(); s && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());
                for (r = 0; r < a.dataSeriesIndexes.length; r++) {
                  var q = a.dataSeriesIndexes[r], k = this.data[q], C = k.dataPoints; if (0 < C.length) {
                    var m = 5 < p && k.bevelEnabled ? !0 : !1; b.strokeStyle = "#4572A7 "; for (g = 0; g < C.length; g++)if (C[g].getTime ? f = C[g].x.getTime() : f = C[g].x, !(f < a.axisX.dataInfo.viewPortMin || f > a.axisX.dataInfo.viewPortMax) && "number" === typeof C[g].y) {
                      h = a.axisX.convertValueToPixel(f); A = a.axisY.convertValueToPixel(C[g].y); h = a.axisX.reversed ? h + a.plotType.totalDataSeries * p / 2 - (a.previousDataSeriesCount + r) * p << 0 : h - a.plotType.totalDataSeries *
                        p / 2 + (a.previousDataSeriesCount + r) * p << 0; var F = a.axisX.reversed ? h - p << 0 : h + p << 0, t; 0 <= C[g].y ? t = l : (t = A, A = l); c = C[g].color ? C[g].color : k._colorSet[g % k._colorSet.length]; X(b, t, h, A, F, c, 0, null, m, !1, !1, !1, k.fillOpacity); c = k.dataPointIds[g]; this._eventManager.objectMap[c] = { id: c, objectType: "dataPoint", dataSeriesIndex: q, dataPointIndex: g, x1: t, y1: h, x2: A, y2: F }; c = Q(c); s && X(this._eventManager.ghostCtx, t, h, A, F, c, 0, null, !1, !1, !1, !1); (C[g].indexLabel || k.indexLabel || C[g].indexLabelFormatter || k.indexLabelFormatter) && this._indexLabels.push({
                          chartType: "bar",
                          dataPoint: C[g], dataSeries: k, point: { x: 0 <= C[g].y ? A : t, y: h + (F - h) / 2 }, direction: 0 > C[g].y === a.axisY.reversed ? 1 : -1, bounds: { x1: Math.min(t, A), y1: h, x2: Math.max(t, A), y2: F }, color: c
                        })
                    }
                  }
                } s && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas,
                  0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore()); b.restore(); return { source: d, dest: this.plotArea.ctx, animationCallback: v.xScaleAnimation, easingFunction: v.easing.easeOutQuart, animationBase: l < a.axisY.bounds.x1 ? a.axisY.bounds.x1 : l > a.axisY.bounds.x2 ? a.axisY.bounds.x2 : l }
              }
            }; n.prototype.renderStackedBar = function (a) {
              var d = a.targetCanvasCtx || this.plotArea.ctx, b = s ? this._preRenderCtx : d; if (!(0 >= a.dataSeriesIndexes.length)) {
                var c = null, e = this.plotArea, g =
                  [], A = [], h = [], f = [], l = 0, r, p, q = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), l = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1; p = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.15 * this.height << 0; var k = a.axisX.dataInfo.minDiff; isFinite(k) || (k = 0.3 * Math.abs(a.axisX.range)); k = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (e.height * (a.axisX.logarithmic ? Math.log(k) /
                    Math.log(a.axisX.range) : Math.abs(k) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0; this.dataPointMaxWidth && l > p && (l = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, p)); !this.dataPointMaxWidth && (this.dataPointMinWidth && p < l) && (p = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, l)); k < l && (k = l); k > p && (k = p); b.save(); s && this._eventManager.ghostCtx.save(); b.beginPath(); b.rect(e.x1, e.y1, e.width, e.height); b.clip(); s && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1,
                      e.y1, e.width, e.height), this._eventManager.ghostCtx.clip()); for (var C = 0; C < a.dataSeriesIndexes.length; C++) {
                        var m = a.dataSeriesIndexes[C], F = this.data[m], t = F.dataPoints; if (0 < t.length) {
                          var x = 5 < k && F.bevelEnabled ? !0 : !1; b.strokeStyle = "#4572A7 "; for (l = 0; l < t.length; l++)if (c = t[l].x.getTime ? t[l].x.getTime() : t[l].x, !(c < a.axisX.dataInfo.viewPortMin || c > a.axisX.dataInfo.viewPortMax) && "number" === typeof t[l].y) {
                            p = a.axisX.convertValueToPixel(c); var z = p - a.plotType.plotUnits.length * k / 2 + a.index * k << 0, n = z + k << 0, w; if (a.axisY.logarithmic ||
                              a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 < t[l].y) h[c] = t[l].y + (h[c] ? h[c] : 0), 0 < h[c] && (w = g[c] ? g[c] : q, g[c] = r = a.axisY.convertValueToPixel(h[c])); else if (a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 >= t[l].y) f[c] = t[l].y + (f[c] ? f[c] : 0), r = A[c] ? A[c] : q, A[c] = w = a.axisY.convertValueToPixel(f[c]); else if (r = a.axisY.convertValueToPixel(t[l].y), 0 <= t[l].y) { var E = g[c] ? g[c] : 0; w = q + E; r += E; g[c] = E + (r - w) } else E = A[c] ? A[c] : 0, w = r - E, r = q - E, A[c] = E + (r - w); c = t[l].color ? t[l].color : F._colorSet[l %
                                F._colorSet.length]; X(b, w, z, r, n, c, 0, null, x, !1, !1, !1, F.fillOpacity); c = F.dataPointIds[l]; this._eventManager.objectMap[c] = { id: c, objectType: "dataPoint", dataSeriesIndex: m, dataPointIndex: l, x1: w, y1: z, x2: r, y2: n }; c = Q(c); s && X(this._eventManager.ghostCtx, w, z, r, n, c, 0, null, !1, !1, !1, !1); (t[l].indexLabel || F.indexLabel || t[l].indexLabelFormatter || F.indexLabelFormatter) && this._indexLabels.push({
                                  chartType: "stackedBar", dataPoint: t[l], dataSeries: F, point: { x: 0 <= t[l].y ? r : w, y: p }, direction: 0 > t[l].y === a.axisY.reversed ? 1 : -1,
                                  bounds: { x1: Math.min(w, r), y1: z, x2: Math.max(w, r), y2: n }, color: c
                                })
                          }
                        }
                      } s && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());
                b.restore(); return { source: d, dest: this.plotArea.ctx, animationCallback: v.xScaleAnimation, easingFunction: v.easing.easeOutQuart, animationBase: q < a.axisY.bounds.x1 ? a.axisY.bounds.x1 : q > a.axisY.bounds.x2 ? a.axisY.bounds.x2 : q }
              }
            }; n.prototype.renderStackedBar100 = function (a) {
              var d = a.targetCanvasCtx || this.plotArea.ctx, b = s ? this._preRenderCtx : d; if (!(0 >= a.dataSeriesIndexes.length)) {
                var c = null, e = this.plotArea, g = [], A = [], h = [], f = [], l = 0, r, p, q = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), l =
                  this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1; p = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.15 * this.height << 0; var k = a.axisX.dataInfo.minDiff; isFinite(k) || (k = 0.3 * Math.abs(a.axisX.range)); k = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (e.height * (a.axisX.logarithmic ? Math.log(k) / Math.log(a.axisX.range) : Math.abs(k) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0; this.dataPointMaxWidth &&
                    l > p && (l = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, p)); !this.dataPointMaxWidth && (this.dataPointMinWidth && p < l) && (p = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, l)); k < l && (k = l); k > p && (k = p); b.save(); s && this._eventManager.ghostCtx.save(); b.beginPath(); b.rect(e.x1, e.y1, e.width, e.height); b.clip(); s && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip()); for (var C = 0; C < a.dataSeriesIndexes.length; C++) {
                      var m =
                        a.dataSeriesIndexes[C], F = this.data[m], t = F.dataPoints; if (0 < t.length) {
                          var x = 5 < k && F.bevelEnabled ? !0 : !1; b.strokeStyle = "#4572A7 "; for (l = 0; l < t.length; l++)if (c = t[l].x.getTime ? t[l].x.getTime() : t[l].x, !(c < a.axisX.dataInfo.viewPortMin || c > a.axisX.dataInfo.viewPortMax) && "number" === typeof t[l].y) {
                            p = a.axisX.convertValueToPixel(c); var z; z = 0 !== a.dataPointYSums[c] ? 100 * (t[l].y / a.dataPointYSums[c]) : 0; var n = p - a.plotType.plotUnits.length * k / 2 + a.index * k << 0, w = n + k << 0; if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length &&
                              0 < t[l].y) { h[c] = z + (h[c] ? h[c] : 0); if (0 >= h[c]) continue; z = g[c] ? g[c] : q; g[c] = r = a.axisY.convertValueToPixel(h[c]) } else if (a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 >= t[l].y) f[c] = z + (f[c] ? f[c] : 0), r = A[c] ? A[c] : q, A[c] = z = a.axisY.convertValueToPixel(f[c]); else if (r = a.axisY.convertValueToPixel(z), 0 <= t[l].y) { var E = g[c] ? g[c] : 0; z = q + E; r += E; a.dataSeriesIndexes.length - 1 === C && 1 >= Math.abs(e.x2 - r) && (r = e.x2); g[c] = E + (r - z) } else E = A[c] ? A[c] : 0, z = r - E, r = q - E, a.dataSeriesIndexes.length - 1 === C && 1 >= Math.abs(e.x1 -
                                z) && (z = e.x1), A[c] = E + (r - z); c = t[l].color ? t[l].color : F._colorSet[l % F._colorSet.length]; X(b, z, n, r, w, c, 0, null, x, !1, !1, !1, F.fillOpacity); c = F.dataPointIds[l]; this._eventManager.objectMap[c] = { id: c, objectType: "dataPoint", dataSeriesIndex: m, dataPointIndex: l, x1: z, y1: n, x2: r, y2: w }; c = Q(c); s && X(this._eventManager.ghostCtx, z, n, r, w, c, 0, null, !1, !1, !1, !1); (t[l].indexLabel || F.indexLabel || t[l].indexLabelFormatter || F.indexLabelFormatter) && this._indexLabels.push({
                                  chartType: "stackedBar100", dataPoint: t[l], dataSeries: F, point: {
                                    x: 0 <=
                                      t[l].y ? r : z, y: p
                                  }, direction: 0 > t[l].y === a.axisY.reversed ? 1 : -1, bounds: { x1: Math.min(z, r), y1: n, x2: Math.max(z, r), y2: w }, color: c
                                })
                          }
                        }
                    } s && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1,
                      e.y1, e.width, e.height), this._eventManager.ghostCtx.restore()); b.restore(); return { source: d, dest: this.plotArea.ctx, animationCallback: v.xScaleAnimation, easingFunction: v.easing.easeOutQuart, animationBase: q < a.axisY.bounds.x1 ? a.axisY.bounds.x1 : q > a.axisY.bounds.x2 ? a.axisY.bounds.x2 : q }
              }
            }; n.prototype.renderArea = function (a) {
              var d, b; function c() {
                Da && (0 < k.lineThickness && g.stroke(), a.axisY.logarithmic || 0 >= a.axisY.viewportMinimum && 0 <= a.axisY.viewportMaximum ? w = n : 0 > a.axisY.viewportMaximum ? w = h.y1 : 0 < a.axisY.viewportMinimum &&
                  (w = n), g.lineTo(F, w), g.lineTo(Da.x, w), g.closePath(), g.globalAlpha = k.fillOpacity, g.fill(), g.globalAlpha = 1, s && (A.lineTo(F, w), A.lineTo(Da.x, w), A.closePath(), A.fill()), g.beginPath(), g.moveTo(F, t), A.beginPath(), A.moveTo(F, t), Da = { x: F, y: t })
              } var e = a.targetCanvasCtx || this.plotArea.ctx, g = s ? this._preRenderCtx : e; if (!(0 >= a.dataSeriesIndexes.length)) {
                var A = this._eventManager.ghostCtx, h = a.axisY.lineCoordinates, f = [], l = this.plotArea, r; g.save(); s && A.save(); g.beginPath(); g.rect(l.x1, l.y1, l.width, l.height); g.clip(); s &&
                  (A.beginPath(), A.rect(l.x1, l.y1, l.width, l.height), A.clip()); for (var p = 0; p < a.dataSeriesIndexes.length; p++) {
                    var q = a.dataSeriesIndexes[p], k = this.data[q], C = k.dataPoints, f = k.id; this._eventManager.objectMap[f] = { objectType: "dataSeries", dataSeriesIndex: q }; f = Q(f); A.fillStyle = f; f = []; d = !0; var m = 0, F, t, x, n = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), w, Da = null; if (0 < C.length) {
                      var E = k._colorSet[m % k._colorSet.length], y = k.lineColor = k.options.lineColor || E, B = y; g.fillStyle = E; g.strokeStyle =
                        y; g.lineWidth = k.lineThickness; b = "solid"; if (g.setLineDash) { var P = R(k.nullDataLineDashType, k.lineThickness); b = k.lineDashType; var ca = R(b, k.lineThickness); g.setLineDash(ca) } for (var ea = !0; m < C.length; m++)if (x = C[m].x.getTime ? C[m].x.getTime() : C[m].x, !(x < a.axisX.dataInfo.viewPortMin || x > a.axisX.dataInfo.viewPortMax && (!k.connectNullData || !ea))) if ("number" !== typeof C[m].y) k.connectNullData || (ea || d) || c(), ea = !0; else {
                          F = a.axisX.convertValueToPixel(x); t = a.axisY.convertValueToPixel(C[m].y); d || ea ? (!d && k.connectNullData ?
                            (g.setLineDash && (k.options.nullDataLineDashType || b === k.lineDashType && k.lineDashType !== k.nullDataLineDashType) && (d = F, b = t, F = r.x, t = r.y, c(), g.moveTo(r.x, r.y), F = d, t = b, Da = r, b = k.nullDataLineDashType, g.setLineDash(P)), g.lineTo(F, t), s && A.lineTo(F, t)) : (g.beginPath(), g.moveTo(F, t), s && (A.beginPath(), A.moveTo(F, t)), Da = { x: F, y: t }), ea = d = !1) : (g.lineTo(F, t), s && A.lineTo(F, t), 0 == m % 250 && c()); r = { x: F, y: t }; m < C.length - 1 && (B !== (C[m].lineColor || y) || b !== (C[m].lineDashType || k.lineDashType)) && (c(), B = C[m].lineColor || y, g.strokeStyle =
                              B, g.setLineDash && (C[m].lineDashType ? (b = C[m].lineDashType, g.setLineDash(R(b, k.lineThickness))) : (b = k.lineDashType, g.setLineDash(ca)))); var $ = k.dataPointIds[m]; this._eventManager.objectMap[$] = { id: $, objectType: "dataPoint", dataSeriesIndex: q, dataPointIndex: m, x1: F, y1: t }; 0 !== C[m].markerSize && (0 < C[m].markerSize || 0 < k.markerSize) && (x = k.getMarkerProperties(m, F, t, g), f.push(x), $ = Q($), s && f.push({ x: F, y: t, ctx: A, type: x.type, size: x.size, color: $, borderColor: $, borderThickness: x.borderThickness })); (C[m].indexLabel || k.indexLabel ||
                                C[m].indexLabelFormatter || k.indexLabelFormatter) && this._indexLabels.push({ chartType: "area", dataPoint: C[m], dataSeries: k, point: { x: F, y: t }, direction: 0 > C[m].y === a.axisY.reversed ? 1 : -1, color: E })
                        } c(); z.drawMarkers(f)
                    }
                  } s && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), g.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && g.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && g.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas,
                    0, 0, this.width, this.height), g.clearRect(l.x1, l.y1, l.width, l.height), this._eventManager.ghostCtx.restore()); g.restore(); return { source: e, dest: this.plotArea.ctx, animationCallback: v.xClipAnimation, easingFunction: v.easing.linear, animationBase: 0 }
              }
            }; n.prototype.renderSplineArea = function (a) {
              function d() {
                var b = w(L, 2); if (0 < b.length) {
                  if (0 < r.lineThickness) {
                    c.beginPath(); c.moveTo(b[0].x, b[0].y); b[0].newStrokeStyle && (c.strokeStyle = b[0].newStrokeStyle); b[0].newLineDashArray && c.setLineDash(b[0].newLineDashArray);
                    for (var d = 0; d < b.length - 3; d += 3)if (c.bezierCurveTo(b[d + 1].x, b[d + 1].y, b[d + 2].x, b[d + 2].y, b[d + 3].x, b[d + 3].y), s && e.bezierCurveTo(b[d + 1].x, b[d + 1].y, b[d + 2].x, b[d + 2].y, b[d + 3].x, b[d + 3].y), b[d + 3].newStrokeStyle || b[d + 3].newLineDashArray) c.stroke(), c.beginPath(), c.moveTo(b[d + 3].x, b[d + 3].y), b[d + 3].newStrokeStyle && (c.strokeStyle = b[d + 3].newStrokeStyle), b[d + 3].newLineDashArray && c.setLineDash(b[d + 3].newLineDashArray); c.stroke()
                  } c.beginPath(); c.moveTo(b[0].x, b[0].y); s && (e.beginPath(), e.moveTo(b[0].x, b[0].y)); for (d =
                    0; d < b.length - 3; d += 3)c.bezierCurveTo(b[d + 1].x, b[d + 1].y, b[d + 2].x, b[d + 2].y, b[d + 3].x, b[d + 3].y), s && e.bezierCurveTo(b[d + 1].x, b[d + 1].y, b[d + 2].x, b[d + 2].y, b[d + 3].x, b[d + 3].y); a.axisY.logarithmic || 0 >= a.axisY.viewportMinimum && 0 <= a.axisY.viewportMaximum ? F = x : 0 > a.axisY.viewportMaximum ? F = g.y1 : 0 < a.axisY.viewportMinimum && (F = x); t = { x: b[0].x, y: b[0].y }; c.lineTo(b[b.length - 1].x, F); c.lineTo(t.x, F); c.closePath(); c.globalAlpha = r.fillOpacity; c.fill(); c.globalAlpha = 1; s && (e.lineTo(b[b.length - 1].x, F), e.lineTo(t.x, F), e.closePath(),
                      e.fill())
                }
              } var b = a.targetCanvasCtx || this.plotArea.ctx, c = s ? this._preRenderCtx : b; if (!(0 >= a.dataSeriesIndexes.length)) {
                var e = this._eventManager.ghostCtx, g = a.axisY.lineCoordinates, h = [], f = this.plotArea; c.save(); s && e.save(); c.beginPath(); c.rect(f.x1, f.y1, f.width, f.height); c.clip(); s && (e.beginPath(), e.rect(f.x1, f.y1, f.width, f.height), e.clip()); for (var m = 0; m < a.dataSeriesIndexes.length; m++) {
                  var l = a.dataSeriesIndexes[m], r = this.data[l], p = r.dataPoints, h = r.id; this._eventManager.objectMap[h] = {
                    objectType: "dataSeries",
                    dataSeriesIndex: l
                  }; h = Q(h); e.fillStyle = h; var h = [], q = 0, k, C, x = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), F, t = null, L = []; if (0 < p.length) {
                    var n = r._colorSet[q % r._colorSet.length], Ca = r.lineColor = r.options.lineColor || n, y = Ca; c.fillStyle = n; c.strokeStyle = Ca; c.lineWidth = r.lineThickness; var E = "solid"; if (c.setLineDash) { var B = R(r.nullDataLineDashType, r.lineThickness), E = r.lineDashType, D = R(E, r.lineThickness); c.setLineDash(D) } for (C = !1; q < p.length; q++)if (k = p[q].x.getTime ? p[q].x.getTime() :
                      p[q].x, !(k < a.axisX.dataInfo.viewPortMin || k > a.axisX.dataInfo.viewPortMax && (!r.connectNullData || !C))) if ("number" !== typeof p[q].y) 0 < q && !C && (r.connectNullData ? c.setLineDash && (0 < L.length && (r.options.nullDataLineDashType || !p[q - 1].lineDashType)) && (L[L.length - 1].newLineDashArray = B, E = r.nullDataLineDashType) : (d(), L = [])), C = !0; else {
                        k = a.axisX.convertValueToPixel(k); C = a.axisY.convertValueToPixel(p[q].y); var P = r.dataPointIds[q]; this._eventManager.objectMap[P] = {
                          id: P, objectType: "dataPoint", dataSeriesIndex: l, dataPointIndex: q,
                          x1: k, y1: C
                        }; L[L.length] = { x: k, y: C }; q < p.length - 1 && (y !== (p[q].lineColor || Ca) || E !== (p[q].lineDashType || r.lineDashType)) && (y = p[q].lineColor || Ca, L[L.length - 1].newStrokeStyle = y, c.setLineDash && (p[q].lineDashType ? (E = p[q].lineDashType, L[L.length - 1].newLineDashArray = R(E, r.lineThickness)) : (E = r.lineDashType, L[L.length - 1].newLineDashArray = D))); if (0 !== p[q].markerSize && (0 < p[q].markerSize || 0 < r.markerSize)) {
                          var ca = r.getMarkerProperties(q, k, C, c); h.push(ca); P = Q(P); s && h.push({
                            x: k, y: C, ctx: e, type: ca.type, size: ca.size, color: P,
                            borderColor: P, borderThickness: ca.borderThickness
                          })
                        } (p[q].indexLabel || r.indexLabel || p[q].indexLabelFormatter || r.indexLabelFormatter) && this._indexLabels.push({ chartType: "splineArea", dataPoint: p[q], dataSeries: r, point: { x: k, y: C }, direction: 0 > p[q].y === a.axisY.reversed ? 1 : -1, color: n }); C = !1
                      } d(); z.drawMarkers(h)
                  }
                } s && (b.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas &&
                  c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(f.x1, f.y1, f.width, f.height), this._eventManager.ghostCtx.restore()); c.restore(); return { source: b, dest: this.plotArea.ctx, animationCallback: v.xClipAnimation, easingFunction: v.easing.linear, animationBase: 0 }
              }
            }; n.prototype.renderStepArea = function (a) {
              var d, b; function c() {
                y && (0 < k.lineThickness && g.stroke(), a.axisY.logarithmic || 0 >= a.axisY.viewportMinimum &&
                  0 <= a.axisY.viewportMaximum ? w = n : 0 > a.axisY.viewportMaximum ? w = f.y1 : 0 < a.axisY.viewportMinimum && (w = n), g.lineTo(F, w), g.lineTo(y.x, w), g.closePath(), g.globalAlpha = k.fillOpacity, g.fill(), g.globalAlpha = 1, s && (h.lineTo(F, w), h.lineTo(y.x, w), h.closePath(), h.fill()), g.beginPath(), g.moveTo(F, t), h.beginPath(), h.moveTo(F, t), y = { x: F, y: t })
              } var e = a.targetCanvasCtx || this.plotArea.ctx, g = s ? this._preRenderCtx : e; if (!(0 >= a.dataSeriesIndexes.length)) {
                var h = this._eventManager.ghostCtx, f = a.axisY.lineCoordinates, m = [], l = this.plotArea,
                  r; g.save(); s && h.save(); g.beginPath(); g.rect(l.x1, l.y1, l.width, l.height); g.clip(); s && (h.beginPath(), h.rect(l.x1, l.y1, l.width, l.height), h.clip()); for (var p = 0; p < a.dataSeriesIndexes.length; p++) {
                    var q = a.dataSeriesIndexes[p], k = this.data[q], C = k.dataPoints, m = k.id; this._eventManager.objectMap[m] = { objectType: "dataSeries", dataSeriesIndex: q }; m = Q(m); h.fillStyle = m; m = []; d = !0; var x = 0, F, t, L, n = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), w, y = null; b = !1; if (0 < C.length) {
                      var E = k._colorSet[x %
                        k._colorSet.length], B = k.lineColor = k.options.lineColor || E, D = B; g.fillStyle = E; g.strokeStyle = B; g.lineWidth = k.lineThickness; var P = "solid"; if (g.setLineDash) { var ca = R(k.nullDataLineDashType, k.lineThickness), P = k.lineDashType, ea = R(P, k.lineThickness); g.setLineDash(ea) } for (; x < C.length; x++)if (L = C[x].x.getTime ? C[x].x.getTime() : C[x].x, !(L < a.axisX.dataInfo.viewPortMin || L > a.axisX.dataInfo.viewPortMax && (!k.connectNullData || !b))) {
                          var $ = t; "number" !== typeof C[x].y ? (k.connectNullData || (b || d) || c(), b = !0) : (F = a.axisX.convertValueToPixel(L),
                            t = a.axisY.convertValueToPixel(C[x].y), d || b ? (!d && k.connectNullData ? (g.setLineDash && (k.options.nullDataLineDashType || P === k.lineDashType && k.lineDashType !== k.nullDataLineDashType) && (d = F, b = t, F = r.x, t = r.y, c(), g.moveTo(r.x, r.y), F = d, t = b, y = r, P = k.nullDataLineDashType, g.setLineDash(ca)), g.lineTo(F, $), g.lineTo(F, t), s && (h.lineTo(F, $), h.lineTo(F, t))) : (g.beginPath(), g.moveTo(F, t), s && (h.beginPath(), h.moveTo(F, t)), y = { x: F, y: t }), b = d = !1) : (g.lineTo(F, $), s && h.lineTo(F, $), g.lineTo(F, t), s && h.lineTo(F, t), 0 == x % 250 && c()), r =
                            { x: F, y: t }, x < C.length - 1 && (D !== (C[x].lineColor || B) || P !== (C[x].lineDashType || k.lineDashType)) && (c(), D = C[x].lineColor || B, g.strokeStyle = D, g.setLineDash && (C[x].lineDashType ? (P = C[x].lineDashType, g.setLineDash(R(P, k.lineThickness))) : (P = k.lineDashType, g.setLineDash(ea)))), L = k.dataPointIds[x], this._eventManager.objectMap[L] = { id: L, objectType: "dataPoint", dataSeriesIndex: q, dataPointIndex: x, x1: F, y1: t }, 0 !== C[x].markerSize && (0 < C[x].markerSize || 0 < k.markerSize) && ($ = k.getMarkerProperties(x, F, t, g), m.push($), L = Q(L), s &&
                              m.push({ x: F, y: t, ctx: h, type: $.type, size: $.size, color: L, borderColor: L, borderThickness: $.borderThickness })), (C[x].indexLabel || k.indexLabel || C[x].indexLabelFormatter || k.indexLabelFormatter) && this._indexLabels.push({ chartType: "stepArea", dataPoint: C[x], dataSeries: k, point: { x: F, y: t }, direction: 0 > C[x].y === a.axisY.reversed ? 1 : -1, color: E }))
                        } c(); z.drawMarkers(m)
                    }
                  } s && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), g.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && g.drawImage(a.axisX.maskCanvas,
                    0, 0, this.width, this.height), a.axisY.maskCanvas && g.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), g.clearRect(l.x1, l.y1, l.width, l.height), this._eventManager.ghostCtx.restore()); g.restore(); return { source: e, dest: this.plotArea.ctx, animationCallback: v.xClipAnimation, easingFunction: v.easing.linear, animationBase: 0 }
              }
            }; n.prototype.renderStackedArea = function (a) {
              function d() {
                if (!(1 > l.length)) {
                  for (0 <
                    E.lineThickness && c.stroke(); 0 < l.length;) { var a = l.pop(); c.lineTo(a.x, a.y); s && F.lineTo(a.x, a.y) } c.closePath(); c.globalAlpha = E.fillOpacity; c.fill(); c.globalAlpha = 1; c.beginPath(); s && (F.closePath(), F.fill(), F.beginPath()); l = []
                }
              } var b = a.targetCanvasCtx || this.plotArea.ctx, c = s ? this._preRenderCtx : b; if (!(0 >= a.dataSeriesIndexes.length)) {
                var e = null, g = null, h = [], f = this.plotArea, m = [], l = [], r = [], p = [], q = 0, k, C, x = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), F = this._eventManager.ghostCtx,
                  t, L, n; s && F.beginPath(); c.save(); s && F.save(); c.beginPath(); c.rect(f.x1, f.y1, f.width, f.height); c.clip(); s && (F.beginPath(), F.rect(f.x1, f.y1, f.width, f.height), F.clip()); for (var e = [], w = 0; w < a.dataSeriesIndexes.length; w++) { var y = a.dataSeriesIndexes[w], E = this.data[y], B = E.dataPoints; E.dataPointIndexes = []; for (q = 0; q < B.length; q++)y = B[q].x.getTime ? B[q].x.getTime() : B[q].x, E.dataPointIndexes[y] = q, e[y] || (r.push(y), e[y] = !0); r.sort(Xa) } for (w = 0; w < a.dataSeriesIndexes.length; w++) {
                    y = a.dataSeriesIndexes[w]; E = this.data[y];
                    B = E.dataPoints; L = !0; l = []; q = E.id; this._eventManager.objectMap[q] = { objectType: "dataSeries", dataSeriesIndex: y }; q = Q(q); F.fillStyle = q; if (0 < r.length) {
                      var e = E._colorSet[0], D = E.lineColor = E.options.lineColor || e, P = D; c.fillStyle = e; c.strokeStyle = D; c.lineWidth = E.lineThickness; n = "solid"; if (c.setLineDash) { var ca = R(E.nullDataLineDashType, E.lineThickness); n = E.lineDashType; var ea = R(n, E.lineThickness); c.setLineDash(ea) } for (var $ = !0, q = 0; q < r.length; q++) {
                        var g = r[q], ia = null, ia = 0 <= E.dataPointIndexes[g] ? B[E.dataPointIndexes[g]] :
                          { x: g, y: null }; if (!(g < a.axisX.dataInfo.viewPortMin || g > a.axisX.dataInfo.viewPortMax && (!E.connectNullData || !$))) if ("number" !== typeof ia.y) E.connectNullData || ($ || L) || d(), $ = !0; else {
                            k = a.axisX.convertValueToPixel(g); var ra = m[g] ? m[g] : 0; if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length) { p[g] = ia.y + (p[g] ? p[g] : 0); if (0 >= p[g] && a.axisY.logarithmic) continue; C = a.axisY.convertValueToPixel(p[g]) } else C = a.axisY.convertValueToPixel(ia.y), C -= ra; l.push({ x: k, y: x - ra }); m[g] = x - C; L || $ ? (!L &&
                              E.connectNullData ? (c.setLineDash && (E.options.nullDataLineDashType || n === E.lineDashType && E.lineDashType !== E.nullDataLineDashType) && (L = l.pop(), n = l[l.length - 1], d(), c.moveTo(t.x, t.y), l.push(n), l.push(L), n = E.nullDataLineDashType, c.setLineDash(ca)), c.lineTo(k, C), s && F.lineTo(k, C)) : (c.beginPath(), c.moveTo(k, C), s && (F.beginPath(), F.moveTo(k, C))), $ = L = !1) : (c.lineTo(k, C), s && F.lineTo(k, C), 0 == q % 250 && (d(), c.moveTo(k, C), s && F.moveTo(k, C), l.push({ x: k, y: x - ra }))); t = { x: k, y: C }; q < B.length - 1 && (P !== (B[q].lineColor || D) || n !==
                                (B[q].lineDashType || E.lineDashType)) && (d(), c.beginPath(), c.moveTo(k, C), l.push({ x: k, y: x - ra }), P = B[q].lineColor || D, c.strokeStyle = P, c.setLineDash && (B[q].lineDashType ? (n = B[q].lineDashType, c.setLineDash(R(n, E.lineThickness))) : (n = E.lineDashType, c.setLineDash(ea)))); if (0 <= E.dataPointIndexes[g]) { var da = E.dataPointIds[E.dataPointIndexes[g]]; this._eventManager.objectMap[da] = { id: da, objectType: "dataPoint", dataSeriesIndex: y, dataPointIndex: E.dataPointIndexes[g], x1: k, y1: C } } 0 <= E.dataPointIndexes[g] && 0 !== ia.markerSize &&
                                  (0 < ia.markerSize || 0 < E.markerSize) && (ra = E.getMarkerProperties(E.dataPointIndexes[g], k, C, c), h.push(ra), g = Q(da), s && h.push({ x: k, y: C, ctx: F, type: ra.type, size: ra.size, color: g, borderColor: g, borderThickness: ra.borderThickness })); (ia.indexLabel || E.indexLabel || ia.indexLabelFormatter || E.indexLabelFormatter) && this._indexLabels.push({ chartType: "stackedArea", dataPoint: ia, dataSeries: E, point: { x: k, y: C }, direction: 0 > B[q].y === a.axisY.reversed ? 1 : -1, color: e })
                          }
                      } d(); c.moveTo(k, C); s && F.moveTo(k, C)
                    } delete E.dataPointIndexes
                  } z.drawMarkers(h);
                s && (b.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(f.x1, f.y1, f.width, f.height), F.restore()); c.restore(); return {
                  source: b, dest: this.plotArea.ctx, animationCallback: v.xClipAnimation,
                  easingFunction: v.easing.linear, animationBase: 0
                }
              }
            }; n.prototype.renderStackedArea100 = function (a) {
              function d() { for (0 < E.lineThickness && c.stroke(); 0 < l.length;) { var a = l.pop(); c.lineTo(a.x, a.y); s && n.lineTo(a.x, a.y) } c.closePath(); c.globalAlpha = E.fillOpacity; c.fill(); c.globalAlpha = 1; c.beginPath(); s && (n.closePath(), n.fill(), n.beginPath()); l = [] } var b = a.targetCanvasCtx || this.plotArea.ctx, c = s ? this._preRenderCtx : b; if (!(0 >= a.dataSeriesIndexes.length)) {
                var e = null, g = null, h = this.plotArea, f = [], m = [], l = [], r = [], p = [], q =
                  0, k, C, x, F, t, L = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), n = this._eventManager.ghostCtx; c.save(); s && n.save(); c.beginPath(); c.rect(h.x1, h.y1, h.width, h.height); c.clip(); s && (n.beginPath(), n.rect(h.x1, h.y1, h.width, h.height), n.clip()); for (var e = [], w = 0; w < a.dataSeriesIndexes.length; w++) {
                    var y = a.dataSeriesIndexes[w], E = this.data[y], B = E.dataPoints; E.dataPointIndexes = []; for (q = 0; q < B.length; q++)y = B[q].x.getTime ? B[q].x.getTime() : B[q].x, E.dataPointIndexes[y] = q, e[y] || (r.push(y), e[y] =
                      !0); r.sort(Xa)
                  } for (w = 0; w < a.dataSeriesIndexes.length; w++) {
                    y = a.dataSeriesIndexes[w]; E = this.data[y]; B = E.dataPoints; F = !0; e = E.id; this._eventManager.objectMap[e] = { objectType: "dataSeries", dataSeriesIndex: y }; e = Q(e); n.fillStyle = e; l = []; if (0 < r.length) {
                      var e = E._colorSet[q % E._colorSet.length], D = E.lineColor = E.options.lineColor || e, P = D; c.fillStyle = e; c.strokeStyle = D; c.lineWidth = E.lineThickness; t = "solid"; if (c.setLineDash) {
                        var ca = R(E.nullDataLineDashType, E.lineThickness); t = E.lineDashType; var ea = R(t, E.lineThickness);
                        c.setLineDash(ea)
                      } for (var $ = !0, q = 0; q < r.length; q++) {
                        var g = r[q], ia = null, ia = 0 <= E.dataPointIndexes[g] ? B[E.dataPointIndexes[g]] : { x: g, y: null }; if (!(g < a.axisX.dataInfo.viewPortMin || g > a.axisX.dataInfo.viewPortMax && (!E.connectNullData || !$))) if ("number" !== typeof ia.y) E.connectNullData || ($ || F) || d(), $ = !0; else {
                          var ra; ra = 0 !== a.dataPointYSums[g] ? 100 * (ia.y / a.dataPointYSums[g]) : 0; k = a.axisX.convertValueToPixel(g); var da = m[g] ? m[g] : 0; if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length) {
                            p[g] =
                              ra + (p[g] ? p[g] : 0); if (0 >= p[g] && a.axisY.logarithmic) continue; C = a.axisY.convertValueToPixel(p[g])
                          } else C = a.axisY.convertValueToPixel(ra), C -= da; l.push({ x: k, y: L - da }); m[g] = L - C; F || $ ? (!F && E.connectNullData ? (c.setLineDash && (E.options.nullDataLineDashType || t === E.lineDashType && E.lineDashType !== E.nullDataLineDashType) && (F = l.pop(), t = l[l.length - 1], d(), c.moveTo(x.x, x.y), l.push(t), l.push(F), t = E.nullDataLineDashType, c.setLineDash(ca)), c.lineTo(k, C), s && n.lineTo(k, C)) : (c.beginPath(), c.moveTo(k, C), s && (n.beginPath(), n.moveTo(k,
                            C))), $ = F = !1) : (c.lineTo(k, C), s && n.lineTo(k, C), 0 == q % 250 && (d(), c.moveTo(k, C), s && n.moveTo(k, C), l.push({ x: k, y: L - da }))); x = { x: k, y: C }; q < B.length - 1 && (P !== (B[q].lineColor || D) || t !== (B[q].lineDashType || E.lineDashType)) && (d(), c.beginPath(), c.moveTo(k, C), l.push({ x: k, y: L - da }), P = B[q].lineColor || D, c.strokeStyle = P, c.setLineDash && (B[q].lineDashType ? (t = B[q].lineDashType, c.setLineDash(R(t, E.lineThickness))) : (t = E.lineDashType, c.setLineDash(ea)))); if (0 <= E.dataPointIndexes[g]) {
                              var I = E.dataPointIds[E.dataPointIndexes[g]];
                              this._eventManager.objectMap[I] = { id: I, objectType: "dataPoint", dataSeriesIndex: y, dataPointIndex: E.dataPointIndexes[g], x1: k, y1: C }
                            } 0 <= E.dataPointIndexes[g] && 0 !== ia.markerSize && (0 < ia.markerSize || 0 < E.markerSize) && (da = E.getMarkerProperties(q, k, C, c), f.push(da), g = Q(I), s && f.push({ x: k, y: C, ctx: n, type: da.type, size: da.size, color: g, borderColor: g, borderThickness: da.borderThickness })); (ia.indexLabel || E.indexLabel || ia.indexLabelFormatter || E.indexLabelFormatter) && this._indexLabels.push({
                              chartType: "stackedArea100", dataPoint: ia,
                              dataSeries: E, point: { x: k, y: C }, direction: 0 > B[q].y === a.axisY.reversed ? 1 : -1, color: e
                            })
                        }
                      } d(); c.moveTo(k, C); s && n.moveTo(k, C)
                    } delete E.dataPointIndexes
                  } z.drawMarkers(f); s && (b.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas,
                    0, 0, this.width, this.height), c.clearRect(h.x1, h.y1, h.width, h.height), n.restore()); c.restore(); return { source: b, dest: this.plotArea.ctx, animationCallback: v.xClipAnimation, easingFunction: v.easing.linear, animationBase: 0 }
              }
            }; n.prototype.renderBubble = function (a) {
              var d = a.targetCanvasCtx || this.plotArea.ctx, b = s ? this._preRenderCtx : d; if (!(0 >= a.dataSeriesIndexes.length)) {
                var c = this.plotArea, e = 0, g, h; b.save(); s && this._eventManager.ghostCtx.save(); b.beginPath(); b.rect(c.x1, c.y1, c.width, c.height); b.clip(); s && (this._eventManager.ghostCtx.beginPath(),
                  this._eventManager.ghostCtx.rect(c.x1, c.y1, c.width, c.height), this._eventManager.ghostCtx.clip()); for (var f = -Infinity, m = Infinity, l = 0; l < a.dataSeriesIndexes.length; l++)for (var r = a.dataSeriesIndexes[l], p = this.data[r], q = p.dataPoints, k = 0, e = 0; e < q.length; e++)g = q[e].getTime ? g = q[e].x.getTime() : g = q[e].x, g < a.axisX.dataInfo.viewPortMin || g > a.axisX.dataInfo.viewPortMax || "undefined" === typeof q[e].z || (k = q[e].z, k > f && (f = k), k < m && (m = k)); for (var C = 25 * Math.PI, x = Math.max(Math.pow(0.25 * Math.min(c.height, c.width) / 2, 2) * Math.PI,
                    C), l = 0; l < a.dataSeriesIndexes.length; l++)if (r = a.dataSeriesIndexes[l], p = this.data[r], q = p.dataPoints, 0 < q.length) for (b.strokeStyle = "#4572A7 ", e = 0; e < q.length; e++)if (g = q[e].getTime ? g = q[e].x.getTime() : g = q[e].x, !(g < a.axisX.dataInfo.viewPortMin || g > a.axisX.dataInfo.viewPortMax) && "number" === typeof q[e].y) {
                      g = a.axisX.convertValueToPixel(g); h = a.axisY.convertValueToPixel(q[e].y); var k = q[e].z, F = 2 * Math.max(Math.sqrt((f === m ? x / 2 : C + (x - C) / (f - m) * (k - m)) / Math.PI) << 0, 1), k = p.getMarkerProperties(e, b); k.size = F; b.globalAlpha =
                        p.fillOpacity; z.drawMarker(g, h, b, k.type, k.size, k.color, k.borderColor, k.borderThickness); b.globalAlpha = 1; var t = p.dataPointIds[e]; this._eventManager.objectMap[t] = { id: t, objectType: "dataPoint", dataSeriesIndex: r, dataPointIndex: e, x1: g, y1: h, size: F }; F = Q(t); s && z.drawMarker(g, h, this._eventManager.ghostCtx, k.type, k.size, F, F, k.borderThickness); (q[e].indexLabel || p.indexLabel || q[e].indexLabelFormatter || p.indexLabelFormatter) && this._indexLabels.push({
                          chartType: "bubble", dataPoint: q[e], dataSeries: p, point: { x: g, y: h },
                          direction: 1, bounds: { x1: g - k.size / 2, y1: h - k.size / 2, x2: g + k.size / 2, y2: h + k.size / 2 }, color: null
                        })
                    } s && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(c.x1, c.y1, c.width, c.height), this._eventManager.ghostCtx.restore());
                b.restore(); return { source: d, dest: this.plotArea.ctx, animationCallback: v.fadeInAnimation, easingFunction: v.easing.easeInQuad, animationBase: 0 }
              }
            }; n.prototype.renderScatter = function (a) {
              var d = a.targetCanvasCtx || this.plotArea.ctx, b = s ? this._preRenderCtx : d; if (!(0 >= a.dataSeriesIndexes.length)) {
                var c = this.plotArea, e = 0, g, h; b.save(); s && this._eventManager.ghostCtx.save(); b.beginPath(); b.rect(c.x1, c.y1, c.width, c.height); b.clip(); s && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(c.x1, c.y1,
                  c.width, c.height), this._eventManager.ghostCtx.clip()); for (var f = 0; f < a.dataSeriesIndexes.length; f++) {
                    var m = a.dataSeriesIndexes[f], l = this.data[m], r = l.dataPoints; if (0 < r.length) {
                      b.strokeStyle = "#4572A7 "; Math.pow(0.3 * Math.min(c.height, c.width) / 2, 2); for (var p = 0, q = 0, e = 0; e < r.length; e++)if (g = r[e].getTime ? g = r[e].x.getTime() : g = r[e].x, !(g < a.axisX.dataInfo.viewPortMin || g > a.axisX.dataInfo.viewPortMax) && "number" === typeof r[e].y) {
                        g = a.axisX.convertValueToPixel(g); h = a.axisY.convertValueToPixel(r[e].y); var k = l.getMarkerProperties(e,
                          g, h, b); b.globalAlpha = l.fillOpacity; z.drawMarker(k.x, k.y, k.ctx, k.type, k.size, k.color, k.borderColor, k.borderThickness); b.globalAlpha = 1; Math.sqrt((p - g) * (p - g) + (q - h) * (q - h)) < Math.min(k.size, 5) && r.length > Math.min(this.plotArea.width, this.plotArea.height) || (p = l.dataPointIds[e], this._eventManager.objectMap[p] = { id: p, objectType: "dataPoint", dataSeriesIndex: m, dataPointIndex: e, x1: g, y1: h }, p = Q(p), s && z.drawMarker(k.x, k.y, this._eventManager.ghostCtx, k.type, k.size, p, p, k.borderThickness), (r[e].indexLabel || l.indexLabel ||
                            r[e].indexLabelFormatter || l.indexLabelFormatter) && this._indexLabels.push({ chartType: "scatter", dataPoint: r[e], dataSeries: l, point: { x: g, y: h }, direction: 1, bounds: { x1: g - k.size / 2, y1: h - k.size / 2, x2: g + k.size / 2, y2: h + k.size / 2 }, color: null }), p = g, q = h)
                      }
                    }
                  } s && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height),
                    this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(c.x1, c.y1, c.width, c.height), this._eventManager.ghostCtx.restore()); b.restore(); return { source: d, dest: this.plotArea.ctx, animationCallback: v.fadeInAnimation, easingFunction: v.easing.easeInQuad, animationBase: 0 }
              }
            }; n.prototype.renderCandlestick = function (a) {
              var d = a.targetCanvasCtx || this.plotArea.ctx, b = s ? this._preRenderCtx : d, c = this._eventManager.ghostCtx; if (!(0 >= a.dataSeriesIndexes.length)) {
                var e =
                  null, g = null, f = this.plotArea, u = 0, m, l, r, p, q, k, e = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, g = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.015 * this.width, C = a.axisX.dataInfo.minDiff; isFinite(C) || (C = 0.3 * Math.abs(a.axisX.range)); C = this.options.dataPointWidth ? this.dataPointWidth : 0.7 * f.width * (a.axisX.logarithmic ? Math.log(C) / Math.log(a.axisX.range) : Math.abs(C) / Math.abs(a.axisX.range)) << 0;
                this.dataPointMaxWidth && e > g && (e = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, g)); !this.dataPointMaxWidth && (this.dataPointMinWidth && g < e) && (g = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, e)); C < e && (C = e); C > g && (C = g); b.save(); s && c.save(); b.beginPath(); b.rect(f.x1, f.y1, f.width, f.height); b.clip(); s && (c.beginPath(), c.rect(f.x1, f.y1, f.width, f.height), c.clip()); for (var x = 0; x < a.dataSeriesIndexes.length; x++) {
                  var F = a.dataSeriesIndexes[x], t = this.data[F], z = t.dataPoints;
                  if (0 < z.length) for (var n = 5 < C && t.bevelEnabled ? !0 : !1, u = 0; u < z.length; u++)if (z[u].getTime ? k = z[u].x.getTime() : k = z[u].x, !(k < a.axisX.dataInfo.viewPortMin || k > a.axisX.dataInfo.viewPortMax) && !h(z[u].y) && z[u].y.length && "number" === typeof z[u].y[0] && "number" === typeof z[u].y[1] && "number" === typeof z[u].y[2] && "number" === typeof z[u].y[3]) {
                    m = a.axisX.convertValueToPixel(k); l = a.axisY.convertValueToPixel(z[u].y[0]); r = a.axisY.convertValueToPixel(z[u].y[1]); p = a.axisY.convertValueToPixel(z[u].y[2]); q = a.axisY.convertValueToPixel(z[u].y[3]);
                    var w = m - C / 2 << 0, y = w + C << 0, g = t.options.fallingColor ? t.fallingColor : t._colorSet[0], e = z[u].color ? z[u].color : t._colorSet[0], E = Math.round(Math.max(1, 0.15 * C)), B = 0 === E % 2 ? 0 : 0.5, D = t.dataPointIds[u]; this._eventManager.objectMap[D] = { id: D, objectType: "dataPoint", dataSeriesIndex: F, dataPointIndex: u, x1: w, y1: l, x2: y, y2: r, x3: m, y3: p, x4: m, y4: q, borderThickness: E, color: e }; b.strokeStyle = e; b.beginPath(); b.lineWidth = E; c.lineWidth = Math.max(E, 4); "candlestick" === t.type ? (b.moveTo(m - B, r), b.lineTo(m - B, Math.min(l, q)), b.stroke(), b.moveTo(m -
                      B, Math.max(l, q)), b.lineTo(m - B, p), b.stroke(), X(b, w, Math.min(l, q), y, Math.max(l, q), z[u].y[0] <= z[u].y[3] ? t.risingColor : g, E, e, n, n, !1, !1, t.fillOpacity), s && (e = Q(D), c.strokeStyle = e, c.moveTo(m - B, r), c.lineTo(m - B, Math.min(l, q)), c.stroke(), c.moveTo(m - B, Math.max(l, q)), c.lineTo(m - B, p), c.stroke(), X(c, w, Math.min(l, q), y, Math.max(l, q), e, 0, null, !1, !1, !1, !1))) : "ohlc" === t.type && (b.moveTo(m - B, r), b.lineTo(m - B, p), b.stroke(), b.beginPath(), b.moveTo(m, l), b.lineTo(w, l), b.stroke(), b.beginPath(), b.moveTo(m, q), b.lineTo(y, q), b.stroke(),
                        s && (e = Q(D), c.strokeStyle = e, c.moveTo(m - B, r), c.lineTo(m - B, p), c.stroke(), c.beginPath(), c.moveTo(m, l), c.lineTo(w, l), c.stroke(), c.beginPath(), c.moveTo(m, q), c.lineTo(y, q), c.stroke())); (z[u].indexLabel || t.indexLabel || z[u].indexLabelFormatter || t.indexLabelFormatter) && this._indexLabels.push({ chartType: t.type, dataPoint: z[u], dataSeries: t, point: { x: w + (y - w) / 2, y: a.axisY.reversed ? p : r }, direction: 1, bounds: { x1: w, y1: Math.min(r, p), x2: y, y2: Math.max(r, p) }, color: e })
                  }
                } s && (d.drawImage(this._preRenderCanvas, 0, 0, this.width,
                  this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(f.x1, f.y1, f.width, f.height), c.restore()); b.restore(); return { source: d, dest: this.plotArea.ctx, animationCallback: v.fadeInAnimation, easingFunction: v.easing.easeInQuad, animationBase: 0 }
              }
            };
        n.prototype.renderBoxAndWhisker = function (a) {
          var d = a.targetCanvasCtx || this.plotArea.ctx, b = s ? this._preRenderCtx : d, c = this._eventManager.ghostCtx; if (!(0 >= a.dataSeriesIndexes.length)) {
            var e = null, g = this.plotArea, f = 0, u, m, l, r, p, q, k, e = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, f = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.015 * this.width, C = a.axisX.dataInfo.minDiff; isFinite(C) || (C = 0.3 * Math.abs(a.axisX.range));
            C = this.options.dataPointWidth ? this.dataPointWidth : 0.7 * g.width * (a.axisX.logarithmic ? Math.log(C) / Math.log(a.axisX.range) : Math.abs(C) / Math.abs(a.axisX.range)) << 0; this.dataPointMaxWidth && e > f && (e = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, f)); !this.dataPointMaxWidth && (this.dataPointMinWidth && f < e) && (f = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, e)); C < e && (C = e); C > f && (C = f); b.save(); s && c.save(); b.beginPath(); b.rect(g.x1, g.y1, g.width, g.height); b.clip(); s && (c.beginPath(),
              c.rect(g.x1, g.y1, g.width, g.height), c.clip()); for (var x = !1, x = !!a.axisY.reversed, F = 0; F < a.dataSeriesIndexes.length; F++) {
                var t = a.dataSeriesIndexes[F], z = this.data[t], n = z.dataPoints; if (0 < n.length) for (var w = 5 < C && z.bevelEnabled ? !0 : !1, f = 0; f < n.length; f++)if (n[f].getTime ? k = n[f].x.getTime() : k = n[f].x, !(k < a.axisX.dataInfo.viewPortMin || k > a.axisX.dataInfo.viewPortMax) && !h(n[f].y) && n[f].y.length && "number" === typeof n[f].y[0] && "number" === typeof n[f].y[1] && "number" === typeof n[f].y[2] && "number" === typeof n[f].y[3] && "number" ===
                  typeof n[f].y[4] && 5 === n[f].y.length) {
                  u = a.axisX.convertValueToPixel(k); m = a.axisY.convertValueToPixel(n[f].y[0]); l = a.axisY.convertValueToPixel(n[f].y[1]); r = a.axisY.convertValueToPixel(n[f].y[2]); p = a.axisY.convertValueToPixel(n[f].y[3]); q = a.axisY.convertValueToPixel(n[f].y[4]); var y = u - C / 2 << 0, E = u + C / 2 << 0, e = n[f].color ? n[f].color : z._colorSet[0], B = Math.round(Math.max(1, 0.15 * C)), D = 0 === B % 2 ? 0 : 0.5, P = n[f].whiskerColor ? n[f].whiskerColor : n[f].color ? z.whiskerColor ? z.whiskerColor : n[f].color : z.whiskerColor ? z.whiskerColor :
                    e, ca = "number" === typeof n[f].whiskerThickness ? n[f].whiskerThickness : "number" === typeof z.options.whiskerThickness ? z.whiskerThickness : B, ea = n[f].whiskerDashType ? n[f].whiskerDashType : z.whiskerDashType, $ = h(n[f].whiskerLength) ? h(z.options.whiskerLength) ? C : z.whiskerLength : n[f].whiskerLength, $ = "number" === typeof $ ? 0 >= $ ? 0 : $ >= C ? C : $ : "string" === typeof $ ? parseInt($) * C / 100 > C ? C : parseInt($) * C / 100 : C, ia = 1 === Math.round(ca) % 2 ? 0.5 : 0, ra = n[f].stemColor ? n[f].stemColor : n[f].color ? z.stemColor ? z.stemColor : n[f].color : z.stemColor ?
                      z.stemColor : e, da = "number" === typeof n[f].stemThickness ? n[f].stemThickness : "number" === typeof z.options.stemThickness ? z.stemThickness : B, I = 1 === Math.round(da) % 2 ? 0.5 : 0, H = n[f].stemDashType ? n[f].stemDashType : z.stemDashType, G = n[f].lineColor ? n[f].lineColor : n[f].color ? z.lineColor ? z.lineColor : n[f].color : z.lineColor ? z.lineColor : e, K = "number" === typeof n[f].lineThickness ? n[f].lineThickness : "number" === typeof z.options.lineThickness ? z.lineThickness : B, M = n[f].lineDashType ? n[f].lineDashType : z.lineDashType, O = 1 === Math.round(K) %
                        2 ? 0.5 : 0, N = z.upperBoxColor, aa = z.lowerBoxColor, xa = h(z.options.fillOpacity) ? 1 : z.fillOpacity, S = z.dataPointIds[f]; this._eventManager.objectMap[S] = { id: S, objectType: "dataPoint", dataSeriesIndex: t, dataPointIndex: f, x1: y, y1: m, x2: E, y2: l, x3: u, y3: r, x4: u, y4: p, y5: q, borderThickness: B, color: e, stemThickness: da, stemColor: ra, whiskerThickness: ca, whiskerLength: $, whiskerColor: P, lineThickness: K, lineColor: G }; b.save(); 0 < da && (b.beginPath(), b.strokeStyle = ra, b.lineWidth = da, b.setLineDash && b.setLineDash(R(H, da)), b.moveTo(u - I, l),
                          b.lineTo(u - I, m), b.stroke(), b.moveTo(u - I, p), b.lineTo(u - I, r), b.stroke()); b.restore(); c.lineWidth = Math.max(B, 4); b.beginPath(); X(b, y, Math.min(q, l), E, Math.max(l, q), aa, 0, e, x ? w : !1, x ? !1 : w, !1, !1, xa); b.beginPath(); X(b, y, Math.min(r, q), E, Math.max(q, r), N, 0, e, x ? !1 : w, x ? w : !1, !1, !1, xa); b.beginPath(); b.lineWidth = B; b.strokeStyle = e; b.rect(y - D, Math.min(l, r) - D, E - y + 2 * D, Math.max(l, r) - Math.min(l, r) + 2 * D); b.stroke(); b.save(); 0 < K && (b.beginPath(), b.globalAlpha = 1, b.setLineDash && b.setLineDash(R(M, K)), b.strokeStyle = G, b.lineWidth =
                            K, b.moveTo(y, q - O), b.lineTo(E, q - O), b.stroke()); b.restore(); b.save(); 0 < ca && (b.beginPath(), b.setLineDash && b.setLineDash(R(ea, ca)), b.strokeStyle = P, b.lineWidth = ca, b.moveTo(u - $ / 2 << 0, p - ia), b.lineTo(u + $ / 2 << 0, p - ia), b.stroke(), b.moveTo(u - $ / 2 << 0, m + ia), b.lineTo(u + $ / 2 << 0, m + ia), b.stroke()); b.restore(); s && (e = Q(S), c.strokeStyle = e, c.lineWidth = da, 0 < da && (c.moveTo(u - D - I, l), c.lineTo(u - D - I, Math.max(m, p)), c.stroke(), c.moveTo(u - D - I, Math.min(m, p)), c.lineTo(u - D - I, r), c.stroke()), X(c, y, Math.max(l, r), E, Math.min(l, r), e, 0, null,
                              !1, !1, !1, !1), 0 < ca && (c.beginPath(), c.lineWidth = ca, c.moveTo(u + $ / 2, p - ia), c.lineTo(u - $ / 2, p - ia), c.stroke(), c.moveTo(u + $ / 2, m + ia), c.lineTo(u - $ / 2, m + ia), c.stroke())); (n[f].indexLabel || z.indexLabel || n[f].indexLabelFormatter || z.indexLabelFormatter) && this._indexLabels.push({ chartType: z.type, dataPoint: n[f], dataSeries: z, point: { x: y + (E - y) / 2, y: a.axisY.reversed ? m : p }, direction: 1, bounds: { x1: y, y1: Math.min(m, p), x2: E, y2: Math.max(m, p) }, color: e })
                }
              } s && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation =
                "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(g.x1, g.y1, g.width, g.height), c.restore()); b.restore(); return { source: d, dest: this.plotArea.ctx, animationCallback: v.fadeInAnimation, easingFunction: v.easing.easeInQuad, animationBase: 0 }
          }
        }; n.prototype.renderRangeColumn =
          function (a) {
            var d = a.targetCanvasCtx || this.plotArea.ctx, b = s ? this._preRenderCtx : d; if (!(0 >= a.dataSeriesIndexes.length)) {
              var c = null, e = this.plotArea, g = 0, f, u, m, g = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1; f = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.03 * this.width; var l = a.axisX.dataInfo.minDiff; isFinite(l) || (l = 0.3 * Math.abs(a.axisX.range)); l = this.options.dataPointWidth ? this.dataPointWidth :
                0.9 * (e.width * (a.axisX.logarithmic ? Math.log(l) / Math.log(a.axisX.range) : Math.abs(l) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0; this.dataPointMaxWidth && g > f && (g = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, f)); !this.dataPointMaxWidth && (this.dataPointMinWidth && f < g) && (f = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, g)); l < g && (l = g); l > f && (l = f); b.save(); s && this._eventManager.ghostCtx.save(); b.beginPath(); b.rect(e.x1, e.y1, e.width, e.height); b.clip(); s && (this._eventManager.ghostCtx.beginPath(),
                  this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip()); for (var r = 0; r < a.dataSeriesIndexes.length; r++) {
                    var p = a.dataSeriesIndexes[r], q = this.data[p], k = q.dataPoints; if (0 < k.length) for (var C = 5 < l && q.bevelEnabled ? !0 : !1, g = 0; g < k.length; g++)if (k[g].getTime ? m = k[g].x.getTime() : m = k[g].x, !(m < a.axisX.dataInfo.viewPortMin || m > a.axisX.dataInfo.viewPortMax) && !h(k[g].y) && k[g].y.length && "number" === typeof k[g].y[0] && "number" === typeof k[g].y[1]) {
                      c = a.axisX.convertValueToPixel(m); f =
                        a.axisY.convertValueToPixel(k[g].y[0]); u = a.axisY.convertValueToPixel(k[g].y[1]); var x = a.axisX.reversed ? c + a.plotType.totalDataSeries * l / 2 - (a.previousDataSeriesCount + r) * l << 0 : c - a.plotType.totalDataSeries * l / 2 + (a.previousDataSeriesCount + r) * l << 0, z = a.axisX.reversed ? x - l << 0 : x + l << 0, c = k[g].color ? k[g].color : q._colorSet[g % q._colorSet.length]; if (f > u) { var t = f; f = u; u = t } t = q.dataPointIds[g]; this._eventManager.objectMap[t] = { id: t, objectType: "dataPoint", dataSeriesIndex: p, dataPointIndex: g, x1: x, y1: f, x2: z, y2: u }; X(b, x, f, z,
                          u, c, 0, c, C, C, !1, !1, q.fillOpacity); c = Q(t); s && X(this._eventManager.ghostCtx, x, f, z, u, c, 0, null, !1, !1, !1, !1); if (k[g].indexLabel || q.indexLabel || k[g].indexLabelFormatter || q.indexLabelFormatter) this._indexLabels.push({ chartType: "rangeColumn", dataPoint: k[g], dataSeries: q, indexKeyword: 0, point: { x: x + (z - x) / 2, y: k[g].y[1] >= k[g].y[0] ? u : f }, direction: k[g].y[1] >= k[g].y[0] ? -1 : 1, bounds: { x1: x, y1: Math.min(f, u), x2: z, y2: Math.max(f, u) }, color: c }), this._indexLabels.push({
                            chartType: "rangeColumn", dataPoint: k[g], dataSeries: q, indexKeyword: 1,
                            point: { x: x + (z - x) / 2, y: k[g].y[1] >= k[g].y[0] ? f : u }, direction: k[g].y[1] >= k[g].y[0] ? 1 : -1, bounds: { x1: x, y1: Math.min(f, u), x2: z, y2: Math.max(f, u) }, color: c
                          })
                    }
                  } s && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width,
                    this.height), b.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore()); b.restore(); return { source: d, dest: this.plotArea.ctx, animationCallback: v.fadeInAnimation, easingFunction: v.easing.easeInQuad, animationBase: 0 }
            }
          }; n.prototype.renderError = function (a) {
            var d = a.targetCanvasCtx || this.plotArea.ctx, b = s ? this._preRenderCtx : d, c = a.axisY._position ? "left" === a.axisY._position || "right" === a.axisY._position ? !1 : !0 : !1; if (!(0 >= a.dataSeriesIndexes.length)) {
              var e = null, g = !1, f = this.plotArea, u = 0, m, l, r,
                p, q, k, C, x = a.axisX.dataInfo.minDiff; isFinite(x) || (x = 0.3 * Math.abs(a.axisX.range)); b.save(); s && this._eventManager.ghostCtx.save(); b.beginPath(); b.rect(f.x1, f.y1, f.width, f.height); b.clip(); s && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(f.x1, f.y1, f.width, f.height), this._eventManager.ghostCtx.clip()); for (var z = 0, t = 0; t < this.data.length; t++)!this.data[t].type.match(/(bar|column)/ig) || !this.data[t].visible || this.data[t].type.match(/(stacked)/ig) && z || z++; for (var n = 0; n < a.dataSeriesIndexes.length; n++) {
                  var w =
                    a.dataSeriesIndexes[n], y = this.data[w], B = y.dataPoints, E = h(y._linkedSeries) ? !1 : y._linkedSeries.type.match(/(bar|column)/ig) && y._linkedSeries.visible ? !0 : !1, H = 0; if (E) for (e = y._linkedSeries.id, t = 0; t < e; t++)!this.data[t].type.match(/(bar|column)/ig) || !this.data[t].visible || this.data[t].type.match(/(stacked)/ig) && H || (this.data[t].type.match(/(range)/ig) && (g = !0), H++); e = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1; u = this.options.dataPointMaxWidth ? this.dataPointMaxWidth :
                      this.options.dataPointWidth ? this.dataPointWidth : c ? Math.min(0.15 * this.height, 0.9 * (this.plotArea.height / (E ? z : 1))) << 0 : 0.3 * this.width; g && (u = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : c ? Math.min(0.15 * this.height, 0.9 * (this.plotArea.height / (E ? z : 1))) << 0 : 0.03 * this.width); t = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * ((c ? f.height : f.width) * (a.axisX.logarithmic ? Math.log(x) / Math.log(a.axisX.range) : Math.abs(x) / Math.abs(a.axisX.range)) / (E ? z : 1)) <<
                        0; this.dataPointMaxWidth && e > u && (e = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, u)); !this.dataPointMaxWidth && (this.dataPointMinWidth && u < e) && (u = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, e)); t < e && (t = e); t > u && (t = u); if (0 < B.length) for (var G = y._colorSet, u = 0; u < B.length; u++) {
                          var e = y.lineColor = y.options.color ? y.options.color : G[0], P = {
                            color: B[u].whiskerColor ? B[u].whiskerColor : B[u].color ? y.whiskerColor ? y.whiskerColor : B[u].color : y.whiskerColor ? y.whiskerColor : e, thickness: h(B[u].whiskerThickness) ?
                              y.whiskerThickness : B[u].whiskerThickness, dashType: B[u].whiskerDashType ? B[u].whiskerDashType : y.whiskerDashType, length: h(B[u].whiskerLength) ? h(y.options.whiskerLength) ? t : y.options.whiskerLength : B[u].whiskerLength, trimLength: h(B[u].whiskerLength) ? h(y.options.whiskerLength) ? 50 : 0 : 0
                          }; P.length = "number" === typeof P.length ? 0 >= P.length ? 0 : P.length >= t ? t : P.length : "string" === typeof P.length ? parseInt(P.length) * t / 100 > t ? t : parseInt(P.length) * t / 100 > t : t; P.thickness = "number" === typeof P.thickness ? 0 > P.thickness ? 0 : Math.round(P.thickness) :
                            2; var ca = { color: B[u].stemColor ? B[u].stemColor : B[u].color ? y.stemColor ? y.stemColor : B[u].color : y.stemColor ? y.stemColor : e, thickness: B[u].stemThickness ? B[u].stemThickness : y.stemThickness, dashType: B[u].stemDashType ? B[u].stemDashType : y.stemDashType }; ca.thickness = "number" === typeof ca.thickness ? 0 > ca.thickness ? 0 : Math.round(ca.thickness) : 2; B[u].getTime ? C = B[u].x.getTime() : C = B[u].x; if (!(C < a.axisX.dataInfo.viewPortMin || C > a.axisX.dataInfo.viewPortMax) && !h(B[u].y) && B[u].y.length && "number" === typeof B[u].y[0] && "number" ===
                              typeof B[u].y[1]) {
                            var ea = a.axisX.convertValueToPixel(C); c ? l = ea : m = ea; ea = a.axisY.convertValueToPixel(B[u].y[0]); c ? r = ea : q = ea; ea = a.axisY.convertValueToPixel(B[u].y[1]); c ? p = ea : k = ea; c ? (q = a.axisX.reversed ? l + (E ? z : 1) * t / 2 - (E ? H - 1 : 0) * t << 0 : l - (E ? z : 1) * t / 2 + (E ? H - 1 : 0) * t << 0, k = a.axisX.reversed ? q - t << 0 : q + t << 0) : (r = a.axisX.reversed ? m + (E ? z : 1) * t / 2 - (E ? H - 1 : 0) * t << 0 : m - (E ? z : 1) * t / 2 + (E ? H - 1 : 0) * t << 0, p = a.axisX.reversed ? r - t << 0 : r + t << 0); !c && q > k && (ea = q, q = k, k = ea); c && r > p && (ea = r, r = p, p = ea); ea = y.dataPointIds[u]; this._eventManager.objectMap[ea] =
                              { id: ea, objectType: "dataPoint", dataSeriesIndex: w, dataPointIndex: u, x1: Math.min(r, p), y1: Math.min(q, k), x2: Math.max(p, r), y2: Math.max(k, q), isXYSwapped: c, stemProperties: ca, whiskerProperties: P }; D(b, Math.min(r, p), Math.min(q, k), Math.max(p, r), Math.max(k, q), e, P, ca, c); s && D(this._eventManager.ghostCtx, r, q, p, k, e, P, ca, c); if (B[u].indexLabel || y.indexLabel || B[u].indexLabelFormatter || y.indexLabelFormatter) this._indexLabels.push({
                                chartType: "error", dataPoint: B[u], dataSeries: y, indexKeyword: 0, point: {
                                  x: c ? B[u].y[1] >= B[u].y[0] ?
                                    r : p : r + (p - r) / 2, y: c ? q + (k - q) / 2 : B[u].y[1] >= B[u].y[0] ? k : q
                                }, direction: B[u].y[1] >= B[u].y[0] ? -1 : 1, bounds: { x1: c ? Math.min(r, p) : r, y1: c ? q : Math.min(q, k), x2: c ? Math.max(r, p) : p, y2: c ? k : Math.max(q, k) }, color: e, axisSwapped: c
                              }), this._indexLabels.push({
                                chartType: "error", dataPoint: B[u], dataSeries: y, indexKeyword: 1, point: { x: c ? B[u].y[1] >= B[u].y[0] ? p : r : r + (p - r) / 2, y: c ? q + (k - q) / 2 : B[u].y[1] >= B[u].y[0] ? q : k }, direction: B[u].y[1] >= B[u].y[0] ? 1 : -1, bounds: {
                                  x1: c ? Math.min(r, p) : r, y1: c ? q : Math.min(q, k), x2: c ? Math.max(r, p) : p, y2: c ? k : Math.max(q,
                                    k)
                                }, color: e, axisSwapped: c
                              })
                          }
                        }
                } s && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(f.x1, f.y1, f.width, f.height), this._eventManager.ghostCtx.restore()); b.restore(); return {
                  source: d,
                  dest: this.plotArea.ctx, animationCallback: v.fadeInAnimation, easingFunction: v.easing.easeInQuad, animationBase: 0
                }
            }
          }; n.prototype.renderRangeBar = function (a) {
            var d = a.targetCanvasCtx || this.plotArea.ctx, b = s ? this._preRenderCtx : d; if (!(0 >= a.dataSeriesIndexes.length)) {
              var c = null, e = this.plotArea, g = 0, f, u, m, l, g = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1; f = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth :
                Math.min(0.15 * this.height, 0.9 * (this.plotArea.height / a.plotType.totalDataSeries)) << 0; var r = a.axisX.dataInfo.minDiff; isFinite(r) || (r = 0.3 * Math.abs(a.axisX.range)); r = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (e.height * (a.axisX.logarithmic ? Math.log(r) / Math.log(a.axisX.range) : Math.abs(r) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0; this.dataPointMaxWidth && g > f && (g = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, f)); !this.dataPointMaxWidth && (this.dataPointMinWidth &&
                  f < g) && (f = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, g)); r < g && (r = g); r > f && (r = f); b.save(); s && this._eventManager.ghostCtx.save(); b.beginPath(); b.rect(e.x1, e.y1, e.width, e.height); b.clip(); s && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip()); for (var p = 0; p < a.dataSeriesIndexes.length; p++) {
                    var q = a.dataSeriesIndexes[p], k = this.data[q], C = k.dataPoints; if (0 < C.length) {
                      var x = 5 < r && k.bevelEnabled ? !0 : !1; b.strokeStyle =
                        "#4572A7 "; for (g = 0; g < C.length; g++)if (C[g].getTime ? l = C[g].x.getTime() : l = C[g].x, !(l < a.axisX.dataInfo.viewPortMin || l > a.axisX.dataInfo.viewPortMax) && !h(C[g].y) && C[g].y.length && "number" === typeof C[g].y[0] && "number" === typeof C[g].y[1]) {
                          f = a.axisY.convertValueToPixel(C[g].y[0]); u = a.axisY.convertValueToPixel(C[g].y[1]); m = a.axisX.convertValueToPixel(l); m = a.axisX.reversed ? m + a.plotType.totalDataSeries * r / 2 - (a.previousDataSeriesCount + p) * r << 0 : m - a.plotType.totalDataSeries * r / 2 + (a.previousDataSeriesCount + p) * r << 0; var z =
                            a.axisX.reversed ? m - r << 0 : m + r << 0; f > u && (c = f, f = u, u = c); c = C[g].color ? C[g].color : k._colorSet[g % k._colorSet.length]; X(b, f, m, u, z, c, 0, null, x, !1, !1, !1, k.fillOpacity); c = k.dataPointIds[g]; this._eventManager.objectMap[c] = { id: c, objectType: "dataPoint", dataSeriesIndex: q, dataPointIndex: g, x1: f, y1: m, x2: u, y2: z }; c = Q(c); s && X(this._eventManager.ghostCtx, f, m, u, z, c, 0, null, !1, !1, !1, !1); if (C[g].indexLabel || k.indexLabel || C[g].indexLabelFormatter || k.indexLabelFormatter) this._indexLabels.push({
                              chartType: "rangeBar", dataPoint: C[g],
                              dataSeries: k, indexKeyword: 0, point: { x: C[g].y[1] >= C[g].y[0] ? f : u, y: m + (z - m) / 2 }, direction: C[g].y[1] >= C[g].y[0] ? -1 : 1, bounds: { x1: Math.min(f, u), y1: m, x2: Math.max(f, u), y2: z }, color: c
                            }), this._indexLabels.push({ chartType: "rangeBar", dataPoint: C[g], dataSeries: k, indexKeyword: 1, point: { x: C[g].y[1] >= C[g].y[0] ? u : f, y: m + (z - m) / 2 }, direction: C[g].y[1] >= C[g].y[0] ? 1 : -1, bounds: { x1: Math.min(f, u), y1: m, x2: Math.max(f, u), y2: z }, color: c })
                        }
                    }
                  } s && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation =
                    "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore()); b.restore(); return { source: d, dest: this.plotArea.ctx, animationCallback: v.fadeInAnimation, easingFunction: v.easing.easeInQuad, animationBase: 0 }
            }
          }; n.prototype.renderRangeArea =
            function (a) {
              function d() { if (w) { var a = null; 0 < r.lineThickness && c.stroke(); for (var b = m.length - 1; 0 <= b; b--)a = m[b], c.lineTo(a.x, a.y), e.lineTo(a.x, a.y); c.closePath(); c.globalAlpha = r.fillOpacity; c.fill(); c.globalAlpha = 1; e.fill(); if (0 < r.lineThickness) { c.beginPath(); c.moveTo(a.x, a.y); for (b = 0; b < m.length; b++)a = m[b], c.lineTo(a.x, a.y); c.stroke() } c.beginPath(); c.moveTo(C, x); e.beginPath(); e.moveTo(C, x); w = { x: C, y: x }; m = []; m.push({ x: C, y: n }) } } var b = a.targetCanvasCtx || this.plotArea.ctx, c = s ? this._preRenderCtx : b; if (!(0 >=
                a.dataSeriesIndexes.length)) {
                var e = this._eventManager.ghostCtx, g = [], f = this.plotArea; c.save(); s && e.save(); c.beginPath(); c.rect(f.x1, f.y1, f.width, f.height); c.clip(); s && (e.beginPath(), e.rect(f.x1, f.y1, f.width, f.height), e.clip()); for (var h = 0; h < a.dataSeriesIndexes.length; h++) {
                  var m = [], l = a.dataSeriesIndexes[h], r = this.data[l], p = r.dataPoints, g = r.id; this._eventManager.objectMap[g] = { objectType: "dataSeries", dataSeriesIndex: l }; g = Q(g); e.fillStyle = g; var g = [], q = !0, k = 0, C, x, n, t, w = null; if (0 < p.length) {
                    var B = r._colorSet[k %
                      r._colorSet.length], y = r.lineColor = r.options.lineColor || B, D = y; c.fillStyle = B; c.strokeStyle = y; c.lineWidth = r.lineThickness; var E = "solid"; if (c.setLineDash) { var H = R(r.nullDataLineDashType, r.lineThickness), E = r.lineDashType, G = R(E, r.lineThickness); c.setLineDash(G) } for (var P = !0; k < p.length; k++)if (t = p[k].x.getTime ? p[k].x.getTime() : p[k].x, !(t < a.axisX.dataInfo.viewPortMin || t > a.axisX.dataInfo.viewPortMax && (!r.connectNullData || !P))) if (null !== p[k].y && p[k].y.length && "number" === typeof p[k].y[0] && "number" === typeof p[k].y[1]) {
                        C =
                          a.axisX.convertValueToPixel(t); x = a.axisY.convertValueToPixel(p[k].y[0]); n = a.axisY.convertValueToPixel(p[k].y[1]); q || P ? (r.connectNullData && !q ? (c.setLineDash && (r.options.nullDataLineDashType || E === r.lineDashType && r.lineDashType !== r.nullDataLineDashType) && (m[m.length - 1].newLineDashArray = G, E = r.nullDataLineDashType, c.setLineDash(H)), c.lineTo(C, x), s && e.lineTo(C, x), m.push({ x: C, y: n })) : (c.beginPath(), c.moveTo(C, x), w = { x: C, y: x }, m = [], m.push({ x: C, y: n }), s && (e.beginPath(), e.moveTo(C, x))), P = q = !1) : (c.lineTo(C, x), m.push({
                            x: C,
                            y: n
                          }), s && e.lineTo(C, x), 0 == k % 250 && d()); t = r.dataPointIds[k]; this._eventManager.objectMap[t] = { id: t, objectType: "dataPoint", dataSeriesIndex: l, dataPointIndex: k, x1: C, y1: x, y2: n }; k < p.length - 1 && (D !== (p[k].lineColor || y) || E !== (p[k].lineDashType || r.lineDashType)) && (d(), D = p[k].lineColor || y, m[m.length - 1].newStrokeStyle = D, c.strokeStyle = D, c.setLineDash && (p[k].lineDashType ? (E = p[k].lineDashType, m[m.length - 1].newLineDashArray = R(E, r.lineThickness), c.setLineDash(m[m.length - 1].newLineDashArray)) : (E = r.lineDashType, m[m.length -
                            1].newLineDashArray = G, c.setLineDash(G)))); if (0 !== p[k].markerSize && (0 < p[k].markerSize || 0 < r.markerSize)) { var ca = r.getMarkerProperties(k, C, n, c); g.push(ca); var ea = Q(t); s && g.push({ x: C, y: n, ctx: e, type: ca.type, size: ca.size, color: ea, borderColor: ea, borderThickness: ca.borderThickness }); ca = r.getMarkerProperties(k, C, x, c); g.push(ca); ea = Q(t); s && g.push({ x: C, y: x, ctx: e, type: ca.type, size: ca.size, color: ea, borderColor: ea, borderThickness: ca.borderThickness }) } if (p[k].indexLabel || r.indexLabel || p[k].indexLabelFormatter ||
                              r.indexLabelFormatter) this._indexLabels.push({ chartType: "rangeArea", dataPoint: p[k], dataSeries: r, indexKeyword: 0, point: { x: C, y: x }, direction: p[k].y[0] > p[k].y[1] === a.axisY.reversed ? -1 : 1, color: B }), this._indexLabels.push({ chartType: "rangeArea", dataPoint: p[k], dataSeries: r, indexKeyword: 1, point: { x: C, y: n }, direction: p[k].y[0] > p[k].y[1] === a.axisY.reversed ? 1 : -1, color: B })
                      } else P || q || d(), P = !0; d(); z.drawMarkers(g)
                  }
                } s && (b.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop",
                  a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(f.x1, f.y1, f.width, f.height), this._eventManager.ghostCtx.restore()); c.restore(); return { source: b, dest: this.plotArea.ctx, animationCallback: v.xClipAnimation, easingFunction: v.easing.linear, animationBase: 0 }
              }
            }; n.prototype.renderRangeSplineArea =
              function (a) {
                function d(a, b) {
                  var d = w(x, 2); if (0 < d.length) {
                    if (0 < l.lineThickness) { c.strokeStyle = b; c.setLineDash && c.setLineDash(a); c.beginPath(); c.moveTo(d[0].x, d[0].y); for (var g = 0; g < d.length - 3; g += 3) { if (d[g].newStrokeStyle || d[g].newLineDashArray) c.stroke(), c.beginPath(), c.moveTo(d[g].x, d[g].y), d[g].newStrokeStyle && (c.strokeStyle = d[g].newStrokeStyle), d[g].newLineDashArray && c.setLineDash(d[g].newLineDashArray); c.bezierCurveTo(d[g + 1].x, d[g + 1].y, d[g + 2].x, d[g + 2].y, d[g + 3].x, d[g + 3].y) } c.stroke() } c.beginPath();
                    c.moveTo(d[0].x, d[0].y); s && (e.beginPath(), e.moveTo(d[0].x, d[0].y)); for (g = 0; g < d.length - 3; g += 3)c.bezierCurveTo(d[g + 1].x, d[g + 1].y, d[g + 2].x, d[g + 2].y, d[g + 3].x, d[g + 3].y), s && e.bezierCurveTo(d[g + 1].x, d[g + 1].y, d[g + 2].x, d[g + 2].y, d[g + 3].x, d[g + 3].y); d = w(n, 2); c.lineTo(n[n.length - 1].x, n[n.length - 1].y); for (g = d.length - 1; 2 < g; g -= 3)c.bezierCurveTo(d[g - 1].x, d[g - 1].y, d[g - 2].x, d[g - 2].y, d[g - 3].x, d[g - 3].y), s && e.bezierCurveTo(d[g - 1].x, d[g - 1].y, d[g - 2].x, d[g - 2].y, d[g - 3].x, d[g - 3].y); c.closePath(); c.globalAlpha = l.fillOpacity;
                    c.fill(); s && (e.closePath(), e.fill()); c.globalAlpha = 1; if (0 < l.lineThickness) { c.strokeStyle = b; c.setLineDash && c.setLineDash(a); c.beginPath(); c.moveTo(d[0].x, d[0].y); for (var k = g = 0; g < d.length - 3; g += 3, k++) { if (x[k].newStrokeStyle || x[k].newLineDashArray) c.stroke(), c.beginPath(), c.moveTo(d[g].x, d[g].y), x[k].newStrokeStyle && (c.strokeStyle = x[k].newStrokeStyle), x[k].newLineDashArray && c.setLineDash(x[k].newLineDashArray); c.bezierCurveTo(d[g + 1].x, d[g + 1].y, d[g + 2].x, d[g + 2].y, d[g + 3].x, d[g + 3].y) } c.stroke() } c.beginPath()
                  }
                }
                var b = a.targetCanvasCtx || this.plotArea.ctx, c = s ? this._preRenderCtx : b; if (!(0 >= a.dataSeriesIndexes.length)) {
                  var e = this._eventManager.ghostCtx, g = [], f = this.plotArea; c.save(); s && e.save(); c.beginPath(); c.rect(f.x1, f.y1, f.width, f.height); c.clip(); s && (e.beginPath(), e.rect(f.x1, f.y1, f.width, f.height), e.clip()); for (var h = 0; h < a.dataSeriesIndexes.length; h++) {
                    var m = a.dataSeriesIndexes[h], l = this.data[m], r = l.dataPoints, g = l.id; this._eventManager.objectMap[g] = { objectType: "dataSeries", dataSeriesIndex: m }; g = Q(g); e.fillStyle =
                      g; var g = [], p = 0, q, k, C, x = [], n = []; if (0 < r.length) {
                        var t = l._colorSet[p % l._colorSet.length], L = l.lineColor = l.options.lineColor || t, B = L; c.fillStyle = t; c.lineWidth = l.lineThickness; var y = "solid", D; if (c.setLineDash) { var E = R(l.nullDataLineDashType, l.lineThickness), y = l.lineDashType; D = R(y, l.lineThickness) } for (k = !1; p < r.length; p++)if (q = r[p].x.getTime ? r[p].x.getTime() : r[p].x, !(q < a.axisX.dataInfo.viewPortMin || q > a.axisX.dataInfo.viewPortMax && (!l.connectNullData || !k))) if (null !== r[p].y && r[p].y.length && "number" === typeof r[p].y[0] &&
                          "number" === typeof r[p].y[1]) {
                          q = a.axisX.convertValueToPixel(q); k = a.axisY.convertValueToPixel(r[p].y[0]); C = a.axisY.convertValueToPixel(r[p].y[1]); var H = l.dataPointIds[p]; this._eventManager.objectMap[H] = { id: H, objectType: "dataPoint", dataSeriesIndex: m, dataPointIndex: p, x1: q, y1: k, y2: C }; x[x.length] = { x: q, y: k }; n[n.length] = { x: q, y: C }; p < r.length - 1 && (B !== (r[p].lineColor || L) || y !== (r[p].lineDashType || l.lineDashType)) && (B = r[p].lineColor || L, x[x.length - 1].newStrokeStyle = B, c.setLineDash && (r[p].lineDashType ? (y = r[p].lineDashType,
                            x[x.length - 1].newLineDashArray = R(y, l.lineThickness)) : (y = l.lineDashType, x[x.length - 1].newLineDashArray = D))); if (0 !== r[p].markerSize && (0 < r[p].markerSize || 0 < l.markerSize)) { var G = l.getMarkerProperties(p, q, k, c); g.push(G); var P = Q(H); s && g.push({ x: q, y: k, ctx: e, type: G.type, size: G.size, color: P, borderColor: P, borderThickness: G.borderThickness }); G = l.getMarkerProperties(p, q, C, c); g.push(G); P = Q(H); s && g.push({ x: q, y: C, ctx: e, type: G.type, size: G.size, color: P, borderColor: P, borderThickness: G.borderThickness }) } if (r[p].indexLabel ||
                              l.indexLabel || r[p].indexLabelFormatter || l.indexLabelFormatter) this._indexLabels.push({ chartType: "rangeSplineArea", dataPoint: r[p], dataSeries: l, indexKeyword: 0, point: { x: q, y: k }, direction: r[p].y[0] <= r[p].y[1] ? -1 : 1, color: t }), this._indexLabels.push({ chartType: "rangeSplineArea", dataPoint: r[p], dataSeries: l, indexKeyword: 1, point: { x: q, y: C }, direction: r[p].y[0] <= r[p].y[1] ? 1 : -1, color: t }); k = !1
                        } else 0 < p && !k && (l.connectNullData ? c.setLineDash && (0 < x.length && (l.options.nullDataLineDashType || !r[p - 1].lineDashType)) && (x[x.length -
                          1].newLineDashArray = E, y = l.nullDataLineDashType) : (d(D, L), x = [], n = [])), k = !0; d(D, L); z.drawMarkers(g)
                      }
                  } s && (b.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(f.x1, f.y1, f.width, f.height),
                    this._eventManager.ghostCtx.restore()); c.restore(); return { source: b, dest: this.plotArea.ctx, animationCallback: v.xClipAnimation, easingFunction: v.easing.linear, animationBase: 0 }
                }
              }; n.prototype.renderWaterfall = function (a) {
                var d = a.targetCanvasCtx || this.plotArea.ctx, b = s ? this._preRenderCtx : d; if (!(0 >= a.dataSeriesIndexes.length)) {
                  var c = this._eventManager.ghostCtx, e = null, g = this.plotArea, f = 0, h, m, l, r, p = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), f = this.options.dataPointMinWidth ? this.dataPointMinWidth :
                    this.options.dataPointWidth ? this.dataPointWidth : 1; m = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : Math.min(0.15 * this.width, 0.9 * (this.plotArea.width / a.plotType.totalDataSeries)) << 0; var q = a.axisX.dataInfo.minDiff; isFinite(q) || (q = 0.3 * Math.abs(a.axisX.range)); q = this.options.dataPointWidth ? this.dataPointWidth : 0.6 * (g.width * (a.axisX.logarithmic ? Math.log(q) / Math.log(a.axisX.range) : Math.abs(q) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0; this.dataPointMaxWidth &&
                      f > m && (f = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, m)); !this.dataPointMaxWidth && (this.dataPointMinWidth && m < f) && (m = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, f)); q < f && (q = f); q > m && (q = m); b.save(); s && this._eventManager.ghostCtx.save(); b.beginPath(); b.rect(g.x1, g.y1, g.width, g.height); b.clip(); s && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(g.x1, g.y1, g.width, g.height), this._eventManager.ghostCtx.clip()); for (var k = 0; k < a.dataSeriesIndexes.length; k++) {
                        var C =
                          a.dataSeriesIndexes[k], x = this.data[C], z = x.dataPoints, e = x._colorSet[0]; x.risingColor = x.options.risingColor ? x.options.risingColor : e; x.fallingColor = x.options.fallingColor ? x.options.fallingColor : "#e40a0a"; var t = "number" === typeof x.options.lineThickness ? Math.round(x.lineThickness) : 1, n = 1 === Math.round(t) % 2 ? -0.5 : 0; if (0 < z.length) for (var w = 5 < q && x.bevelEnabled ? !0 : !1, B = !1, y = null, E = null, f = 0; f < z.length; f++)if (z[f].getTime ? r = z[f].x.getTime() : r = z[f].x, "number" !== typeof z[f].y) {
                            if (0 < f && !B && x.connectNullData) var D =
                              x.options.nullDataLineDashType || !z[f - 1].lineDashType ? x.nullDataLineDashType : z[f - 1].lineDashType; B = !0
                          } else {
                            h = a.axisX.convertValueToPixel(r); m = 0 === x.dataPointEOs[f].cumulativeSum ? p : a.axisY.convertValueToPixel(x.dataPointEOs[f].cumulativeSum); l = 0 === x.dataPointEOs[f].cumulativeSumYStartValue ? p : a.axisY.convertValueToPixel(x.dataPointEOs[f].cumulativeSumYStartValue); h = a.axisX.reversed ? h + a.plotType.totalDataSeries * q / 2 - (a.previousDataSeriesCount + k) * q << 0 : h - a.plotType.totalDataSeries * q / 2 + (a.previousDataSeriesCount +
                              k) * q << 0; var H = a.axisX.reversed ? h - q << 0 : h + q << 0; m > l && (e = m, m = l, l = e); a.axisY.reversed && (e = m, m = l, l = e); e = x.dataPointIds[f]; this._eventManager.objectMap[e] = { id: e, objectType: "dataPoint", dataSeriesIndex: C, dataPointIndex: f, x1: h, y1: m, x2: H, y2: l }; var P = z[f].color ? z[f].color : 0 < z[f].y ? x.risingColor : x.fallingColor; X(b, h, m, H, l, P, 0, P, w, w, !1, !1, x.fillOpacity); e = Q(e); s && X(this._eventManager.ghostCtx, h, m, H, l, e, 0, null, !1, !1, !1, !1); var ca, P = h; ca = "undefined" !== typeof z[f].isIntermediateSum && !0 === z[f].isIntermediateSum || "undefined" !==
                                typeof z[f].isCumulativeSum && !0 === z[f].isCumulativeSum ? 0 < z[f].y ? m : l : 0 < z[f].y ? l : m; 0 < f && y && (!B || x.connectNullData) && (B && b.setLineDash && b.setLineDash(R(D, t)), b.beginPath(), b.moveTo(y, E - n), b.lineTo(P, ca - n), 0 < t && b.stroke(), s && (c.beginPath(), c.moveTo(y, E - n), c.lineTo(P, ca - n), 0 < t && c.stroke())); B = !1; y = H; E = 0 < z[f].y ? m : l; P = z[f].lineDashType ? z[f].lineDashType : x.options.lineDashType ? x.options.lineDashType : "shortDash"; b.strokeStyle = z[f].lineColor ? z[f].lineColor : x.options.lineColor ? x.options.lineColor : "#9e9e9e";
                            b.lineWidth = t; b.setLineDash && (P = R(P, t), b.setLineDash(P)); (z[f].indexLabel || x.indexLabel || z[f].indexLabelFormatter || x.indexLabelFormatter) && this._indexLabels.push({ chartType: "waterfall", dataPoint: z[f], dataSeries: x, point: { x: h + (H - h) / 2, y: 0 <= z[f].y ? m : l }, direction: 0 > z[f].y === a.axisY.reversed ? 1 : -1, bounds: { x1: h, y1: Math.min(m, l), x2: H, y2: Math.max(m, l) }, color: e })
                          }
                      } s && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas,
                        0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(g.x1, g.y1, g.width, g.height), this._eventManager.ghostCtx.restore()); b.restore(); return { source: d, dest: this.plotArea.ctx, animationCallback: v.fadeInAnimation, easingFunction: v.easing.easeInQuad, animationBase: 0 }
                }
              }; var f = function (a, d, b, c, e, g, f, h, m) {
                if (!(0 > b)) {
                  "undefined" === typeof h &&
                    (h = 1); if (!s) { var l = Number((f % (2 * Math.PI)).toFixed(8)); Number((g % (2 * Math.PI)).toFixed(8)) === l && (f -= 1E-4) } a.save(); a.globalAlpha = h; "pie" === e ? (a.beginPath(), a.moveTo(d.x, d.y), a.arc(d.x, d.y, b, g, f, !1), a.fillStyle = c, a.strokeStyle = "white", a.lineWidth = 2, a.closePath(), a.fill()) : "doughnut" === e && (a.beginPath(), a.arc(d.x, d.y, b, g, f, !1), 0 <= m && a.arc(d.x, d.y, m * b, f, g, !0), a.closePath(), a.fillStyle = c, a.strokeStyle = "white", a.lineWidth = 2, a.fill()); a.globalAlpha = 1; a.restore()
                }
              }; n.prototype.renderPie = function (a) {
                function d() {
                  if (l &&
                    r) {
                    for (var a = 0, c = 0, b = 0, d = 0, e = 0; e < r.length; e++) {
                      var g = r[e], f = l.dataPointIds[e]; k[e].id = f; k[e].objectType = "dataPoint"; k[e].dataPointIndex = e; k[e].dataSeriesIndex = 0; var p = k[e], u = { percent: null, total: null }, m = null, u = x.getPercentAndTotal(l, g); if (l.indexLabelFormatter || g.indexLabelFormatter) m = { chart: x.options, dataSeries: l, dataPoint: g, total: u.total, percent: u.percent }; u = g.indexLabelFormatter ? g.indexLabelFormatter(m) : g.indexLabel ? x.replaceKeywordsWithValue(g.indexLabel, g, l, e) : l.indexLabelFormatter ? l.indexLabelFormatter(m) :
                        l.indexLabel ? x.replaceKeywordsWithValue(l.indexLabel, g, l, e) : g.label ? g.label : ""; x._eventManager.objectMap[f] = p; p.center = { x: n.x, y: n.y }; p.y = g.y; p.radius = y; p.percentInnerRadius = H; p.indexLabelText = u; p.indexLabelPlacement = l.indexLabelPlacement; p.indexLabelLineColor = g.indexLabelLineColor ? g.indexLabelLineColor : l.options.indexLabelLineColor ? l.options.indexLabelLineColor : g.color ? g.color : l._colorSet[e % l._colorSet.length]; p.indexLabelLineThickness = h(g.indexLabelLineThickness) ? l.indexLabelLineThickness : g.indexLabelLineThickness;
                      p.indexLabelLineDashType = g.indexLabelLineDashType ? g.indexLabelLineDashType : l.indexLabelLineDashType; p.indexLabelFontColor = g.indexLabelFontColor ? g.indexLabelFontColor : l.indexLabelFontColor; p.indexLabelFontStyle = g.indexLabelFontStyle ? g.indexLabelFontStyle : l.indexLabelFontStyle; p.indexLabelFontWeight = g.indexLabelFontWeight ? g.indexLabelFontWeight : l.indexLabelFontWeight; p.indexLabelFontSize = h(g.indexLabelFontSize) ? l.indexLabelFontSize : g.indexLabelFontSize; p.indexLabelFontFamily = g.indexLabelFontFamily ?
                        g.indexLabelFontFamily : l.indexLabelFontFamily; p.indexLabelBackgroundColor = g.indexLabelBackgroundColor ? g.indexLabelBackgroundColor : l.options.indexLabelBackgroundColor ? l.options.indexLabelBackgroundColor : l.indexLabelBackgroundColor; p.indexLabelMaxWidth = g.indexLabelMaxWidth ? g.indexLabelMaxWidth : l.indexLabelMaxWidth ? l.indexLabelMaxWidth : 0.33 * q.width; p.indexLabelWrap = "undefined" !== typeof g.indexLabelWrap ? g.indexLabelWrap : l.indexLabelWrap; p.startAngle = 0 === e ? l.startAngle ? l.startAngle / 180 * Math.PI : 0 : k[e - 1].endAngle;
                      p.startAngle = (p.startAngle + 2 * Math.PI) % (2 * Math.PI); p.endAngle = p.startAngle + 2 * Math.PI / w * Math.abs(g.y); g = (p.endAngle + p.startAngle) / 2; g = (g + 2 * Math.PI) % (2 * Math.PI); p.midAngle = g; if (p.midAngle > Math.PI / 2 - t && p.midAngle < Math.PI / 2 + t) { if (0 === a || k[b].midAngle > p.midAngle) b = e; a++ } else if (p.midAngle > 3 * Math.PI / 2 - t && p.midAngle < 3 * Math.PI / 2 + t) { if (0 === c || k[d].midAngle > p.midAngle) d = e; c++ } p.hemisphere = g > Math.PI / 2 && g <= 3 * Math.PI / 2 ? "left" : "right"; p.indexLabelTextBlock = new ja(x.plotArea.ctx, {
                        fontSize: p.indexLabelFontSize, fontFamily: p.indexLabelFontFamily,
                        fontColor: p.indexLabelFontColor, fontStyle: p.indexLabelFontStyle, fontWeight: p.indexLabelFontWeight, horizontalAlign: "left", backgroundColor: p.indexLabelBackgroundColor, maxWidth: p.indexLabelMaxWidth, maxHeight: p.indexLabelWrap ? 5 * p.indexLabelFontSize : 1.5 * p.indexLabelFontSize, text: p.indexLabelText, padding: 0, textBaseline: "top"
                      }); p.indexLabelTextBlock.measureText()
                    } f = g = 0; u = !1; for (e = 0; e < r.length; e++)p = k[(b + e) % r.length], 1 < a && (p.midAngle > Math.PI / 2 - t && p.midAngle < Math.PI / 2 + t) && (g <= a / 2 && !u ? (p.hemisphere = "right",
                      g++) : (p.hemisphere = "left", u = !0)); u = !1; for (e = 0; e < r.length; e++)p = k[(d + e) % r.length], 1 < c && (p.midAngle > 3 * Math.PI / 2 - t && p.midAngle < 3 * Math.PI / 2 + t) && (f <= c / 2 && !u ? (p.hemisphere = "left", f++) : (p.hemisphere = "right", u = !0))
                  }
                } function b(a) {
                  var c = x.plotArea.ctx; c.clearRect(q.x1, q.y1, q.width, q.height); c.fillStyle = x.backgroundColor; c.fillRect(q.x1, q.y1, q.width, q.height); for (c = 0; c < r.length; c++) {
                    var b = k[c].startAngle, d = k[c].endAngle; if (d > b) {
                      var e = 0.07 * y * Math.cos(k[c].midAngle), g = 0.07 * y * Math.sin(k[c].midAngle), h = !1; if (r[c].exploded) {
                        if (1E-9 <
                          Math.abs(k[c].center.x - (n.x + e)) || 1E-9 < Math.abs(k[c].center.y - (n.y + g))) k[c].center.x = n.x + e * a, k[c].center.y = n.y + g * a, h = !0
                      } else if (0 < Math.abs(k[c].center.x - n.x) || 0 < Math.abs(k[c].center.y - n.y)) k[c].center.x = n.x + e * (1 - a), k[c].center.y = n.y + g * (1 - a), h = !0; h && (e = {}, e.dataSeries = l, e.dataPoint = l.dataPoints[c], e.index = c, x.toolTip.highlightObjects([e])); f(x.plotArea.ctx, k[c].center, k[c].radius, r[c].color ? r[c].color : l._colorSet[c % l._colorSet.length], l.type, b, d, l.fillOpacity, k[c].percentInnerRadius)
                    }
                  } a = x.plotArea.ctx;
                  a.save(); a.fillStyle = "black"; a.strokeStyle = "grey"; a.textBaseline = "middle"; a.lineJoin = "round"; for (c = c = 0; c < r.length; c++)b = k[c], b.indexLabelText && (b.indexLabelTextBlock.y -= b.indexLabelTextBlock.height / 2, d = 0, d = "left" === b.hemisphere ? "inside" !== l.indexLabelPlacement ? -(b.indexLabelTextBlock.width + p) : -b.indexLabelTextBlock.width / 2 : "inside" !== l.indexLabelPlacement ? p : -b.indexLabelTextBlock.width / 2, b.indexLabelTextBlock.x += d, b.indexLabelTextBlock.render(!0), b.indexLabelTextBlock.x -= d, b.indexLabelTextBlock.y +=
                    b.indexLabelTextBlock.height / 2, "inside" !== b.indexLabelPlacement && 0 < b.indexLabelLineThickness && (d = b.center.x + y * Math.cos(b.midAngle), e = b.center.y + y * Math.sin(b.midAngle), a.strokeStyle = b.indexLabelLineColor, a.lineWidth = b.indexLabelLineThickness, a.setLineDash && a.setLineDash(R(b.indexLabelLineDashType, b.indexLabelLineThickness)), a.beginPath(), a.moveTo(d, e), a.lineTo(b.indexLabelTextBlock.x, b.indexLabelTextBlock.y), a.lineTo(b.indexLabelTextBlock.x + ("left" === b.hemisphere ? -p : p), b.indexLabelTextBlock.y), a.stroke()),
                    a.lineJoin = "miter"); a.save()
                } function c(a, c) { var b = 0, b = a.indexLabelTextBlock.y - a.indexLabelTextBlock.height / 2, d = a.indexLabelTextBlock.y + a.indexLabelTextBlock.height / 2, e = c.indexLabelTextBlock.y - c.indexLabelTextBlock.height / 2, g = c.indexLabelTextBlock.y + c.indexLabelTextBlock.height / 2; return b = c.indexLabelTextBlock.y > a.indexLabelTextBlock.y ? e - d : b - g } function e(a) {
                  for (var b = null, d = 1; d < r.length; d++)if (b = (a + d + k.length) % k.length, k[b].hemisphere !== k[a].hemisphere) { b = null; break } else if (k[b].indexLabelText && b !==
                    a && (0 > c(k[b], k[a]) || ("right" === k[a].hemisphere ? k[b].indexLabelTextBlock.y >= k[a].indexLabelTextBlock.y : k[b].indexLabelTextBlock.y <= k[a].indexLabelTextBlock.y))) break; else b = null; return b
                } function g(a, b, d) {
                  d = (d || 0) + 1; if (1E3 < d) return 0; b = b || 0; var l = 0, f = n.y - 1 * v, h = n.y + 1 * v; if (0 <= a && a < r.length) {
                    var p = k[a]; if (0 > b && p.indexLabelTextBlock.y < f || 0 < b && p.indexLabelTextBlock.y > h) return 0; var q = 0, u = 0, u = q = q = 0; 0 > b ? p.indexLabelTextBlock.y - p.indexLabelTextBlock.height / 2 > f && p.indexLabelTextBlock.y - p.indexLabelTextBlock.height /
                      2 + b < f && (b = -(f - (p.indexLabelTextBlock.y - p.indexLabelTextBlock.height / 2 + b))) : p.indexLabelTextBlock.y + p.indexLabelTextBlock.height / 2 < f && p.indexLabelTextBlock.y + p.indexLabelTextBlock.height / 2 + b > h && (b = p.indexLabelTextBlock.y + p.indexLabelTextBlock.height / 2 + b - h); b = p.indexLabelTextBlock.y + b; f = 0; f = "right" === p.hemisphere ? n.x + Math.sqrt(Math.pow(v, 2) - Math.pow(b - n.y, 2)) : n.x - Math.sqrt(Math.pow(v, 2) - Math.pow(b - n.y, 2)); u = n.x + y * Math.cos(p.midAngle); q = n.y + y * Math.sin(p.midAngle); q = Math.sqrt(Math.pow(f - u, 2) + Math.pow(b -
                        q, 2)); u = Math.acos(y / v); q = Math.acos((v * v + y * y - q * q) / (2 * y * v)); b = q < u ? b - p.indexLabelTextBlock.y : 0; f = null; for (h = 1; h < r.length; h++)if (f = (a - h + k.length) % k.length, k[f].hemisphere !== k[a].hemisphere) { f = null; break } else if (k[f].indexLabelText && k[f].hemisphere === k[a].hemisphere && f !== a && (0 > c(k[f], k[a]) || ("right" === k[a].hemisphere ? k[f].indexLabelTextBlock.y <= k[a].indexLabelTextBlock.y : k[f].indexLabelTextBlock.y >= k[a].indexLabelTextBlock.y))) break; else f = null; u = f; q = e(a); h = f = 0; 0 > b ? (h = "right" === p.hemisphere ? u : q, l = b, null !==
                          h && (u = -b, b = p.indexLabelTextBlock.y - p.indexLabelTextBlock.height / 2 - (k[h].indexLabelTextBlock.y + k[h].indexLabelTextBlock.height / 2), b - u < C && (f = -u, h = g(h, f, d + 1), +h.toFixed(s) > +f.toFixed(s) && (l = b > C ? -(b - C) : -(u - (h - f)))))) : 0 < b && (h = "right" === p.hemisphere ? q : u, l = b, null !== h && (u = b, b = k[h].indexLabelTextBlock.y - k[h].indexLabelTextBlock.height / 2 - (p.indexLabelTextBlock.y + p.indexLabelTextBlock.height / 2), b - u < C && (f = u, h = g(h, f, d + 1), +h.toFixed(s) < +f.toFixed(s) && (l = b > C ? b - C : u - (f - h))))); l && (d = p.indexLabelTextBlock.y + l, b = 0, b =
                            "right" === p.hemisphere ? n.x + Math.sqrt(Math.pow(v, 2) - Math.pow(d - n.y, 2)) : n.x - Math.sqrt(Math.pow(v, 2) - Math.pow(d - n.y, 2)), p.midAngle > Math.PI / 2 - t && p.midAngle < Math.PI / 2 + t ? (f = (a - 1 + k.length) % k.length, f = k[f], a = k[(a + 1 + k.length) % k.length], "left" === p.hemisphere && "right" === f.hemisphere && b > f.indexLabelTextBlock.x ? b = f.indexLabelTextBlock.x - 15 : "right" === p.hemisphere && ("left" === a.hemisphere && b < a.indexLabelTextBlock.x) && (b = a.indexLabelTextBlock.x + 15)) : p.midAngle > 3 * Math.PI / 2 - t && p.midAngle < 3 * Math.PI / 2 + t && (f = (a - 1 + k.length) %
                              k.length, f = k[f], a = k[(a + 1 + k.length) % k.length], "right" === p.hemisphere && "left" === f.hemisphere && b < f.indexLabelTextBlock.x ? b = f.indexLabelTextBlock.x + 15 : "left" === p.hemisphere && ("right" === a.hemisphere && b > a.indexLabelTextBlock.x) && (b = a.indexLabelTextBlock.x - 15)), p.indexLabelTextBlock.y = d, p.indexLabelTextBlock.x = b, p.indexLabelAngle = Math.atan2(p.indexLabelTextBlock.y - n.y, p.indexLabelTextBlock.x - n.x))
                  } return l
                } function m() {
                  var a = x.plotArea.ctx; a.fillStyle = "grey"; a.strokeStyle = "grey"; a.font = "16px Arial"; a.textBaseline =
                    "middle"; for (var b = a = 0, d = 0, f = !0, b = 0; 10 > b && (1 > b || 0 < d); b++) {
                      if (l.radius || !l.radius && "undefined" !== typeof l.innerRadius && null !== l.innerRadius && y - d <= D) f = !1; f && (y -= d); d = 0; if ("inside" !== l.indexLabelPlacement) {
                        v = y * z; for (a = 0; a < r.length; a++) { var h = k[a]; h.indexLabelTextBlock.x = n.x + v * Math.cos(h.midAngle); h.indexLabelTextBlock.y = n.y + v * Math.sin(h.midAngle); h.indexLabelAngle = h.midAngle; h.radius = y; h.percentInnerRadius = H } for (var u, A, a = 0; a < r.length; a++) {
                          var h = k[a], t = e(a); if (null !== t) {
                            u = k[a]; A = k[t]; var w = 0, w = c(u, A) -
                              C; if (0 > w) { for (var B = A = 0, G = 0; G < r.length; G++)G !== a && k[G].hemisphere === h.hemisphere && (k[G].indexLabelTextBlock.y < h.indexLabelTextBlock.y ? A++ : B++); A = w / (A + B || 1) * B; var B = -1 * (w - A), Ca = G = 0; "right" === h.hemisphere ? (G = g(a, A), B = -1 * (w - G), Ca = g(t, B), +Ca.toFixed(s) < +B.toFixed(s) && +G.toFixed(s) <= +A.toFixed(s) && g(a, -(B - Ca))) : (G = g(t, A), B = -1 * (w - G), Ca = g(a, B), +Ca.toFixed(s) < +B.toFixed(s) && +G.toFixed(s) <= +A.toFixed(s) && g(t, -(B - Ca))) }
                          }
                        }
                      } else for (a = 0; a < r.length; a++)h = k[a], v = "pie" === l.type ? 0.7 * y : 0.8 * y, t = n.x + v * Math.cos(h.midAngle),
                        A = n.y + v * Math.sin(h.midAngle), h.indexLabelTextBlock.x = t, h.indexLabelTextBlock.y = A; for (a = 0; a < r.length; a++)if (h = k[a], t = h.indexLabelTextBlock.measureText(), 0 !== t.height && 0 !== t.width) t = t = 0, "right" === h.hemisphere ? (t = q.x2 - (h.indexLabelTextBlock.x + h.indexLabelTextBlock.width + p), t *= -1) : t = q.x1 - (h.indexLabelTextBlock.x - h.indexLabelTextBlock.width - p), 0 < t && (!f && h.indexLabelText && (A = "right" === h.hemisphere ? q.x2 - h.indexLabelTextBlock.x : h.indexLabelTextBlock.x - q.x1, 0.3 * h.indexLabelTextBlock.maxWidth > A ? h.indexLabelText =
                          "" : h.indexLabelTextBlock.maxWidth = 0.85 * A, 0.3 * h.indexLabelTextBlock.maxWidth < A && (h.indexLabelTextBlock.x -= "right" === h.hemisphere ? 2 : -2)), Math.abs(h.indexLabelTextBlock.y - h.indexLabelTextBlock.height / 2 - n.y) < y || Math.abs(h.indexLabelTextBlock.y + h.indexLabelTextBlock.height / 2 - n.y) < y) && (t /= Math.abs(Math.cos(h.indexLabelAngle)), 9 < t && (t *= 0.3), t > d && (d = t)), t = t = 0, 0 < h.indexLabelAngle && h.indexLabelAngle < Math.PI ? (t = q.y2 - (h.indexLabelTextBlock.y + h.indexLabelTextBlock.height / 2 + 5), t *= -1) : t = q.y1 - (h.indexLabelTextBlock.y -
                            h.indexLabelTextBlock.height / 2 - 5), 0 < t && (!f && h.indexLabelText && (A = 0 < h.indexLabelAngle && h.indexLabelAngle < Math.PI ? -1 : 1, 0 === g(a, t * A) && g(a, 2 * A)), Math.abs(h.indexLabelTextBlock.x - n.x) < y && (t /= Math.abs(Math.sin(h.indexLabelAngle)), 9 < t && (t *= 0.3), t > d && (d = t))); var O = function (a, b, c) {
                              for (var d = [], e = 0; d.push(k[b]), b !== c; b = (b + 1 + r.length) % r.length); d.sort(function (a, b) { return a.y - b.y }); for (b = 0; b < d.length; b++)if (c = d[b], e < 0.7 * a) e += c.indexLabelTextBlock.height, c.indexLabelTextBlock.text = "", c.indexLabelText = "", c.indexLabelTextBlock.measureText();
                              else break
                            }; (function () {
                              for (var a = -1, b = -1, d = 0, g = !1, f = 0; f < r.length; f++)if (g = !1, u = k[f], u.indexLabelText) {
                                var l = e(f); if (null !== l) {
                                  var h = k[l]; w = 0; w = c(u, h); var q; if (q = 0 > w) {
                                    q = u.indexLabelTextBlock.x; var m = u.indexLabelTextBlock.y - u.indexLabelTextBlock.height / 2, A = u.indexLabelTextBlock.y + u.indexLabelTextBlock.height / 2, t = h.indexLabelTextBlock.y - h.indexLabelTextBlock.height / 2, x = h.indexLabelTextBlock.x + h.indexLabelTextBlock.width, C = h.indexLabelTextBlock.y + h.indexLabelTextBlock.height / 2; q = u.indexLabelTextBlock.x +
                                      u.indexLabelTextBlock.width < h.indexLabelTextBlock.x - p || q > x + p || m > C + p || A < t - p ? !1 : !0
                                  } q ? (0 > a && (a = f), l !== a && (b = l, d += -w), 0 === f % Math.max(r.length / 10, 3) && (g = !0)) : g = !0; g && (0 < d && 0 <= a && 0 <= b) && (O(d, a, b), b = a = -1, d = 0)
                                }
                              } 0 < d && O(d, a, b)
                            })()
                    }
                } function u() {
                  x.plotArea.layoutManager.reset(); x.title && (x.title.dockInsidePlotArea || "center" === x.title.horizontalAlign && "center" === x.title.verticalAlign) && x.title.render(); if (x.subtitles) for (var a = 0; a < x.subtitles.length; a++) {
                    var b = x.subtitles[a]; (b.dockInsidePlotArea || "center" ===
                      b.horizontalAlign && "center" === b.verticalAlign) && b.render()
                  } x.legend && (x.legend.dockInsidePlotArea || "center" === x.legend.horizontalAlign && "center" === x.legend.verticalAlign) && (x.legend.setLayout(), x.legend.render())
                } var x = this; if (!(0 >= a.dataSeriesIndexes.length)) {
                  var l = this.data[a.dataSeriesIndexes[0]], r = l.dataPoints, p = 10, q = this.plotArea, k = l.dataPointEOs, C = 2, v, z = 1.3, t = 20 / 180 * Math.PI, s = 6, n = { x: (q.x2 + q.x1) / 2, y: (q.y2 + q.y1) / 2 }, w = 0; a = !1; for (var B = 0; B < r.length; B++)w += Math.abs(r[B].y), !a && ("undefined" !== typeof r[B].indexLabel &&
                    null !== r[B].indexLabel && 0 < r[B].indexLabel.toString().length) && (a = !0), !a && ("undefined" !== typeof r[B].label && null !== r[B].label && 0 < r[B].label.toString().length) && (a = !0); if (0 !== w) {
                      a = a || "undefined" !== typeof l.indexLabel && null !== l.indexLabel && 0 < l.indexLabel.toString().length; var y = "inside" !== l.indexLabelPlacement && a ? 0.75 * Math.min(q.width, q.height) / 2 : 0.92 * Math.min(q.width, q.height) / 2; l.radius && (y = Va(l.radius, y)); var D = "undefined" !== typeof l.innerRadius && null !== l.innerRadius ? Va(l.innerRadius, y) : 0.7 * y; l.radius =
                        y; "doughnut" === l.type && (l.innerRadius = D); var H = Math.min(D / y, (y - 1) / y); this.pieDoughnutClickHandler = function (a) { x.isAnimating || !h(a.dataSeries.explodeOnClick) && !a.dataSeries.explodeOnClick || (a = a.dataPoint, a.exploded = a.exploded ? !1 : !0, 1 < this.dataPoints.length && x._animator.animate(0, 500, function (a) { b(a); u() })) }; d(); m(); m(); m(); m(); this.disableToolTip = !0; this._animator.animate(0, this.animatedRender ? this.animationDuration : 0, function (a) {
                          var b = x.plotArea.ctx; b.clearRect(q.x1, q.y1, q.width, q.height); b.fillStyle =
                            x.backgroundColor; b.fillRect(q.x1, q.y1, q.width, q.height); a = k[0].startAngle + 2 * Math.PI * a; for (b = 0; b < r.length; b++) { var c = 0 === b ? k[b].startAngle : d, d = c + (k[b].endAngle - k[b].startAngle), e = !1; d > a && (d = a, e = !0); var g = r[b].color ? r[b].color : l._colorSet[b % l._colorSet.length]; d > c && f(x.plotArea.ctx, k[b].center, k[b].radius, g, l.type, c, d, l.fillOpacity, k[b].percentInnerRadius); if (e) break } u()
                        }, function () { x.disableToolTip = !1; x._animator.animate(0, x.animatedRender ? 500 : 0, function (a) { b(a); u() }) })
                    }
                }
              }; var x = function (a, d, b, c) {
                "undefined" ===
                  typeof b && (b = 1); 0 >= Math.round(d.y4 - d.y1) || (a.save(), a.globalAlpha = b, a.beginPath(), a.moveTo(Math.round(d.x1), Math.round(d.y1)), a.lineTo(Math.round(d.x2), Math.round(d.y2)), a.lineTo(Math.round(d.x3), Math.round(d.y3)), a.lineTo(Math.round(d.x4), Math.round(d.y4)), "undefined" !== d.x5 && (a.lineTo(Math.round(d.x5), Math.round(d.y5)), a.lineTo(Math.round(d.x6), Math.round(d.y6))), a.closePath(), a.fillStyle = c ? c : d.color, a.fill(), a.globalAplha = 1, a.restore())
              }; n.prototype.renderFunnel = function (a) {
                function d() {
                  for (var a =
                    0, b = [], c = 0; c < w.length; c++) { if ("undefined" === typeof w[c].y) return -1; w[c].y = "number" === typeof w[c].y ? w[c].y : 0; a += Math.abs(w[c].y) } if (0 === a) return -1; for (c = b[0] = 0; c < w.length; c++)b.push(Math.abs(w[c].y) * H / a); return b
                } function b() {
                  var a = U, b = X, c = O, d = T, e, g; e = N; g = aa - da; d = Math.abs((g - e) * (b - a + (d - c)) / 2); c = T - O; e = g - e; g = c * (g - aa); g = Math.abs(g); g = d + g; for (var d = [], k = 0, f = 0; f < w.length; f++) { if ("undefined" === typeof w[f].y) return -1; w[f].y = "number" === typeof w[f].y ? w[f].y : 0; k += Math.abs(w[f].y) } if (0 === k) return -1; for (var l =
                    d[0] = 0, h = 0, p, q, b = b - a, l = !1, f = 0; f < w.length; f++)a = Math.abs(w[f].y) * g / k, l ? p = 0 == Number(c.toFixed(3)) ? 0 : a / c : (q = V * V * b * b - 4 * Math.abs(V) * a, 0 > q ? (q = c, l = (b + q) * (e - h) / 2, a -= l, p = e - h, h += e - h, p += 0 == q ? 0 : a / q, h += a / q, l = !0) : (p = (Math.abs(V) * b - Math.sqrt(q)) / 2, q = b - 2 * p / Math.abs(V), h += p, h > e && (h -= p, q = c, l = (b + q) * (e - h) / 2, a -= l, p = e - h, h += e - h, p += a / q, h += a / q, l = !0), b = q)), d.push(p); return d
                } function c() {
                  if (t && w) {
                    for (var a, b, c, d, e, g, f, l, p, q, u, r, m, A, x = [], C = [], v = { percent: null, total: null }, z = null, y = 0; y < w.length; y++)A = S[y], A = "undefined" !== typeof A.x5 ?
                      (A.y2 + A.y4) / 2 : (A.y2 + A.y3) / 2, A = k(A).x2 + 1, x[y] = M - A - W; A = 0.5 * W; for (var y = 0, B = w.length - 1; y < w.length || 0 <= B; y++, B--) {
                        b = t.reversed ? w[B] : w[y]; a = b.color ? b.color : t.reversed ? t._colorSet[(w.length - 1 - y) % t._colorSet.length] : t._colorSet[y % t._colorSet.length]; c = b.indexLabelPlacement || t.indexLabelPlacement || "outside"; d = b.indexLabelBackgroundColor || t.indexLabelBackgroundColor || (s ? "transparent" : null); e = b.indexLabelFontColor || t.indexLabelFontColor || "#979797"; g = h(b.indexLabelFontSize) ? t.indexLabelFontSize : b.indexLabelFontSize;
                        f = b.indexLabelFontStyle || t.indexLabelFontStyle || "normal"; l = b.indexLabelFontFamily || t.indexLabelFontFamily || "arial"; p = b.indexLabelFontWeight || t.indexLabelFontWeight || "normal"; a = b.indexLabelLineColor || t.options.indexLabelLineColor || a; q = "number" === typeof b.indexLabelLineThickness ? b.indexLabelLineThickness : "number" === typeof t.indexLabelLineThickness ? t.indexLabelLineThickness : 2; u = b.indexLabelLineDashType || t.indexLabelLineDashType || "solid"; r = "undefined" !== typeof b.indexLabelWrap ? b.indexLabelWrap : "undefined" !==
                          typeof t.indexLabelWrap ? t.indexLabelWrap : !0; m = t.dataPointIds[y]; n._eventManager.objectMap[m] = { id: m, objectType: "dataPoint", dataPointIndex: y, dataSeriesIndex: 0, funnelSection: S[t.reversed ? w.length - 1 - y : y] }; "inside" === t.indexLabelPlacement && (x[y] = y !== Y ? t.reversed ? S[y].x2 - S[y].x1 : S[y].x3 - S[y].x4 : S[y].x3 - S[y].x6, 20 > x[y] && (x[y] = y !== Y ? t.reversed ? S[y].x3 - S[y].x4 : S[y].x2 - S[y].x1 : S[y].x2 - S[y].x1, x[y] /= 2)); m = b.indexLabelMaxWidth ? b.indexLabelMaxWidth : t.options.indexLabelMaxWidth ? t.indexLabelMaxWidth : x[y]; if (m > x[y] ||
                            0 > m) m = x[y]; C[y] = "inside" === t.indexLabelPlacement ? S[y].height : !1; v = n.getPercentAndTotal(t, b); if (t.indexLabelFormatter || b.indexLabelFormatter) z = { chart: n.options, dataSeries: t, dataPoint: b, total: v.total, percent: v.percent }; b = b.indexLabelFormatter ? b.indexLabelFormatter(z) : b.indexLabel ? n.replaceKeywordsWithValue(b.indexLabel, b, t, y) : t.indexLabelFormatter ? t.indexLabelFormatter(z) : t.indexLabel ? n.replaceKeywordsWithValue(t.indexLabel, b, t, y) : b.label ? b.label : ""; 0 >= q && (q = 0); 1E3 > m && 1E3 - m < A && (m += 1E3 - m); Q.roundRect ||
                              Ha(Q); c = new ja(Q, { fontSize: g, fontFamily: l, fontColor: e, fontStyle: f, fontWeight: p, horizontalAlign: c, backgroundColor: d, maxWidth: m, maxHeight: !1 === C[y] ? r ? 4.28571429 * g : 1.5 * g : C[y], text: b, padding: ga }); c.measureText(); J.push({ textBlock: c, id: t.reversed ? B : y, isDirty: !1, lineColor: a, lineThickness: q, lineDashType: u, height: c.height < c.maxHeight ? c.height : c.maxHeight, width: c.width < c.maxWidth ? c.width : c.maxWidth })
                      }
                  }
                } function e() {
                  var a, b, c, d, e, g = []; e = !1; c = 0; for (var k, f = M - X - W / 2, f = t.options.indexLabelMaxWidth ? t.indexLabelMaxWidth >
                    f ? f : t.indexLabelMaxWidth : f, l = J.length - 1; 0 <= l; l--) { k = w[J[l].id]; c = J[l]; d = c.textBlock; b = (a = q(l) < S.length ? J[q(l)] : null) ? a.textBlock : null; c = c.height; a && d.y + c + ga > b.y && (e = !0); c = k.indexLabelMaxWidth || f; if (c > f || 0 > c) c = f; g.push(c) } if (e) for (l = J.length - 1; 0 <= l; l--)a = S[l], J[l].textBlock.maxWidth = g[g.length - (l + 1)], J[l].textBlock.measureText(), J[l].textBlock.x = M - f, c = J[l].textBlock.height < J[l].textBlock.maxHeight ? J[l].textBlock.height : J[l].textBlock.maxHeight, e = J[l].textBlock.width < J[l].textBlock.maxWidth ? J[l].textBlock.width :
                      J[l].textBlock.maxWidth, J[l].height = c, J[l].width = e, c = "undefined" !== typeof a.x5 ? (a.y2 + a.y4) / 2 : (a.y2 + a.y3) / 2, J[l].textBlock.y = c - J[l].height / 2, t.reversed ? (J[l].textBlock.y + J[l].height > ta + B && (J[l].textBlock.y = ta + B - J[l].height), J[l].textBlock.y < xa - B && (J[l].textBlock.y = xa - B)) : (J[l].textBlock.y < ta - B && (J[l].textBlock.y = ta - B), J[l].textBlock.y + J[l].height > xa + B && (J[l].textBlock.y = xa + B - J[l].height))
                } function g() {
                  var a, b, c, d; if ("inside" !== t.indexLabelPlacement) for (var e = 0; e < S.length; e++)0 == J[e].textBlock.text.length ?
                    J[e].isDirty = !0 : (a = S[e], c = "undefined" !== typeof a.x5 ? (a.y2 + a.y4) / 2 : (a.y2 + a.y3) / 2, b = t.reversed ? "undefined" !== typeof a.x5 ? c > Z ? k(c).x2 + 1 : (a.x2 + a.x3) / 2 + 1 : (a.x2 + a.x3) / 2 + 1 : "undefined" !== typeof a.x5 ? c < Z ? k(c).x2 + 1 : (a.x4 + a.x3) / 2 + 1 : (a.x2 + a.x3) / 2 + 1, J[e].textBlock.x = b + W, J[e].textBlock.y = c - J[e].height / 2, t.reversed ? (J[e].textBlock.y + J[e].height > ta + B && (J[e].textBlock.y = ta + B - J[e].height), J[e].textBlock.y < xa - B && (J[e].textBlock.y = xa - B)) : (J[e].textBlock.y < ta - B && (J[e].textBlock.y = ta - B), J[e].textBlock.y + J[e].height > xa +
                      B && (J[e].textBlock.y = xa + B - J[e].height))); else for (e = 0; e < S.length; e++)0 == J[e].textBlock.text.length ? J[e].isDirty = !0 : (a = S[e], b = a.height, c = J[e].height, d = J[e].width, b >= c ? (b = e != Y ? (a.x4 + a.x3) / 2 - d / 2 : (a.x5 + a.x4) / 2 - d / 2, c = e != Y ? (a.y1 + a.y3) / 2 - c / 2 : (a.y1 + a.y4) / 2 - c / 2, J[e].textBlock.x = b, J[e].textBlock.y = c) : J[e].isDirty = !0)
                } function f() {
                  function a(b, c) {
                    var d; if (0 > b || b >= J.length) return 0; var e, g = J[b].textBlock; if (0 > c) {
                      c *= -1; e = p(b); d = u(e, b); if (d >= c) return g.y -= c, c; if (0 == b) return 0 < d && (g.y -= d), d; d += a(e, -(c - d)); 0 < d &&
                        (g.y -= d); return d
                    } e = q(b); d = u(b, e); if (d >= c) return g.y += c, c; if (b == S.length - 1) return 0 < d && (g.y += d), d; d += a(e, c - d); 0 < d && (g.y += d); return d
                  } function b() {
                    var a, d, e, g, k = 0, l; g = (aa - N + 2 * B) / r; l = r; for (var f, h = 1; h < l; h++) { e = h * g; for (var u = J.length - 1; 0 <= u; u--)!J[u].isDirty && (J[u].textBlock.y < e && J[u].textBlock.y + J[u].height > e) && (f = q(u), !(f >= J.length - 1) && J[u].textBlock.y + J[u].height + ga > J[f].textBlock.y && (J[u].textBlock.y = J[u].textBlock.y + J[u].height - e > e - J[u].textBlock.y ? e + 1 : e - J[u].height - 1)) } for (f = S.length - 1; 0 < f; f--)if (!J[f].isDirty) {
                      e =
                        p(f); if (0 > e && (e = 0, J[e].isDirty)) break; if (J[f].textBlock.y < J[e].textBlock.y + J[e].height) { d = d || f; g = f; for (l = 0; J[g].textBlock.y < J[e].textBlock.y + J[e].height + ga;) { a = a || J[g].textBlock.y + J[g].height; l += J[g].height; l += ga; g = e; if (0 >= g) { g = 0; l += J[g].height; break } e = p(g); if (0 > e) { g = 0; l += J[g].height; break } } if (g != f) { k = J[g].textBlock.y; a -= k; a = l - a; k = c(a, d, g); break } }
                    } return k
                  } function c(a, b, d) {
                    var e = [], g = 0, k = 0; for (a = Math.abs(a); d <= b; d++)e.push(S[d]); e.sort(function (a, b) { return a.height - b.height }); for (d = 0; d < e.length; d++)if (b =
                      e[d], g < a) k++, g += J[b.id].height + ga, J[b.id].textBlock.text = "", J[b.id].indexLabelText = "", J[b.id].isDirty = !0, J[b.id].textBlock.measureText(); else break; return k
                  } for (var d, e, g, k, l, h, r = 1, m = 0; m < 2 * r; m++) { for (var A = J.length - 1; 0 <= A && !(0 <= p(A) && p(A), g = J[A], k = g.textBlock, h = (l = q(A) < S.length ? J[q(A)] : null) ? l.textBlock : null, d = +g.height.toFixed(6), e = +k.y.toFixed(6), !g.isDirty && (l && e + d + ga > +h.y.toFixed(6)) && (d = k.y + d + ga - h.y, e = a(A, -d), e < d && (0 < e && (d -= e), e = a(q(A), d), e != d))); A--); b() }
                } function u(a, b) {
                  return (b < S.length ? J[b].textBlock.y :
                    t.reversed ? ta + B : xa + B) - (0 > a ? t.reversed ? xa - B : ta - B : J[a].textBlock.y + J[a].height + ga)
                } function m(a, b, c) {
                  var d, e, k, f = [], h = B, p = []; -1 !== b && (0 <= ma.indexOf(b) ? (e = ma.indexOf(b), ma.splice(e, 1)) : (ma.push(b), ma = ma.sort(function (a, b) { return a - b }))); if (0 === ma.length) f = ka; else {
                    e = B * (1 != ma.length || 0 != ma[0] && ma[0] != S.length - 1 ? 2 : 1) / l(); for (var q = 0; q < S.length; q++) {
                      if (1 == ma.length && 0 == ma[0]) { if (0 === q) { f.push(ka[q]); d = h; continue } } else 0 === q && (d = -1 * h); f.push(ka[q] + d); if (0 <= ma.indexOf(q) || q < S.length && 0 <= ma.indexOf(q + 1)) d +=
                        e
                    }
                  } k = function () { for (var a = [], b = 0; b < S.length; b++)a.push(f[b] - S[b].y1); return a }(); var u = { startTime: (new Date).getTime(), duration: c || 500, easingFunction: function (a, b, c, d) { return v.easing.easeOutQuart(a, b, c, d) }, changeSection: function (a) { for (var b, c, d = 0; d < S.length; d++)b = k[d], c = S[d], b *= a, "undefined" === typeof p[d] && (p[d] = 0), 0 > p && (p *= -1), c.y1 += b - p[d], c.y2 += b - p[d], c.y3 += b - p[d], c.y4 += b - p[d], c.y5 && (c.y5 += b - p[d], c.y6 += b - p[d]), p[d] = b } }; a._animator.animate(0, c, function (c) {
                    var d = a.plotArea.ctx || a.ctx; la = !0; d.clearRect(y.x1,
                      y.y1, y.x2 - y.x1, y.y2 - y.y1); d.fillStyle = a.backgroundColor; d.fillRect(y.x1, y.y1, y.width, y.height); u.changeSection(c, b); var e = {}; e.dataSeries = t; e.dataPoint = t.reversed ? t.dataPoints[w.length - 1 - b] : t.dataPoints[b]; e.index = t.reversed ? w.length - 1 - b : b; a.toolTip.highlightObjects([e]); for (e = 0; e < S.length; e++)x(d, S[e], t.fillOpacity); z(d); P && ("inside" !== t.indexLabelPlacement ? r(d) : g(), C(d)); 1 <= c && (la = !1)
                  }, null, v.easing.easeOutQuart)
                } function l() {
                  for (var a = 0, b = 0; b < S.length - 1; b++)(0 <= ma.indexOf(b) || 0 <= ma.indexOf(b + 1)) &&
                    a++; return a
                } function r(a) { for (var b, c, d, e, g = 0; g < S.length; g++)e = 1 === J[g].lineThickness % 2 ? 0.5 : 0, c = ((S[g].y2 + S[g].y4) / 2 << 0) + e, b = k(c).x2 - 1, d = J[g].textBlock.x, e = (J[g].textBlock.y + J[g].height / 2 << 0) + e, J[g].isDirty || 0 == J[g].lineThickness || (a.strokeStyle = J[g].lineColor, a.lineWidth = J[g].lineThickness, a.setLineDash && a.setLineDash(R(J[g].lineDashType, J[g].lineThickness)), a.beginPath(), a.moveTo(b, c), a.lineTo(d, e), a.stroke()) } function p(a) { for (a -= 1; -1 <= a && -1 != a && J[a].isDirty; a--); return a } function q(a) {
                  for (a +=
                    1; a <= S.length && a != S.length && J[a].isDirty; a++); return a
                } function k(a) { for (var b, c = 0; c < w.length; c++)if (S[c].y1 < a && S[c].y4 > a) { b = S[c]; break } return b ? (a = b.y6 ? a > b.y6 ? b.x3 + (b.x4 - b.x3) / (b.y4 - b.y3) * (a - b.y3) : b.x2 + (b.x3 - b.x2) / (b.y3 - b.y2) * (a - b.y2) : b.x2 + (b.x3 - b.x2) / (b.y3 - b.y2) * (a - b.y2), { x1: a, x2: a }) : -1 } function C(a) { for (var b = 0; b < S.length; b++)J[b].isDirty || (a && (J[b].textBlock.ctx = a), J[b].textBlock.render(!0)) } function z(a) {
                  n.plotArea.layoutManager.reset(); a.roundRect || Ha(a); n.title && (n.title.dockInsidePlotArea ||
                    "center" === n.title.horizontalAlign && "center" === n.title.verticalAlign) && (n.title.ctx = a, n.title.render()); if (n.subtitles) for (var b = 0; b < n.subtitles.length; b++) { var c = n.subtitles[b]; if (c.dockInsidePlotArea || "center" === c.horizontalAlign && "center" === c.verticalAlign) n.subtitles.ctx = a, c.render() } n.legend && (n.legend.dockInsidePlotArea || "center" === n.legend.horizontalAlign && "center" === n.legend.verticalAlign) && (n.legend.ctx = a, n.legend.setLayout(), n.legend.render()); fa.fNg && fa.fNg(n)
                } var n = this; if (!(0 >= a.dataSeriesIndexes.length)) {
                  for (var t =
                    this.data[a.dataSeriesIndexes[0]], w = t.dataPoints, y = this.plotArea, B = 0.025 * y.width, D = 0.01 * y.width, E = 0, H = y.height - 2 * B, G = Math.min(y.width - 2 * D, 2.8 * y.height), P = !1, K = 0; K < w.length; K++)if (!P && ("undefined" !== typeof w[K].indexLabel && null !== w[K].indexLabel && 0 < w[K].indexLabel.toString().length) && (P = !0), !P && ("undefined" !== typeof w[K].label && null !== w[K].label && 0 < w[K].label.toString().length) && (P = !0), !P && "function" === typeof t.indexLabelFormatter || "function" === typeof w[K].indexLabelFormatter) P = !0; P = P || "undefined" !==
                      typeof t.indexLabel && null !== t.indexLabel && 0 < t.indexLabel.toString().length; "inside" !== t.indexLabelPlacement && P || (D = (y.width - 0.75 * G) / 2); var K = y.x1 + D, M = y.x2 - D, N = y.y1 + B, aa = y.y2 - B, Q = a.targetCanvasCtx || this.plotArea.ctx || this.ctx; if (0 != t.length && (t.dataPoints && t.visible) && 0 !== w.length) {
                        var da, I; a = 75 * G / 100; var W = 30 * (M - a) / 100; "funnel" === t.type ? (da = h(t.options.neckHeight) ? 0.35 * H : t.neckHeight, I = h(t.options.neckWidth) ? 0.25 * a : t.neckWidth, "string" === typeof da && da.match(/%$/) ? (da = parseInt(da), da = da * H / 100) : da =
                          parseInt(da), "string" === typeof I && I.match(/%$/) ? (I = parseInt(I), I = I * a / 100) : I = parseInt(I), da > H ? da = H : 0 >= da && (da = 0), I > a ? I = a - 0.5 : 0 >= I && (I = 0)) : "pyramid" === t.type && (I = da = 0, t.reversed = t.reversed ? !1 : !0); var D = K + a / 2, U = K, X = K + a, ta = t.reversed ? aa : N, O = D - I / 2, T = D + I / 2, Z = t.reversed ? N + da : aa - da, xa = t.reversed ? N : aa; a = []; var D = [], S = [], G = [], ba = N, Y, V = (Z - ta) / (O - U), ha = -V, K = "area" === (t.valueRepresents ? t.valueRepresents : "height") ? b() : d(); if (-1 !== K) {
                            if (t.reversed) for (G.push(ba), I = K.length - 1; 0 < I; I--)ba += K[I], G.push(ba); else for (I =
                              0; I < K.length; I++)ba += K[I], G.push(ba); if (t.reversed) for (I = 0; I < K.length; I++)G[I] < Z ? (a.push(O), D.push(T), Y = I) : (a.push((G[I] - ta + V * U) / V), D.push((G[I] - ta + ha * X) / ha)); else for (I = 0; I < K.length; I++)G[I] < Z ? (a.push((G[I] - ta + V * U) / V), D.push((G[I] - ta + ha * X) / ha), Y = I) : (a.push(O), D.push(T)); for (I = 0; I < K.length - 1; I++)ba = t.reversed ? w[w.length - 1 - I].color ? w[w.length - 1 - I].color : t._colorSet[(w.length - 1 - I) % t._colorSet.length] : w[I].color ? w[I].color : t._colorSet[I % t._colorSet.length], I === Y ? S.push({
                                x1: a[I], y1: G[I], x2: D[I], y2: G[I],
                                x3: T, y3: Z, x4: D[I + 1], y4: G[I + 1], x5: a[I + 1], y5: G[I + 1], x6: O, y6: Z, id: I, height: G[I + 1] - G[I], color: ba
                              }) : S.push({ x1: a[I], y1: G[I], x2: D[I], y2: G[I], x3: D[I + 1], y3: G[I + 1], x4: a[I + 1], y4: G[I + 1], id: I, height: G[I + 1] - G[I], color: ba }); var ga = 2, J = [], la = !1, ma = [], ka = [], K = !1; a = a = 0; Ea(ma); for (I = 0; I < w.length; I++)w[I].exploded && (K = !0, t.reversed ? ma.push(w.length - 1 - I) : ma.push(I)); Q.clearRect(y.x1, y.y1, y.width, y.height); Q.fillStyle = n.backgroundColor; Q.fillRect(y.x1, y.y1, y.width, y.height); if (P && t.visible && (c(), g(), e(), "inside" !== t.indexLabelPlacement)) {
                                f();
                                for (I = 0; I < w.length; I++)J[I].isDirty || (a = J[I].textBlock.x + J[I].width, a = (M - a) / 2, 0 == I && (E = a), E > a && (E = a)); for (I = 0; I < S.length; I++)S[I].x1 += E, S[I].x2 += E, S[I].x3 += E, S[I].x4 += E, S[I].x5 && (S[I].x5 += E, S[I].x6 += E), J[I].textBlock.x += E
                              } for (I = 0; I < S.length; I++)E = S[I], x(Q, E, t.fillOpacity), ka.push(E.y1); z(Q); P && t.visible && ("inside" === t.indexLabelPlacement || n.animationEnabled || r(Q), n.animationEnabled || C()); if (!P) for (I = 0; I < w.length; I++)E = t.dataPointIds[I], a = {
                                id: E, objectType: "dataPoint", dataPointIndex: I, dataSeriesIndex: 0,
                                funnelSection: S[t.reversed ? w.length - 1 - I : I]
                              }, n._eventManager.objectMap[E] = a; !n.animationEnabled && K ? m(n, -1, 0) : n.animationEnabled && !n.animatedRender && m(n, -1, 0); this.funnelPyramidClickHandler = function (a) {
                                var b = -1; if (!la && !n.isAnimating && (h(a.dataSeries.explodeOnClick) || a.dataSeries.explodeOnClick) && (b = t.reversed ? w.length - 1 - a.dataPointIndex : a.dataPointIndex, 0 <= b)) {
                                  a = b; if ("funnel" === t.type || "pyramid" === t.type) t.reversed ? w[w.length - 1 - a].exploded = w[w.length - 1 - a].exploded ? !1 : !0 : w[a].exploded = w[a].exploded ?
                                    !1 : !0; m(n, b, 500)
                                }
                              }; return { source: Q, dest: this.plotArea.ctx, animationCallback: function (a, b) { v.fadeInAnimation(a, b); 1 <= a && (m(n, -1, 500), z(n.plotArea.ctx || n.ctx)) }, easingFunction: v.easing.easeInQuad, animationBase: 0 }
                          }
                      }
                }
              }; n.prototype.requestAnimFrame = function () { return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (a) { window.setTimeout(a, 1E3 / 60) } }(); n.prototype.cancelRequestAnimFrame =
                window.cancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || clearTimeout; n.prototype.set = function (a, d, b) { b = "undefined" === typeof b ? !0 : b; "options" === a ? (this.options = d, b && this.render()) : n.base.set.call(this, a, d, b) }; n.prototype.exportChart = function (a) {
                  a = "undefined" === typeof a ? {} : a; var d = a.format ? a.format : "png", b = a.fileName ? a.fileName : this.exportFileName; if (a.toDataURL) return this.canvas.toDataURL("image/" +
                    d); eb(this.canvas, d, b)
                }; n.prototype.print = function () {
                  var a = this.exportChart({ toDataURL: !0 }), d = document.createElement("iframe"); d.setAttribute("class", "canvasjs-chart-print-frame"); d.setAttribute("style", "position:absolute; width:100%; border: 0px; margin: 0px 0px 0px 0px; padding 0px 0px 0px 0px;"); d.style.height = this.height + "px"; this._canvasJSContainer.appendChild(d); var b = this, c = d.contentWindow || d.contentDocument.document || d.contentDocument; c.document.open(); c.document.write('<!DOCTYPE HTML>\n<html><body style="margin: 0px 0px 0px 0px; padding: 0px 0px 0px 0px;"><img src="' +
                    a + '"/><body/></html>'); c.document.close(); setTimeout(function () { c.focus(); c.print(); setTimeout(function () { b._canvasJSContainer.removeChild(d) }, 1E3) }, 500)
                }; n.prototype.getPercentAndTotal = function (a, d) {
                  var b = null, c = null, e = null; if (0 <= a.type.indexOf("stacked")) c = 0, b = d.x.getTime ? d.x.getTime() : d.x, b in a.plotUnit.yTotals && (c = a.plotUnit.yTotals[b], e = isNaN(d.y) ? 0 : 100 * (d.y / c)); else if ("pie" === a.type || "doughnut" === a.type || "funnel" === a.type || "pyramid" === a.type) {
                    for (b = c = 0; b < a.dataPoints.length; b++)isNaN(a.dataPoints[b].y) ||
                      (c += a.dataPoints[b].y); e = isNaN(d.y) ? 0 : 100 * (d.y / c)
                  } return { percent: e, total: c }
                }; n.prototype.replaceKeywordsWithValue = function (a, d, b, c, e) {
                  var g = this; e = "undefined" === typeof e ? 0 : e; if ((0 <= b.type.indexOf("stacked") || "pie" === b.type || "doughnut" === b.type || "funnel" === b.type || "pyramid" === b.type) && (0 <= a.indexOf("#percent") || 0 <= a.indexOf("#total"))) {
                    var f = "#percent", h = "#total", m = this.getPercentAndTotal(b, d), h = isNaN(m.total) ? h : m.total, f = isNaN(m.percent) ? f : m.percent; do {
                      m = ""; if (b.percentFormatString) m = b.percentFormatString;
                      else { var m = "#,##0.", l = Math.max(Math.ceil(Math.log(1 / Math.abs(f)) / Math.LN10), 2); if (isNaN(l) || !isFinite(l)) l = 2; for (var r = 0; r < l; r++)m += "#"; b.percentFormatString = m } a = a.replace("#percent", Z(f, m, g._cultureInfo)); a = a.replace("#total", Z(h, b.yValueFormatString ? b.yValueFormatString : "#,##0.########", g._cultureInfo))
                    } while (0 <= a.indexOf("#percent") || 0 <= a.indexOf("#total"))
                  } return a.replace(/\{.*?\}|"[^"]*"|'[^']*'/g, function (a) {
                    if ('"' === a[0] && '"' === a[a.length - 1] || "'" === a[0] && "'" === a[a.length - 1]) return a.slice(1,
                      a.length - 1); a = Pa(a.slice(1, a.length - 1)); a = a.replace("#index", e); var f = null; try { var k = a.match(/(.*?)\s*\[\s*(.*?)\s*\]/); k && 0 < k.length && (f = Pa(k[2]), a = Pa(k[1])) } catch (l) { } k = null; if ("color" === a) return "waterfall" === b.type ? d.color ? d.color : 0 < d.y ? b.risingColor : b.fallingColor : "error" === b.type ? b.color ? b.color : b._colorSet[f % b._colorSet.length] : d.color ? d.color : b.color ? b.color : b._colorSet[c % b._colorSet.length]; if (d.hasOwnProperty(a)) k = d; else if (b.hasOwnProperty(a)) k = b; else return ""; k = k[a]; null !== f && (k = k[f]);
                    if ("x" === a) if ("dateTime" === b.axisX.valueType || "dateTime" === b.xValueType || d.x && d.x.getTime) { if (g.plotInfo.plotTypes[0].plotUnits[0].axisX && !g.plotInfo.plotTypes[0].plotUnits[0].axisX.logarithmic) return ka(k, d.xValueFormatString ? d.xValueFormatString : b.xValueFormatString ? b.xValueFormatString : b.xValueFormatString = g.axisX && g.axisX.autoValueFormatString ? g.axisX.autoValueFormatString : "DD MMM YY", g._cultureInfo) } else return Z(k, d.xValueFormatString ? d.xValueFormatString : b.xValueFormatString ? b.xValueFormatString :
                      b.xValueFormatString = "#,##0.########", g._cultureInfo); else return "y" === a ? Z(k, d.yValueFormatString ? d.yValueFormatString : b.yValueFormatString ? b.yValueFormatString : b.yValueFormatString = "#,##0.########", g._cultureInfo) : "z" === a ? Z(k, d.zValueFormatString ? d.zValueFormatString : b.zValueFormatString ? b.zValueFormatString : b.zValueFormatString = "#,##0.########", g._cultureInfo) : k
                  })
                }; V(G, K); G.prototype.setLayout = function () {
                  var a = this.dockInsidePlotArea ? this.chart.plotArea : this.chart, d = a.layoutManager.getFreeSpace(),
                    b = null, c = 0, e = 0, g = 0, f = 0, u = this.markerMargin = this.chart.options.legend && !h(this.chart.options.legend.markerMargin) ? this.chart.options.legend.markerMargin : 0.3 * this.fontSize; this.height = 0; var m = [], l = []; "top" === this.verticalAlign || "bottom" === this.verticalAlign ? (this.orientation = "horizontal", b = this.verticalAlign, g = this.maxWidth = null !== this.maxWidth ? this.maxWidth : d.width, f = this.maxHeight = null !== this.maxHeight ? this.maxHeight : 0.5 * d.height) : "center" === this.verticalAlign && (this.orientation = "vertical", b = this.horizontalAlign,
                      g = this.maxWidth = null !== this.maxWidth ? this.maxWidth : 0.5 * d.width, f = this.maxHeight = null !== this.maxHeight ? this.maxHeight : d.height); this.errorMarkerColor = []; for (var r = 0; r < this.dataSeries.length; r++) {
                        var p = this.dataSeries[r]; if (p.dataPoints && p.dataPoints.length) if ("pie" !== p.type && "doughnut" !== p.type && "funnel" !== p.type && "pyramid" !== p.type) {
                          var q = p.legendMarkerType = p.legendMarkerType ? p.legendMarkerType : "line" !== p.type && "stepLine" !== p.type && "spline" !== p.type && "scatter" !== p.type && "bubble" !== p.type || !p.markerType ?
                            "error" === p.type && p._linkedSeries ? p._linkedSeries.legendMarkerType ? p._linkedSeries.legendMarkerType : H.getDefaultLegendMarker(p._linkedSeries.type) : H.getDefaultLegendMarker(p.type) : p.markerType, k = p.legendText ? p.legendText : this.itemTextFormatter ? this.itemTextFormatter({ chart: this.chart, legend: this.options, dataSeries: p, dataPoint: null }) : p.name, x = p.legendMarkerColor = p.legendMarkerColor ? p.legendMarkerColor : p.markerColor ? p.markerColor : "error" === p.type ? h(p.whiskerColor) ? p._colorSet[0] : p.whiskerColor : p._colorSet[0],
                            v = p.markerSize || "line" !== p.type && "stepLine" !== p.type && "spline" !== p.type ? 0.75 * this.lineHeight : 0, z = p.legendMarkerBorderColor ? p.legendMarkerBorderColor : p.markerBorderColor, t = p.legendMarkerBorderThickness ? p.legendMarkerBorderThickness : p.markerBorderThickness ? Math.max(1, Math.round(0.2 * v)) : 0; "error" === p.type && this.errorMarkerColor.push(x); k = this.chart.replaceKeywordsWithValue(k, p.dataPoints[0], p, r); q = {
                              markerType: q, markerColor: x, text: k, textBlock: null, chartType: p.type, markerSize: v, lineColor: p._colorSet[0],
                              dataSeriesIndex: p.index, dataPointIndex: null, markerBorderColor: z, markerBorderThickness: t
                            }; m.push(q)
                        } else for (var s = 0; s < p.dataPoints.length; s++) {
                          var n = p.dataPoints[s], q = n.legendMarkerType ? n.legendMarkerType : p.legendMarkerType ? p.legendMarkerType : H.getDefaultLegendMarker(p.type), k = n.legendText ? n.legendText : p.legendText ? p.legendText : this.itemTextFormatter ? this.itemTextFormatter({ chart: this.chart, legend: this.options, dataSeries: p, dataPoint: n }) : n.name ? n.name : "DataPoint: " + (s + 1), x = n.legendMarkerColor ? n.legendMarkerColor :
                            p.legendMarkerColor ? p.legendMarkerColor : n.color ? n.color : p.color ? p.color : p._colorSet[s % p._colorSet.length], v = 0.75 * this.lineHeight, z = n.legendMarkerBorderColor ? n.legendMarkerBorderColor : p.legendMarkerBorderColor ? p.legendMarkerBorderColor : n.markerBorderColor ? n.markerBorderColor : p.markerBorderColor, t = n.legendMarkerBorderThickness ? n.legendMarkerBorderThickness : p.legendMarkerBorderThickness ? p.legendMarkerBorderThickness : n.markerBorderThickness || p.markerBorderThickness ? Math.max(1, Math.round(0.2 * v)) : 0, k = this.chart.replaceKeywordsWithValue(k,
                              n, p, s), q = { markerType: q, markerColor: x, text: k, textBlock: null, chartType: p.type, markerSize: v, dataSeriesIndex: r, dataPointIndex: s, markerBorderColor: z, markerBorderThickness: t }; (n.showInLegend || p.showInLegend && !1 !== n.showInLegend) && m.push(q)
                        }
                      } !0 === this.reversed && m.reverse(); if (0 < m.length) {
                        p = null; x = k = n = s = 0; n = null !== this.itemWidth ? null !== this.itemMaxWidth ? Math.min(this.itemWidth, this.itemMaxWidth, g) : this.itemMaxWidth = Math.min(this.itemWidth, g) : null !== this.itemMaxWidth ? Math.min(this.itemMaxWidth, g) : this.itemMaxWidth =
                          g; v = 0 === v ? 0.75 * this.lineHeight : v; n -= v + u; for (r = 0; r < m.length; r++) {
                            q = m[r]; z = n; if ("line" === q.chartType || "spline" === q.chartType || "stepLine" === q.chartType) z -= 2 * 0.1 * this.lineHeight; if (!(0 >= f || "undefined" === typeof f || 0 >= z || "undefined" === typeof z)) {
                              if ("horizontal" === this.orientation) {
                                q.textBlock = new ja(this.ctx, {
                                  x: 0, y: 0, maxWidth: z, maxHeight: this.itemWrap ? f : this.lineHeight, angle: 0, text: q.text, horizontalAlign: "left", fontSize: this.fontSize, fontFamily: this.fontFamily, fontWeight: this.fontWeight, fontColor: this.fontColor,
                                  fontStyle: this.fontStyle, textBaseline: "middle"
                                }); q.textBlock.measureText(); null !== this.itemWidth && (q.textBlock.width = this.itemWidth - (v + u + ("line" === q.chartType || "spline" === q.chartType || "stepLine" === q.chartType ? 2 * 0.1 * this.lineHeight : 0))); if (!p || p.width + Math.round(q.textBlock.width + v + u + (0 === p.width ? 0 : this.horizontalSpacing) + ("line" === q.chartType || "spline" === q.chartType || "stepLine" === q.chartType ? 2 * 0.1 * this.lineHeight : 0)) > g) p = { items: [], width: 0 }, l.push(p), this.height += k, k = 0; k = Math.max(k, q.textBlock.height)
                              } else q.textBlock =
                                new ja(this.ctx, { x: 0, y: 0, maxWidth: n, maxHeight: !0 === this.itemWrap ? f : 1.5 * this.fontSize, angle: 0, text: q.text, horizontalAlign: "left", fontSize: this.fontSize, fontFamily: this.fontFamily, fontWeight: this.fontWeight, fontColor: this.fontColor, fontStyle: this.fontStyle, textBaseline: "middle" }), q.textBlock.measureText(), null !== this.itemWidth && (q.textBlock.width = this.itemWidth - (v + u + ("line" === q.chartType || "spline" === q.chartType || "stepLine" === q.chartType ? 2 * 0.1 * this.lineHeight : 0))), this.height < f - this.lineHeight ? (p = {
                                  items: [],
                                  width: 0
                                }, l.push(p)) : (p = l[s], s = (s + 1) % l.length), this.height += q.textBlock.height; q.textBlock.x = p.width; q.textBlock.y = 0; p.width += Math.round(q.textBlock.width + v + u + (0 === p.width ? 0 : this.horizontalSpacing) + ("line" === q.chartType || "spline" === q.chartType || "stepLine" === q.chartType ? 2 * 0.1 * this.lineHeight : 0)); p.items.push(q); this.width = Math.max(p.width, this.width); x = q.textBlock.width + (v + u + ("line" === q.chartType || "spline" === q.chartType || "stepLine" === q.chartType ? 2 * 0.1 * this.lineHeight : 0))
                            }
                          } this.itemWidth = x; this.height =
                            !1 === this.itemWrap ? l.length * this.lineHeight : this.height + k; this.height = Math.min(f, this.height); this.width = Math.min(g, this.width)
                      } "top" === this.verticalAlign ? (e = "left" === this.horizontalAlign ? d.x1 : "right" === this.horizontalAlign ? d.x2 - this.width : d.x1 + d.width / 2 - this.width / 2, c = d.y1) : "center" === this.verticalAlign ? (e = "left" === this.horizontalAlign ? d.x1 : "right" === this.horizontalAlign ? d.x2 - this.width : d.x1 + d.width / 2 - this.width / 2, c = d.y1 + d.height / 2 - this.height / 2) : "bottom" === this.verticalAlign && (e = "left" === this.horizontalAlign ?
                        d.x1 : "right" === this.horizontalAlign ? d.x2 - this.width : d.x1 + d.width / 2 - this.width / 2, c = d.y2 - this.height); this.items = m; for (r = 0; r < this.items.length; r++)q = m[r], q.id = ++this.chart._eventManager.lastObjectId, this.chart._eventManager.objectMap[q.id] = { id: q.id, objectType: "legendItem", legendItemIndex: r, dataSeriesIndex: q.dataSeriesIndex, dataPointIndex: q.dataPointIndex }; this.markerSize = v; this.rows = l; 0 < m.length && a.layoutManager.registerSpace(b, { width: this.width + 2 + 2, height: this.height + 5 + 5 }); this.bounds = {
                          x1: e, y1: c, x2: e +
                            this.width, y2: c + this.height
                        }
                }; G.prototype.render = function () {
                  var a = this.bounds.x1, d = this.bounds.y1, b = this.markerMargin, c = this.maxWidth, e = this.maxHeight, g = this.markerSize, f = this.rows; (0 < this.borderThickness && this.borderColor || this.backgroundColor) && this.ctx.roundRect(a, d, this.width, this.height, this.cornerRadius, this.borderThickness, this.backgroundColor, this.borderColor); for (var h = 0, m = 0; m < f.length; m++) {
                    for (var l = f[m], r = 0, p = 0; p < l.items.length; p++) {
                      var q = l.items[p], k = q.textBlock.x + a + (0 === p ? 0.2 * g : this.horizontalSpacing),
                        x = d + h, v = k; this.chart.data[q.dataSeriesIndex].visible || (this.ctx.globalAlpha = 0.5); this.ctx.save(); this.ctx.beginPath(); this.ctx.rect(a, d, c, Math.max(e - e % this.lineHeight, 0)); this.ctx.clip(); if ("line" === q.chartType || "stepLine" === q.chartType || "spline" === q.chartType) this.ctx.strokeStyle = q.lineColor, this.ctx.lineWidth = Math.ceil(this.lineHeight / 8), this.ctx.beginPath(), this.ctx.moveTo(k - 0.1 * this.lineHeight, x + this.lineHeight / 2), this.ctx.lineTo(k + 0.85 * this.lineHeight, x + this.lineHeight / 2), this.ctx.stroke(), v -=
                          0.1 * this.lineHeight; if ("error" === q.chartType) { this.ctx.strokeStyle = this.errorMarkerColor[0]; this.ctx.lineWidth = g / 8; this.ctx.beginPath(); var n = k - 0.08 * this.lineHeight + 0.1 * this.lineHeight, t = x + 0.15 * this.lineHeight, s = 0.7 * this.lineHeight, w = s + 0.02 * this.lineHeight; this.ctx.moveTo(n, t); this.ctx.lineTo(n + s, t); this.ctx.stroke(); this.ctx.beginPath(); this.ctx.moveTo(n + s / 2, t); this.ctx.lineTo(n + s / 2, t + w); this.ctx.stroke(); this.ctx.beginPath(); this.ctx.moveTo(n, t + w); this.ctx.lineTo(n + s, t + w); this.ctx.stroke(); this.errorMarkerColor.shift() } z.drawMarker(k +
                            g / 2, x + this.lineHeight / 2, this.ctx, q.markerType, "error" === q.chartType || "line" === q.chartType || "spline" === q.chartType ? q.markerSize / 2 : q.markerSize, q.markerColor, q.markerBorderColor, q.markerBorderThickness); q.textBlock.x = k + b + g; if ("line" === q.chartType || "stepLine" === q.chartType || "spline" === q.chartType) q.textBlock.x += 0.1 * this.lineHeight; q.textBlock.y = Math.round(x + this.lineHeight / 2); q.textBlock.render(!0); this.ctx.restore(); r = 0 < p ? Math.max(r, q.textBlock.height) : q.textBlock.height; this.chart.data[q.dataSeriesIndex].visible ||
                              (this.ctx.globalAlpha = 1); k = Q(q.id); this.ghostCtx.fillStyle = k; this.ghostCtx.beginPath(); this.ghostCtx.fillRect(v, q.textBlock.y - this.lineHeight / 2, q.textBlock.x + q.textBlock.width - v, q.textBlock.height); q.x1 = this.chart._eventManager.objectMap[q.id].x1 = v; q.y1 = this.chart._eventManager.objectMap[q.id].y1 = q.textBlock.y - this.lineHeight / 2; q.x2 = this.chart._eventManager.objectMap[q.id].x2 = q.textBlock.x + q.textBlock.width; q.y2 = this.chart._eventManager.objectMap[q.id].y2 = q.textBlock.y + q.textBlock.height - this.lineHeight /
                                2
                    } h += r
                  }
                }; V(H, K); H.prototype.getDefaultAxisPlacement = function () {
                  var a = this.type; if ("column" === a || "line" === a || "stepLine" === a || "spline" === a || "area" === a || "stepArea" === a || "splineArea" === a || "stackedColumn" === a || "stackedLine" === a || "bubble" === a || "scatter" === a || "stackedArea" === a || "stackedColumn100" === a || "stackedLine100" === a || "stackedArea100" === a || "candlestick" === a || "ohlc" === a || "rangeColumn" === a || "rangeArea" === a || "rangeSplineArea" === a || "boxAndWhisker" === a || "waterfall" === a) return "normal"; if ("bar" === a || "stackedBar" ===
                    a || "stackedBar100" === a || "rangeBar" === a) return "xySwapped"; if ("pie" === a || "doughnut" === a || "funnel" === a || "pyramid" === a) return "none"; "error" !== a && window.console.log("Unknown Chart Type: " + a); return null
                }; H.getDefaultLegendMarker = function (a) {
                  if ("column" === a || "stackedColumn" === a || "stackedLine" === a || "bar" === a || "stackedBar" === a || "stackedBar100" === a || "bubble" === a || "scatter" === a || "stackedColumn100" === a || "stackedLine100" === a || "stepArea" === a || "candlestick" === a || "ohlc" === a || "rangeColumn" === a || "rangeBar" === a || "rangeArea" ===
                    a || "rangeSplineArea" === a || "boxAndWhisker" === a || "waterfall" === a) return "square"; if ("line" === a || "stepLine" === a || "spline" === a || "pie" === a || "doughnut" === a) return "circle"; if ("area" === a || "splineArea" === a || "stackedArea" === a || "stackedArea100" === a || "funnel" === a || "pyramid" === a) return "triangle"; if ("error" === a) return "none"; window.console.log("Unknown Chart Type: " + a); return null
                }; H.prototype.getDataPointAtX = function (a, d) {
                  if (!this.dataPoints || 0 === this.dataPoints.length) return null; var b = {
                    dataPoint: null, distance: Infinity,
                    index: NaN
                  }, c = null, e = 0, g = 0, f = 1, h = Infinity, m = 0, l = 0, r = 0; "none" !== this.chart.plotInfo.axisPlacement && (this.axisX.logarithmic ? (r = Math.log(this.dataPoints[this.dataPoints.length - 1].x / this.dataPoints[0].x), r = 1 < r ? Math.min(Math.max((this.dataPoints.length - 1) / r * Math.log(a / this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0) : (r = this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x, r = 0 < r ? Math.min(Math.max((this.dataPoints.length - 1) / r * (a - this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0)); for (; ;) {
                    g =
                      0 < f ? r + e : r - e; if (0 <= g && g < this.dataPoints.length) { var c = this.dataPoints[g], p = this.axisX.logarithmic ? c.x > a ? c.x / a : a / c.x : Math.abs(c.x - a); p < b.distance && (b.dataPoint = c, b.distance = p, b.index = g); c = p; c <= h ? h = c : 0 < f ? m++ : l++; if (1E3 < m && 1E3 < l) break } else if (0 > r - e && r + e >= this.dataPoints.length) break; -1 === f ? (e++, f = 1) : f = -1
                  } return d || (b.dataPoint.x.getTime ? b.dataPoint.x.getTime() : b.dataPoint.x) !== (a.getTime ? a.getTime() : a) ? d && null !== b.dataPoint ? b : null : b
                }; H.prototype.getDataPointAtXY = function (a, d, b) {
                  if (!this.dataPoints || 0 ===
                    this.dataPoints.length || a < this.chart.plotArea.x1 || a > this.chart.plotArea.x2 || d < this.chart.plotArea.y1 || d > this.chart.plotArea.y2) return null; b = b || !1; var c = [], e = 0, g = 0, f = 1, h = !1, m = Infinity, l = 0, r = 0, p = 0; if ("none" !== this.chart.plotInfo.axisPlacement) if (p = (this.chart.axisX[0] ? this.chart.axisX[0] : this.chart.axisX2[0]).getXValueAt({ x: a, y: d }), this.axisX.logarithmic) var q = Math.log(this.dataPoints[this.dataPoints.length - 1].x / this.dataPoints[0].x), p = 1 < q ? Math.min(Math.max((this.dataPoints.length - 1) / q * Math.log(p /
                      this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0; else q = this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x, p = 0 < q ? Math.min(Math.max((this.dataPoints.length - 1) / q * (p - this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0; for (; ;) {
                        g = 0 < f ? p + e : p - e; if (0 <= g && g < this.dataPoints.length) {
                          var q = this.chart._eventManager.objectMap[this.dataPointIds[g]], k = this.dataPoints[g], x = null; if (q) {
                            switch (this.type) {
                              case "column": case "stackedColumn": case "stackedColumn100": case "bar": case "stackedBar": case "stackedBar100": case "rangeColumn": case "rangeBar": case "waterfall": case "error": a >=
                                q.x1 && (a <= q.x2 && d >= q.y1 && d <= q.y2) && (c.push({ dataPoint: k, dataPointIndex: g, dataSeries: this, distance: Math.min(Math.abs(q.x1 - a), Math.abs(q.x2 - a), Math.abs(q.y1 - d), Math.abs(q.y2 - d)) }), h = !0); break; case "line": case "stepLine": case "spline": case "area": case "stepArea": case "stackedArea": case "stackedArea100": case "splineArea": case "scatter": var v = oa("markerSize", k, this) || 4, n = b ? 20 : v, x = Math.sqrt(Math.pow(q.x1 - a, 2) + Math.pow(q.y1 - d, 2)); x <= n && c.push({ dataPoint: k, dataPointIndex: g, dataSeries: this, distance: x }); q =
                                  Math.abs(q.x1 - a); q <= m ? m = q : 0 < f ? l++ : r++; x <= v / 2 && (h = !0); break; case "rangeArea": case "rangeSplineArea": v = oa("markerSize", k, this) || 4; n = b ? 20 : v; x = Math.min(Math.sqrt(Math.pow(q.x1 - a, 2) + Math.pow(q.y1 - d, 2)), Math.sqrt(Math.pow(q.x1 - a, 2) + Math.pow(q.y2 - d, 2))); x <= n && c.push({ dataPoint: k, dataPointIndex: g, dataSeries: this, distance: x }); q = Math.abs(q.x1 - a); q <= m ? m = q : 0 < f ? l++ : r++; x <= v / 2 && (h = !0); break; case "bubble": v = q.size; x = Math.sqrt(Math.pow(q.x1 - a, 2) + Math.pow(q.y1 - d, 2)); x <= v / 2 && (c.push({
                                    dataPoint: k, dataPointIndex: g, dataSeries: this,
                                    distance: x
                                  }), h = !0); break; case "pie": case "doughnut": v = q.center; n = "doughnut" === this.type ? q.percentInnerRadius * q.radius : 0; x = Math.sqrt(Math.pow(v.x - a, 2) + Math.pow(v.y - d, 2)); x < q.radius && x > n && (x = Math.atan2(d - v.y, a - v.x), 0 > x && (x += 2 * Math.PI), x = Number(((180 * (x / Math.PI) % 360 + 360) % 360).toFixed(12)), v = Number(((180 * (q.startAngle / Math.PI) % 360 + 360) % 360).toFixed(12)), n = Number(((180 * (q.endAngle / Math.PI) % 360 + 360) % 360).toFixed(12)), 0 === n && 1 < q.endAngle && (n = 360), v >= n && 0 !== k.y && (n += 360, x < v && (x += 360)), x > v && x < n && (c.push({
                                    dataPoint: k,
                                    dataPointIndex: g, dataSeries: this, distance: 0
                                  }), h = !0)); break; case "funnel": case "pyramid": x = q.funnelSection; d > x.y1 && d < x.y4 && (x.y6 ? d > x.y6 ? (g = x.x6 + (x.x5 - x.x6) / (x.y5 - x.y6) * (d - x.y6), x = x.x3 + (x.x4 - x.x3) / (x.y4 - x.y3) * (d - x.y3)) : (g = x.x1 + (x.x6 - x.x1) / (x.y6 - x.y1) * (d - x.y1), x = x.x2 + (x.x3 - x.x2) / (x.y3 - x.y2) * (d - x.y2)) : (g = x.x1 + (x.x4 - x.x1) / (x.y4 - x.y1) * (d - x.y1), x = x.x2 + (x.x3 - x.x2) / (x.y3 - x.y2) * (d - x.y2)), a > g && a < x && (c.push({ dataPoint: k, dataPointIndex: q.dataPointIndex, dataSeries: this, distance: 0 }), h = !0)); break; case "boxAndWhisker": if (a >=
                                    q.x1 - q.borderThickness / 2 && a <= q.x2 + q.borderThickness / 2 && d >= q.y4 - q.borderThickness / 2 && d <= q.y1 + q.borderThickness / 2 || Math.abs(q.x2 - a + q.x1 - a) < q.borderThickness && d >= q.y1 && d <= q.y4) c.push({ dataPoint: k, dataPointIndex: g, dataSeries: this, distance: Math.min(Math.abs(q.x1 - a), Math.abs(q.x2 - a), Math.abs(q.y2 - d), Math.abs(q.y3 - d)) }), h = !0; break; case "candlestick": if (a >= q.x1 - q.borderThickness / 2 && a <= q.x2 + q.borderThickness / 2 && d >= q.y2 - q.borderThickness / 2 && d <= q.y3 + q.borderThickness / 2 || Math.abs(q.x2 - a + q.x1 - a) < q.borderThickness &&
                                      d >= q.y1 && d <= q.y4) c.push({ dataPoint: k, dataPointIndex: g, dataSeries: this, distance: Math.min(Math.abs(q.x1 - a), Math.abs(q.x2 - a), Math.abs(q.y2 - d), Math.abs(q.y3 - d)) }), h = !0; break; case "ohlc": if (Math.abs(q.x2 - a + q.x1 - a) < q.borderThickness && d >= q.y2 && d <= q.y3 || a >= q.x1 && a <= (q.x2 + q.x1) / 2 && d >= q.y1 - q.borderThickness / 2 && d <= q.y1 + q.borderThickness / 2 || a >= (q.x1 + q.x2) / 2 && a <= q.x2 && d >= q.y4 - q.borderThickness / 2 && d <= q.y4 + q.borderThickness / 2) c.push({
                                        dataPoint: k, dataPointIndex: g, dataSeries: this, distance: Math.min(Math.abs(q.x1 - a),
                                          Math.abs(q.x2 - a), Math.abs(q.y2 - d), Math.abs(q.y3 - d))
                                      }), h = !0
                            }if (h || 1E3 < l && 1E3 < r) break
                          }
                        } else if (0 > p - e && p + e >= this.dataPoints.length) break; -1 === f ? (e++, f = 1) : f = -1
                      } a = null; for (d = 0; d < c.length; d++)a ? c[d].distance <= a.distance && (a = c[d]) : a = c[d]; return a
                }; H.prototype.getMarkerProperties = function (a, d, b, c) {
                  var e = this.dataPoints; return {
                    x: d, y: b, ctx: c, type: e[a].markerType ? e[a].markerType : this.markerType, size: e[a].markerSize ? e[a].markerSize : this.markerSize, color: e[a].markerColor ? e[a].markerColor : this.markerColor ? this.markerColor :
                      e[a].color ? e[a].color : this.color ? this.color : this._colorSet[a % this._colorSet.length], borderColor: e[a].markerBorderColor ? e[a].markerBorderColor : this.markerBorderColor ? this.markerBorderColor : null, borderThickness: e[a].markerBorderThickness ? e[a].markerBorderThickness : this.markerBorderThickness ? this.markerBorderThickness : null
                  }
                }; V(B, K); B.prototype.createExtraLabelsForLog = function (a) {
                  a = (a || 0) + 1; if (!(5 < a)) {
                    var d = this.logLabelValues[0] || this.intervalStartPosition; if (Math.log(this.range) / Math.log(d / this.viewportMinimum) <
                      this.noTicks - 1) { for (var b = B.getNiceNumber((d - this.viewportMinimum) / Math.min(Math.max(2, this.noTicks - this.logLabelValues.length), 3), !0), c = Math.ceil(this.viewportMinimum / b) * b; c < d; c += b)c < this.viewportMinimum || this.logLabelValues.push(c); this.logLabelValues.sort(Xa); this.createExtraLabelsForLog(a) }
                  }
                }; B.prototype.createLabels = function () {
                  var a, d, b = 0, c = 0, e, g = 0, f = 0, c = 0, c = this.interval, u = 0, m, l = 0.6 * this.chart.height, r; a = !1; var p = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [], q = p.length ? h(this.scaleBreaks.firstBreakIndex) ?
                    0 : this.scaleBreaks.firstBreakIndex : 0; if ("axisX" !== this.type || "dateTime" !== this.valueType || this.logarithmic) {
                      e = this.viewportMaximum; if (this.labels) { a = Math.ceil(c); for (var c = Math.ceil(this.intervalStartPosition), k = !1, b = c; b < this.viewportMaximum; b += a)if (this.labels[b]) k = !0; else { k = !1; break } k && (this.interval = a, this.intervalStartPosition = c) } if (this.logarithmic && !this.equidistantInterval) for (this.logLabelValues || (this.logLabelValues = [], this.createExtraLabelsForLog()), c = 0, k = q; c < this.logLabelValues.length; c++)if (b =
                        this.logLabelValues[c], b < this.viewportMinimum) c++; else {
                        for (; k < p.length && b > p[k].endValue; k++); a = k < p.length && b >= p[k].startValue && b <= p[k].endValue; r = b; a || (a = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.options, value: r, label: this.labels[r] ? this.labels[r] : null }) : "axisX" === this.type && this.labels[r] ? this.labels[r] : Z(r, this.valueFormatString, this.chart._cultureInfo), a = new ja(this.ctx, {
                          x: 0, y: 0, maxWidth: g, maxHeight: f, angle: this.labelAngle, text: this.prefix + a + this.suffix, backgroundColor: this.labelBackgroundColor,
                          borderColor: this.labelBorderColor, cornerRadius: this.labelCornerRadius, horizontalAlign: "left", fontSize: this.labelFontSize, fontFamily: this.labelFontFamily, fontWeight: this.labelFontWeight, fontColor: this.labelFontColor, fontStyle: this.labelFontStyle, textBaseline: "middle", borderThickness: 0
                        }), this._labels.push({ position: r, textBlock: a, effectiveHeight: null }))
                      } k = q; for (b = this.intervalStartPosition; b <= e; b = parseFloat(1E-12 > this.interval ? this.logarithmic && this.equidistantInterval ? b * Math.pow(this.logarithmBase,
                        this.interval) : b + this.interval : (this.logarithmic && this.equidistantInterval ? b * Math.pow(this.logarithmBase, this.interval) : b + this.interval).toFixed(12))) {
                        for (; k < p.length && b > p[k].endValue; k++); a = k < p.length && b >= p[k].startValue && b <= p[k].endValue; r = b; a || (a = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.options, value: r, label: this.labels[r] ? this.labels[r] : null }) : "axisX" === this.type && this.labels[r] ? this.labels[r] : Z(r, this.valueFormatString, this.chart._cultureInfo), a = new ja(this.ctx, {
                          x: 0,
                          y: 0, maxWidth: g, maxHeight: f, angle: this.labelAngle, text: this.prefix + a + this.suffix, horizontalAlign: "left", backgroundColor: this.labelBackgroundColor, borderColor: this.labelBorderColor, borderThickness: this.labelBorderThickness, cornerRadius: this.labelCornerRadius, fontSize: this.labelFontSize, fontFamily: this.labelFontFamily, fontWeight: this.labelFontWeight, fontColor: this.labelFontColor, fontStyle: this.labelFontStyle, textBaseline: "middle"
                        }), this._labels.push({ position: r, textBlock: a, effectiveHeight: null }))
                      }
                    } else for (this.intervalStartPosition =
                      this.getLabelStartPoint(new Date(this.viewportMinimum), this.intervalType, this.interval), e = cb(new Date(this.viewportMaximum), this.interval, this.intervalType), k = q, b = this.intervalStartPosition; b < e; cb(b, c, this.intervalType)) {
                    for (a = b.getTime(); k < p.length && a > p[k].endValue; k++); r = a; a = k < p.length && a >= p[k].startValue && a <= p[k].endValue; a || (a = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.options, value: new Date(r), label: this.labels[r] ? this.labels[r] : null }) : "axisX" === this.type && this.labels[r] ?
                      this.labels[r] : ka(r, this.valueFormatString, this.chart._cultureInfo), a = new ja(this.ctx, { x: 0, y: 0, maxWidth: g, backgroundColor: this.labelBackgroundColor, borderColor: this.labelBorderColor, borderThickness: this.labelBorderThickness, cornerRadius: this.labelCornerRadius, maxHeight: f, angle: this.labelAngle, text: this.prefix + a + this.suffix, horizontalAlign: "left", fontSize: this.labelFontSize, fontFamily: this.labelFontFamily, fontWeight: this.labelFontWeight, fontColor: this.labelFontColor, fontStyle: this.labelFontStyle, textBaseline: "middle" }),
                      this._labels.push({ position: r, textBlock: a, effectiveHeight: null, breaksLabelType: void 0 }))
                  } if ("bottom" === this._position || "top" === this._position) u = this.logarithmic && !this.equidistantInterval && 2 <= this._labels.length ? this.lineCoordinates.width * Math.log(Math.min(this._labels[this._labels.length - 1].position / this._labels[this._labels.length - 2].position, this._labels[1].position / this._labels[0].position)) / Math.log(this.range) : this.lineCoordinates.width / (this.logarithmic && this.equidistantInterval ? Math.log(this.range) /
                    Math.log(this.logarithmBase) : Math.abs(this.range)) * U[this.intervalType + "Duration"] * this.interval, g = "undefined" === typeof this.options.labelMaxWidth ? 0.5 * this.chart.width >> 0 : this.options.labelMaxWidth, this.chart.panEnabled || (f = "undefined" === typeof this.options.labelWrap || this.labelWrap ? 0.8 * this.chart.height >> 0 : 1.5 * this.labelFontSize); else if ("left" === this._position || "right" === this._position) u = this.logarithmic && !this.equidistantInterval && 2 <= this._labels.length ? this.lineCoordinates.height * Math.log(Math.min(this._labels[this._labels.length -
                      1].position / this._labels[this._labels.length - 2].position, this._labels[1].position / this._labels[0].position)) / Math.log(this.range) : this.lineCoordinates.height / (this.logarithmic && this.equidistantInterval ? Math.log(this.range) / Math.log(this.logarithmBase) : Math.abs(this.range)) * U[this.intervalType + "Duration"] * this.interval, this.chart.panEnabled || (g = "undefined" === typeof this.options.labelMaxWidth ? 0.3 * this.chart.width >> 0 : this.options.labelMaxWidth), f = "undefined" === typeof this.options.labelWrap || this.labelWrap ?
                        0.3 * this.chart.height >> 0 : 1.5 * this.labelFontSize; for (c = 0; c < this._labels.length; c++) { a = this._labels[c].textBlock; a.maxWidth = g; a.maxHeight = f; var x = a.measureText(); m = x.height } e = []; q = p = 0; if (this.labelAutoFit || this.options.labelAutoFit) if (h(this.labelAngle) || (this.labelAngle = (this.labelAngle % 360 + 360) % 360, 90 < this.labelAngle && 270 > this.labelAngle ? this.labelAngle -= 180 : 270 <= this.labelAngle && 360 >= this.labelAngle && (this.labelAngle -= 360)), "bottom" === this._position || "top" === this._position) if (g = 0.9 * u >> 0, q = 0, !this.chart.panEnabled &&
                          1 <= this._labels.length) {
                          this.sessionVariables.labelFontSize = this.labelFontSize; this.sessionVariables.labelMaxWidth = g; this.sessionVariables.labelMaxHeight = f; this.sessionVariables.labelAngle = this.labelAngle; this.sessionVariables.labelWrap = this.labelWrap; for (b = 0; b < this._labels.length; b++)if (!this._labels[b].breaksLabelType) {
                            a = this._labels[b].textBlock; for (var v, k = a.text.split(" "), c = 0; c < k.length; c++)r = k[c], this.ctx.font = a.fontStyle + " " + a.fontWeight + " " + a.fontSize + "px " + a.fontFamily, r = this.ctx.measureText(r),
                              r.width > q && (v = b, q = r.width)
                          } b = 0; for (b = this.intervalStartPosition < this.viewportMinimum ? 1 : 0; b < this._labels.length; b++)if (!this._labels[b].breaksLabelType) {
                            a = this._labels[b].textBlock; x = a.measureText(); for (k = b + 1; k < this._labels.length; k++)if (!this._labels[k].breaksLabelType) { d = this._labels[k].textBlock; d = d.measureText(); break } e.push(a.height); this.sessionVariables.labelMaxHeight = Math.max.apply(Math, e); Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)); Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)); c = g * Math.sin(Math.PI /
                              180 * Math.abs(this.labelAngle)) + (f - a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)); if (h(this.options.labelAngle) && isNaN(this.options.labelAngle) && 0 !== this.options.labelAngle) if (this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? f : Math.min((c - g * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), c), r = (l - (m + a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(-25))) / Math.sin(Math.PI / 180 * Math.abs(-25)), !h(this.options.labelWrap)) this.labelWrap ? h(this.options.labelMaxWidth) ?
                                (this.sessionVariables.labelMaxWidth = Math.min(Math.max(g, q), r), this.sessionVariables.labelWrap = this.labelWrap, d && x.width + d.width >> 0 > 2 * g && (this.sessionVariables.labelAngle = -25)) : (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelAngle = this.sessionVariables.labelMaxWidth > g ? -25 : this.sessionVariables.labelAngle) : h(this.options.labelMaxWidth) ? (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxHeight =
                                  f, this.sessionVariables.labelMaxWidth = g, d && x.width + d.width >> 0 > 2 * g && (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = r)) : (this.sessionVariables.labelAngle = this.sessionVariables.labelMaxWidth > g ? -25 : this.sessionVariables.labelAngle, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelMaxHeight = f, this.sessionVariables.labelWrap = this.labelWrap); else {
                                if (h(this.options.labelWrap)) if (!h(this.options.labelMaxWidth)) this.options.labelMaxWidth < g ?
                                  (this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelMaxHeight = c) : (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelMaxHeight = f); else if (!h(d)) if (c = x.width + d.width >> 0, k = this.labelFontSize, q < g) c - 2 * g > p && (p = c - 2 * g, c >= 2 * g && c < 2.2 * g ? (this.sessionVariables.labelMaxWidth = g, h(this.options.labelFontSize) && 12 < k && (k = Math.floor(12 / 13 * k), a.measureText()), this.sessionVariables.labelFontSize = h(this.options.labelFontSize) ?
                                    k : this.options.labelFontSize, this.sessionVariables.labelAngle = this.labelAngle) : c >= 2.2 * g && c < 2.8 * g ? (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = r, this.sessionVariables.labelFontSize = k) : c >= 2.8 * g && c < 3.2 * g ? (this.sessionVariables.labelMaxWidth = Math.max(g, q), this.sessionVariables.labelWrap = !0, h(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelFontSize = h(this.options.labelFontSize) ?
                                      k : this.options.labelFontSize, this.sessionVariables.labelAngle = this.labelAngle) : c >= 3.2 * g && c < 3.6 * g ? (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelWrap = !0, this.sessionVariables.labelMaxWidth = r, this.sessionVariables.labelFontSize = this.labelFontSize) : c > 3.6 * g && c < 5 * g ? (h(this.options.labelFontSize) && 12 < k && (k = Math.floor(12 / 13 * k), a.measureText()), this.sessionVariables.labelFontSize = h(this.options.labelFontSize) ? k : this.options.labelFontSize, this.sessionVariables.labelWrap = !0, this.sessionVariables.labelAngle =
                                        -25, this.sessionVariables.labelMaxWidth = r) : c > 5 * g && (this.sessionVariables.labelWrap = !0, this.sessionVariables.labelMaxWidth = g, this.sessionVariables.labelFontSize = k, this.sessionVariables.labelMaxHeight = f, this.sessionVariables.labelAngle = this.labelAngle)); else if (v === b && (0 === v && q + this._labels[v + 1].textBlock.measureText().width - 2 * g > p || v === this._labels.length - 1 && q + this._labels[v - 1].textBlock.measureText().width - 2 * g > p || 0 < v && v < this._labels.length - 1 && q + this._labels[v + 1].textBlock.measureText().width - 2 * g > p &&
                                          q + this._labels[v - 1].textBlock.measureText().width - 2 * g > p)) p = 0 === v ? q + this._labels[v + 1].textBlock.measureText().width - 2 * g : q + this._labels[v - 1].textBlock.measureText().width - 2 * g, this.sessionVariables.labelFontSize = h(this.options.labelFontSize) ? k : this.options.labelFontSize, this.sessionVariables.labelWrap = !0, this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = r; else if (0 === p) for (this.sessionVariables.labelFontSize = h(this.options.labelFontSize) ? k : this.options.labelFontSize, this.sessionVariables.labelWrap =
                                            !0, c = 0; c < this._labels.length; c++)a = this._labels[c].textBlock, a.maxWidth = this.sessionVariables.labelMaxWidth = Math.min(Math.max(g, q), r), x = a.measureText(), c < this._labels.length - 1 && (k = c + 1, d = this._labels[k].textBlock, d.maxWidth = this.sessionVariables.labelMaxWidth = Math.min(Math.max(g, q), r), d = d.measureText(), x.width + d.width >> 0 > 2 * g && (this.sessionVariables.labelAngle = -25))
                              } else (this.sessionVariables.labelAngle = this.labelAngle, this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? f : Math.min((c - g * Math.cos(Math.PI /
                                180 * Math.abs(this.labelAngle))) / Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), c), r = 0 != this.labelAngle ? (l - (m + a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) : g, this.sessionVariables.labelMaxHeight = f = this.labelWrap ? (l - r * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) : 1.5 * this.labelFontSize, h(this.options.labelWrap)) ? h(this.options.labelWrap) && (this.labelWrap && !h(this.options.labelMaxWidth) ?
                                  (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : r, this.sessionVariables.labelMaxHeight = f) : (this.sessionVariables.labelAngle = this.labelAngle, this.sessionVariables.labelMaxWidth = r, this.sessionVariables.labelMaxHeight = c < 0.9 * u ? 0.9 * u : c, this.sessionVariables.labelWrap = this.labelWrap)) : (this.options.labelWrap ? (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ?
                                    this.options.labelMaxWidth : r) : (h(this.options.labelMaxWidth), this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : r, this.sessionVariables.labelWrap = this.labelWrap), this.sessionVariables.labelMaxHeight = f)
                          } for (c = 0; c < this._labels.length; c++)a = this._labels[c].textBlock, a.maxWidth = this.labelMaxWidth = this.sessionVariables.labelMaxWidth, a.fontSize = this.sessionVariables.labelFontSize, a.angle = this.labelAngle = this.sessionVariables.labelAngle, a.wrap = this.labelWrap = this.sessionVariables.labelWrap,
                            a.maxHeight = this.sessionVariables.labelMaxHeight, a.measureText()
                        } else for (b = 0; b < this._labels.length; b++)a = this._labels[b].textBlock, a.maxWidth = this.labelMaxWidth = h(this.options.labelMaxWidth) ? h(this.sessionVariables.labelMaxWidth) ? this.sessionVariables.labelMaxWidth = g : this.sessionVariables.labelMaxWidth : this.options.labelMaxWidth, a.fontSize = this.labelFontSize = h(this.options.labelFontSize) ? h(this.sessionVariables.labelFontSize) ? this.sessionVariables.labelFontSize = this.labelFontSize : this.sessionVariables.labelFontSize :
                          this.options.labelFontSize, a.angle = this.labelAngle = h(this.options.labelAngle) ? h(this.sessionVariables.labelAngle) ? this.sessionVariables.labelAngle = this.labelAngle : this.sessionVariables.labelAngle : this.labelAngle, a.wrap = this.labelWrap = h(this.options.labelWrap) ? h(this.sessionVariables.labelWrap) ? this.sessionVariables.labelWrap = this.labelWrap : this.sessionVariables.labelWrap : this.options.labelWrap, a.maxHeight = h(this.sessionVariables.labelMaxHeight) ? this.sessionVariables.labelMaxHeight = f : this.sessionVariables.labelMaxHeight,
                          a.measureText(); else if ("left" === this._position || "right" === this._position) if (g = h(this.options.labelMaxWidth) ? 0.3 * this.chart.width >> 0 : this.options.labelMaxWidth, f = "undefined" === typeof this.options.labelWrap || this.labelWrap ? 0.3 * this.chart.height >> 0 : 1.5 * this.labelFontSize, !this.chart.panEnabled && 1 <= this._labels.length) {
                            this.sessionVariables.labelFontSize = this.labelFontSize; this.sessionVariables.labelMaxWidth = g; this.sessionVariables.labelMaxHeight = f; this.sessionVariables.labelAngle = h(this.sessionVariables.labelAngle) ?
                              0 : this.sessionVariables.labelAngle; this.sessionVariables.labelWrap = this.labelWrap; for (b = 0; b < this._labels.length; b++)if (!this._labels[b].breaksLabelType) {
                                a = this._labels[b].textBlock; x = a.measureText(); for (k = b + 1; k < this._labels.length; k++)if (!this._labels[k].breaksLabelType) { d = this._labels[k].textBlock; d = d.measureText(); break } e.push(a.height); this.sessionVariables.labelMaxHeight = Math.max.apply(Math, e); c = g * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (f - a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));
                                Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)); Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)); h(this.options.labelAngle) && isNaN(this.options.labelAngle) && 0 !== this.options.labelAngle ? h(this.options.labelWrap) ? h(this.options.labelWrap) && (h(this.options.labelMaxWidth) ? h(d) || (u = x.height + d.height >> 0, u - 2 * f > q && (q = u - 2 * f, u >= 2 * f && u < 2.4 * f ? (h(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelMaxHeight = f, this.sessionVariables.labelFontSize =
                                  h(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize) : u >= 2.4 * f && u < 2.8 * f ? (this.sessionVariables.labelMaxHeight = c, this.sessionVariables.labelFontSize = this.labelFontSize, this.sessionVariables.labelWrap = !0) : u >= 2.8 * f && u < 3.2 * f ? (this.sessionVariables.labelMaxHeight = f, this.sessionVariables.labelWrap = !0, h(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelFontSize = h(this.options.labelFontSize) ?
                                    this.labelFontSize : this.options.labelFontSize, this.sessionVariables.labelAngle = h(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle) : u >= 3.2 * f && u < 3.6 * f ? (this.sessionVariables.labelMaxHeight = c, this.sessionVariables.labelWrap = !0, this.sessionVariables.labelFontSize = this.labelFontSize) : u > 3.6 * f && u < 10 * f ? (h(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelFontSize = h(this.options.labelFontSize) ?
                                      this.labelFontSize : this.options.labelFontSize, this.sessionVariables.labelMaxWidth = g, this.sessionVariables.labelMaxHeight = f, this.sessionVariables.labelAngle = h(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle) : u > 10 * f && u < 50 * f && (h(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelFontSize = h(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize, this.sessionVariables.labelMaxHeight =
                                        f, this.sessionVariables.labelMaxWidth = g, this.sessionVariables.labelAngle = h(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle))) : (this.sessionVariables.labelMaxHeight = f, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth)) : (this.sessionVariables.labelMaxWidth = this.labelWrap ? this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth : this.labelMaxWidth ? this.options.labelMaxWidth ?
                                          this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth : g, this.sessionVariables.labelMaxHeight = f) : (this.sessionVariables.labelAngle = this.labelAngle, this.sessionVariables.labelMaxWidth = 0 === this.labelAngle ? g : Math.min((c - f * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)), f), h(this.options.labelWrap)) ? h(this.options.labelWrap) && (this.labelWrap && !h(this.options.labelMaxWidth) ? (this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth >
                                            this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth, this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxHeight = c) : (this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : g, this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? f : c, h(this.options.labelMaxWidth) && (this.sessionVariables.labelAngle = this.labelAngle))) : this.options.labelWrap ? (this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? f : c, this.sessionVariables.labelWrap =
                                              this.labelWrap, this.sessionVariables.labelMaxWidth = g) : (this.sessionVariables.labelMaxHeight = f, h(this.options.labelMaxWidth), this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth, this.sessionVariables.labelWrap = this.labelWrap)
                              } for (c = 0; c < this._labels.length; c++)a = this._labels[c].textBlock, a.maxWidth = this.labelMaxWidth = this.sessionVariables.labelMaxWidth, a.fontSize = this.labelFontSize = this.sessionVariables.labelFontSize, a.angle = this.labelAngle =
                                this.sessionVariables.labelAngle, a.wrap = this.labelWrap = this.sessionVariables.labelWrap, a.maxHeight = this.sessionVariables.labelMaxHeight, a.measureText()
                          } else for (b = 0; b < this._labels.length; b++)a = this._labels[b].textBlock, a.maxWidth = this.labelMaxWidth = h(this.options.labelMaxWidth) ? h(this.sessionVariables.labelMaxWidth) ? this.sessionVariables.labelMaxWidth = g : this.sessionVariables.labelMaxWidth : this.options.labelMaxWidth, a.fontSize = this.labelFontSize = h(this.options.labelFontSize) ? h(this.sessionVariables.labelFontSize) ?
                            this.sessionVariables.labelFontSize = this.labelFontSize : this.sessionVariables.labelFontSize : this.options.labelFontSize, a.angle = this.labelAngle = h(this.options.labelAngle) ? h(this.sessionVariables.labelAngle) ? this.sessionVariables.labelAngle = this.labelAngle : this.sessionVariables.labelAngle : this.labelAngle, a.wrap = this.labelWrap = h(this.options.labelWrap) ? h(this.sessionVariables.labelWrap) ? this.sessionVariables.labelWrap = this.labelWrap : this.sessionVariables.labelWrap : this.options.labelWrap, a.maxHeight = h(this.sessionVariables.labelMaxHeight) ?
                              this.sessionVariables.labelMaxHeight = f : this.sessionVariables.labelMaxHeight, a.measureText(); for (b = 0; b < this.stripLines.length; b++) {
                                var g = this.stripLines[b], n; if ("outside" === g.labelPlacement) {
                                  f = this.sessionVariables.labelMaxWidth; if ("bottom" === this._position || "top" === this._position) n = h(g.options.labelWrap) ? this.sessionVariables.labelMaxHeight : g.labelWrap ? 0.8 * this.chart.height >> 0 : 1.5 * this.labelFontSize; if ("left" === this._position || "right" === this._position) n = h(g.options.labelWrap) ? this.sessionVariables.labelMaxHeight :
                                    g.labelWrap ? 0.8 * this.chart.width >> 0 : 1.5 * this.labelFontSize; h(g.labelBackgroundColor) && (g.labelBackgroundColor = "#EEEEEE")
                                } else f = "bottom" === this._position || "top" === this._position ? 0.9 * this.chart.width >> 0 : 0.9 * this.chart.height >> 0, n = h(g.options.labelWrap) || g.labelWrap ? "bottom" === this._position || "top" === this._position ? 0.8 * this.chart.width >> 0 : 0.8 * this.chart.height >> 0 : 1.5 * this.labelFontSize, h(g.labelBackgroundColor) && (h(g.startValue) && 0 !== g.startValue ? g.labelBackgroundColor = s ? "transparent" : null : g.labelBackgroundColor =
                                  "#EEEEEE"); a = new ja(this.ctx, {
                                    x: 0, y: 0, backgroundColor: g.labelBackgroundColor, borderColor: g.labelBorderColor, borderThickness: g.labelBorderThickness, cornerRadius: g.labelCornerRadius, maxWidth: g.options.labelMaxWidth ? g.options.labelMaxWidth : f, maxHeight: n, angle: this.labelAngle, text: g.labelFormatter ? g.labelFormatter({ chart: this.chart, axis: this, stripLine: g }) : g.label, horizontalAlign: "left", fontSize: "outside" === g.labelPlacement ? g.options.labelFontSize ? g.labelFontSize : this.labelFontSize : g.labelFontSize, fontFamily: "outside" ===
                                      g.labelPlacement ? g.options.labelFontFamily ? g.labelFontFamily : this.labelFontFamily : g.labelFontFamily, fontWeight: "outside" === g.labelPlacement ? g.options.labelFontWeight ? g.labelFontWeight : this.labelFontWeight : g.labelFontWeight, fontColor: g.labelFontColor || g.color, fontStyle: "outside" === g.labelPlacement ? g.options.labelFontStyle ? g.labelFontStyle : this.fontWeight : g.labelFontStyle, textBaseline: "middle"
                                  }); this._stripLineLabels.push({ position: g.value, textBlock: a, effectiveHeight: null, stripLine: g })
                              }
                }; B.prototype.createLabelsAndCalculateWidth =
                  function () {
                    var a = 0, d = 0; this._labels = []; this._stripLineLabels = []; var b = this.chart.isNavigator ? 0 : 5; if ("left" === this._position || "right" === this._position) {
                      this.createLabels(); if ("inside" != this.labelPlacement || "inside" === this.labelPlacement && 0 < this._index) for (d = 0; d < this._labels.length; d++) {
                        var c = this._labels[d].textBlock, e = c.measureText(), g = 0, g = 0 === this.labelAngle ? e.width : e.width * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) + (e.height - c.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)); a < g &&
                          (a = g); this._labels[d].effectiveWidth = g
                      } for (d = 0; d < this._stripLineLabels.length; d++)"outside" === this._stripLineLabels[d].stripLine.labelPlacement && (this._stripLineLabels[d].stripLine.value >= this.viewportMinimum && this._stripLineLabels[d].stripLine.value <= this.viewportMaximum) && (c = this._stripLineLabels[d].textBlock, e = c.measureText(), g = 0 === this.labelAngle ? e.width : e.width * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) + (e.height - c.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), a < g && (a = g), this._stripLineLabels[d].effectiveWidth =
                        g)
                    } return (this.title ? this._titleTextBlock.measureText().height + 2 : 0) + a + ("inside" === this.tickPlacement ? 0 : this.tickLength) + b
                  }; B.prototype.createLabelsAndCalculateHeight = function () {
                    var a = 0; this._labels = []; this._stripLineLabels = []; var d, b = 0, c = this.chart.isNavigator ? 0 : 5; if ("bottom" === this._position || "top" === this._position) {
                      this.createLabels(); if ("inside" != this.labelPlacement || "inside" === this.labelPlacement && 0 < this._index) for (b = 0; b < this._labels.length; b++) {
                        d = this._labels[b].textBlock; var e = d.measureText(),
                          g = 0, g = 0 === this.labelAngle ? e.height : e.width * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (e.height - d.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)); a < g && (a = g); this._labels[b].effectiveHeight = g
                      } for (b = 0; b < this._stripLineLabels.length; b++)"outside" === this._stripLineLabels[b].stripLine.labelPlacement && (this._stripLineLabels[b].stripLine.value >= this.viewportMinimum && this._stripLineLabels[b].stripLine.value <= this.viewportMaximum) && (d = this._stripLineLabels[b].textBlock, e = d.measureText(), g =
                        0 === this.labelAngle ? e.height : e.width * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (e.height - d.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)), a < g && (a = g), this._stripLineLabels[b].effectiveHeight = g)
                    } return (this.title ? this._titleTextBlock.measureText().height + 2 : 0) + a + ("inside" === this.tickPlacement ? 0 : this.tickLength) + c
                  }; B.setLayout = function (a, d, b, c, e, g) {
                    var f, u, m, l, r = a[0] ? a[0].chart : d[0].chart, p = r.isNavigator ? 0 : 10, q = r._axes; if (a && 0 < a.length) for (var k = 0; k < a.length; k++)a[k] && a[k].calculateAxisParameters();
                    if (d && 0 < d.length) for (k = 0; k < d.length; k++)d[k].calculateAxisParameters(); if (b && 0 < b.length) for (k = 0; k < b.length; k++)b[k].calculateAxisParameters(); if (c && 0 < c.length) for (k = 0; k < c.length; k++)c[k].calculateAxisParameters(); for (k = 0; k < q.length; k++)if (q[k] && q[k].scaleBreaks && q[k].scaleBreaks._appliedBreaks.length) for (var x = q[k].scaleBreaks._appliedBreaks, v = 0; v < x.length && !(x[v].startValue > q[k].viewportMaximum); v++)x[v].endValue < q[k].viewportMinimum || (h(q[k].scaleBreaks.firstBreakIndex) && (q[k].scaleBreaks.firstBreakIndex =
                      v), x[v].startValue >= q[k].viewPortMinimum && (q[k].scaleBreaks.lastBreakIndex = v)); for (var n = v = 0, t = 0, s = 0, z = 0, w = 0, y = 0, B, D, G = u = 0, H, K, M, x = H = K = M = !1, k = 0; k < q.length; k++)q[k] && q[k].title && (q[k]._titleTextBlock = new ja(q[k].ctx, {
                        text: q[k].title, horizontalAlign: "center", fontSize: q[k].titleFontSize, fontFamily: q[k].titleFontFamily, fontWeight: q[k].titleFontWeight, fontColor: q[k].titleFontColor, fontStyle: q[k].titleFontStyle, borderColor: q[k].titleBorderColor, borderThickness: q[k].titleBorderThickness, backgroundColor: q[k].titleBackgroundColor,
                        cornerRadius: q[k].titleCornerRadius, textBaseline: "top"
                      })); for (k = 0; k < q.length; k++)if (q[k].title) switch (q[k]._position) {
                        case "left": q[k]._titleTextBlock.maxWidth = q[k].titleMaxWidth || g.height; q[k]._titleTextBlock.maxHeight = q[k].titleWrap ? 0.8 * g.width : 1.5 * q[k].titleFontSize; q[k]._titleTextBlock.angle = -90; break; case "right": q[k]._titleTextBlock.maxWidth = q[k].titleMaxWidth || g.height; q[k]._titleTextBlock.maxHeight = q[k].titleWrap ? 0.8 * g.width : 1.5 * q[k].titleFontSize; q[k]._titleTextBlock.angle = 90; break; default: q[k]._titleTextBlock.maxWidth =
                          q[k].titleMaxWidth || g.width, q[k]._titleTextBlock.maxHeight = q[k].titleWrap ? 0.8 * g.height : 1.5 * q[k].titleFontSize, q[k]._titleTextBlock.angle = 0
                      }if ("normal" === e) {
                        for (var s = [], z = [], w = [], y = [], N = [], aa = [], Q = [], R = []; 4 > v;) {
                          var I = 0, W = 0, U = 0, Z = 0, X = e = 0, O = 0, ba = 0, V = 0, T = 0, S = 0, Y = 0; if (b && 0 < b.length) for (w = [], k = S = 0; k < b.length; k++)w.push(Math.ceil(b[k] ? b[k].createLabelsAndCalculateWidth() : 0)), S += w[k], O += b[k] && !r.isNavigator ? b[k].margin : 0; else w.push(Math.ceil(b[0] ? b[0].createLabelsAndCalculateWidth() : 0)); Q.push(w); if (c &&
                            0 < c.length) for (y = [], k = Y = 0; k < c.length; k++)y.push(Math.ceil(c[k] ? c[k].createLabelsAndCalculateWidth() : 0)), Y += y[k], ba += c[k] ? c[k].margin : 0; else y.push(Math.ceil(c[0] ? c[0].createLabelsAndCalculateWidth() : 0)); R.push(y); f = Math.round(g.x1 + S + O); m = Math.round(g.x2 - Y - ba > r.width - p ? r.width - p : g.x2 - Y - ba); if (a && 0 < a.length) for (s = [], k = V = 0; k < a.length; k++)a[k] && (a[k].lineCoordinates = {}), a[k].lineCoordinates.width = Math.abs(m - f), a[k].title && (a[k]._titleTextBlock.maxWidth = 0 < a[k].titleMaxWidth && a[k].titleMaxWidth < a[k].lineCoordinates.width ?
                              a[k].titleMaxWidth : a[k].lineCoordinates.width), s.push(Math.ceil(a[k] ? a[k].createLabelsAndCalculateHeight() : 0)), V += s[k], e += a[k] && !r.isNavigator ? a[k].margin : 0; else s.push(Math.ceil(a[0] ? a[0].createLabelsAndCalculateHeight() : 0)); N.push(s); if (d && 0 < d.length) for (z = [], k = T = 0; k < d.length; k++)d[k] && (d[k].lineCoordinates = {}), d[k].lineCoordinates.width = Math.abs(m - f), d[k].title && (d[k]._titleTextBlock.maxWidth = 0 < d[k].titleMaxWidth && d[k].titleMaxWidth < d[k].lineCoordinates.width ? d[k].titleMaxWidth : d[k].lineCoordinates.width),
                                z.push(Math.ceil(d[k] ? d[k].createLabelsAndCalculateHeight() : 0)), T += z[k], X += d[k] && !r.isNavigator ? d[k].margin : 0; else z.push(Math.ceil(d[0] ? d[0].createLabelsAndCalculateHeight() : 0)); aa.push(z); if (a && 0 < a.length) for (k = 0; k < a.length; k++)a[k] && (a[k].lineCoordinates.x1 = f, m = Math.round(g.x2 - Y - ba > r.width - p ? r.width - p : g.x2 - Y - ba), a[k]._labels && 1 < a[k]._labels.length && (u = l = 0, l = a[k]._labels[1], u = "dateTime" === a[k].valueType ? a[k]._labels[a[k]._labels.length - 2] : a[k]._labels[a[k]._labels.length - 1], n = l.textBlock.width *
                                  Math.cos(Math.PI / 180 * Math.abs(l.textBlock.angle)) + (l.textBlock.height - u.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(l.textBlock.angle)), t = u.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(u.textBlock.angle)) + (u.textBlock.height - u.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(u.textBlock.angle))), !a[k] || (!a[k].labelAutoFit || h(B) || h(D) || r.isNavigator || r.stockChart) || (u = 0, 0 < a[k].labelAngle ? D + t > m && (u += 0 < a[k].labelAngle ? D + t - m - Y : 0) : 0 > a[k].labelAngle ? B - n < f && B - n < a[k].viewportMinimum && (G = f - (O +
                                    a[k].tickLength + w + B - n + a[k].labelFontSize / 2)) : 0 === a[k].labelAngle && (D + t > m && (u = D + t / 2 - m - Y), B - n < f && B - n < a[k].viewportMinimum && (G = f - O - a[k].tickLength - w - B + n / 2)), a[k].viewportMaximum === a[k].maximum && a[k].viewportMinimum === a[k].minimum && 0 < a[k].labelAngle && 0 < u ? m -= u : a[k].viewportMaximum === a[k].maximum && a[k].viewportMinimum === a[k].minimum && 0 > a[k].labelAngle && 0 < G ? f += G : a[k].viewportMaximum === a[k].maximum && a[k].viewportMinimum === a[k].minimum && 0 === a[k].labelAngle && (0 < G && (f += G), 0 < u && (m -= u))), r.panEnabled ? V = h(r.sessionVariables.axisX.height) ?
                                      r.sessionVariables.axisX.height = V : r.sessionVariables.axisX.height : r.sessionVariables.axisX.height = V, u = Math.round(g.y2 - V - e + I), l = Math.round(g.y2), a[k].lineCoordinates.x2 = m, a[k].lineCoordinates.width = m - f, a[k].lineCoordinates.y1 = u, a[k].lineCoordinates.y2 = u + a[k].lineThickness / 2, "inside" === a[k].labelPlacement && 0 < k && (a[k].lineCoordinates.y1 = a[k].lineCoordinates.y1 + s[k] - (a[k]._titleTextBlock ? a[k]._titleTextBlock.height : 0) - ("inside" === a[k].tickPlacement ? a[k].tickLength : 0), a[k].lineCoordinates.y2 = a[k].lineCoordinates.y1 +
                                        a[k].lineThickness / 2), a[k].bounds = { x1: f, y1: u, x2: m, y2: l - (V + e - s[k] - I), width: m - f, height: l - u }), I += s[k] + a[k].margin; if (d && 0 < d.length) for (k = 0; k < d.length; k++)d[k].lineCoordinates.x1 = Math.round(g.x1 + S + O), d[k].lineCoordinates.x2 = Math.round(g.x2 - Y - ba > r.width - p ? r.width - p : g.x2 - Y - ba), d[k].lineCoordinates.width = Math.abs(m - f), d[k]._labels && 1 < d[k]._labels.length && (l = d[k]._labels[1], u = "dateTime" === d[k].valueType ? d[k]._labels[d[k]._labels.length - 2] : d[k]._labels[d[k]._labels.length - 1], n = l.textBlock.width * Math.cos(Math.PI /
                                          180 * Math.abs(l.textBlock.angle)) + (l.textBlock.height - u.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(l.textBlock.angle)), t = u.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(u.textBlock.angle)) + (u.textBlock.height - u.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(u.textBlock.angle))), r.panEnabled ? T = h(r.sessionVariables.axisX2.height) ? r.sessionVariables.axisX2.height = T : r.sessionVariables.axisX2.height : r.sessionVariables.axisX2.height = T, u = Math.round(g.y1), l = Math.round(g.y2 + d[k].margin), d[k].lineCoordinates.y1 =
                                          u + T + X - W, d[k].lineCoordinates.y2 = u, "inside" === d[k].labelPlacement && 0 < k && (d[k].lineCoordinates.y1 = d[k - 1].bounds.y1 - z[k] + (d[k]._titleTextBlock ? d[k]._titleTextBlock.height : 0)), d[k].bounds = { x1: f, y1: u + (T + X - z[k] - W), x2: m, y2: l, width: m - f, height: l - u }, W += z[k] + d[k].margin; if (b && 0 < b.length) for (k = 0; k < b.length; k++)O = r.isNavigator ? 0 : 10, b[k] && (f = Math.round(a[0] ? a[0].lineCoordinates.x1 : d[0].lineCoordinates.x1), O = b[k]._labels && 0 < b[k]._labels.length ? b[k]._labels[b[k]._labels.length - 1].textBlock.height / 2 : p, u = Math.round(g.y1 +
                                            T + X < Math.max(O, p) ? Math.max(O, p) : g.y1 + T + X), m = Math.round(a[0] ? a[0].lineCoordinates.x1 : d[0].lineCoordinates.x1), O = 0 < a.length ? 0 : b[k]._labels && 0 < b[k]._labels.length ? b[k]._labels[0].textBlock.height / 2 : p, l = Math.round(g.y2 - V - e - O), b[k].lineCoordinates = { x1: f - U, y1: u, x2: m - U, y2: l, height: Math.abs(l - u) }, "inside" === b[k].labelPlacement && 0 < k && (b[k].lineCoordinates.x1 = b[k].lineCoordinates.x1 - (w[k] - b[k]._titleTextBlock ? b[k]._titleTextBlock.height : 0) + ("outside" === b[k].tickPlacement ? b[k].tickLength : 0), b[k].lineCoordinates.x2 =
                                              b[k].lineCoordinates.x1 + b[k].lineThickness / 2), b[k].bounds = { x1: f - (w[k] + U), y1: u, x2: m, y2: l, width: m - f, height: l - u }, b[k].title && (b[k]._titleTextBlock.maxWidth = 0 < b[k].titleMaxWidth && b[k].titleMaxWidth < b[k].lineCoordinates.height ? b[k].titleMaxWidth : b[k].lineCoordinates.height), U += w[k] + b[k].margin); if (c && 0 < c.length) for (k = 0; k < c.length; k++)c[k] && (f = Math.round(a[0] ? a[0].lineCoordinates.x2 : d[0].lineCoordinates.x2), m = Math.round(f), O = c[k]._labels && 0 < c[k]._labels.length ? c[k]._labels[c[k]._labels.length - 1].textBlock.height /
                                                2 : 0, u = Math.round(g.y1 + T + X < Math.max(O, p) ? Math.max(O, p) : g.y1 + T + X), O = 0 < a.length ? 0 : c[k]._labels && 0 < c[k]._labels.length ? c[k]._labels[0].textBlock.height / 2 : 0, l = Math.round(g.y2 - (V + e + O)), c[k].lineCoordinates = { x1: f + Z, y1: u, x2: f + Z, y2: l, height: Math.abs(l - u) }, "inside" === c[k].labelPlacement && 0 < k && (c[k].lineCoordinates.x1 = c[k].lineCoordinates.x1 + (y[k] - c[k]._titleTextBlock ? c[k]._titleTextBlock.height : 0) - ("outside" === c[k].tickPlacement ? c[k].tickLength : 0) - 2, c[k].lineCoordinates.x2 = c[k].lineCoordinates.x1 + c[k].lineThickness /
                                                  2), c[k].bounds = { x1: f, y1: u, x2: m + (y[k] + Z), y2: l, width: m - f, height: l - u }, c[k].title && (c[k]._titleTextBlock.maxWidth = 0 < c[k].titleMaxWidth && c[k].titleMaxWidth < c[k].lineCoordinates.height ? c[k].titleMaxWidth : c[k].lineCoordinates.height), Z += y[k] + c[k].margin); if (a && 0 < a.length) for (k = 0; k < a.length; k++)a[k] && (a[k].calculateValueToPixelConversionParameters(), a[k].calculateBreaksSizeInValues(), a[k]._labels && 1 < a[k]._labels.length && (B = (a[k].logarithmic ? Math.log(a[k]._labels[1].position / a[k].viewportMinimum) / a[k].conversionParameters.lnLogarithmBase :
                                                    a[k]._labels[1].position - a[k].viewportMinimum) * Math.abs(a[k].conversionParameters.pixelPerUnit) + a[k].lineCoordinates.x1, f = a[k]._labels[a[k]._labels.length - ("dateTime" === a[k].valueType ? 2 : 1)].position, f = a[k].getApparentDifference(a[k].viewportMinimum, f), D = a[k].logarithmic ? (1 < f ? Math.log(f) / a[k].conversionParameters.lnLogarithmBase * Math.abs(a[k].conversionParameters.pixelPerUnit) : 0) + a[k].lineCoordinates.x1 : (0 < f ? f * Math.abs(a[k].conversionParameters.pixelPerUnit) : 0) + a[k].lineCoordinates.x1)); if (d && 0 < d.length) for (k =
                                                      0; k < d.length; k++)d[k].calculateValueToPixelConversionParameters(), d[k].calculateBreaksSizeInValues(), d[k]._labels && 1 < d[k]._labels.length && (B = (d[k].logarithmic ? Math.log(d[k]._labels[1].position / d[k].viewportMinimum) / d[k].conversionParameters.lnLogarithmBase : d[k]._labels[1].position - d[k].viewportMinimum) * Math.abs(d[k].conversionParameters.pixelPerUnit) + d[k].lineCoordinates.x1, f = d[k]._labels[d[k]._labels.length - ("dateTime" === d[k].valueType ? 2 : 1)].position, f = d[k].getApparentDifference(d[k].viewportMinimum,
                                                        f), D = d[k].logarithmic ? (1 < f ? Math.log(f) / d[k].conversionParameters.lnLogarithmBase * Math.abs(d[k].conversionParameters.pixelPerUnit) : 0) + d[k].lineCoordinates.x1 : (0 < f ? f * Math.abs(d[k].conversionParameters.pixelPerUnit) : 0) + d[k].lineCoordinates.x1); for (k = 0; k < q.length; k++)"axisY" === q[k].type && (q[k].calculateValueToPixelConversionParameters(), q[k].calculateBreaksSizeInValues()); if (0 < v) {
                                                          if (a && 0 < a.length) for (k = 0; k < a.length; k++)x = N[v - 1][k] === N[v][k] ? !0 : !1; else x = !0; if (d && 0 < d.length) for (k = 0; k < d.length; k++)H = aa[v -
                                                            1][k] === aa[v][k] ? !0 : !1; else H = !0; if (b && 0 < b.length) for (k = 0; k < b.length; k++)K = Q[v - 1][k] === Q[v][k] ? !0 : !1; else K = !0; if (c && 0 < c.length) for (k = 0; k < c.length; k++)M = R[v - 1][k] === R[v][k] ? !0 : !1; else M = !0
                                                        } if (x && H && K && M) break; v++
                        } if (a && 0 < a.length) for (k = 0; k < a.length; k++)a[k].calculateStripLinesThicknessInValues(), a[k].calculateBreaksInPixels(); if (d && 0 < d.length) for (k = 0; k < d.length; k++)d[k].calculateStripLinesThicknessInValues(), d[k].calculateBreaksInPixels(); if (b && 0 < b.length) for (k = 0; k < b.length; k++)b[k].calculateStripLinesThicknessInValues(),
                          b[k].calculateBreaksInPixels(); if (c && 0 < c.length) for (k = 0; k < c.length; k++)c[k].calculateStripLinesThicknessInValues(), c[k].calculateBreaksInPixels()
                      } else {
                      p = []; B = []; G = []; n = []; D = []; t = []; N = []; for (aa = []; 4 > v;) {
                        V = Z = W = U = ba = O = X = e = R = Q = I = T = 0; if (a && 0 < a.length) for (G = [], k = Z = 0; k < a.length; k++)G.push(Math.ceil(a[k] ? a[k].createLabelsAndCalculateWidth() : 0)), Z += G[k], e += a[k] && !r.isNavigator ? a[k].margin : 0; else G.push(Math.ceil(a[0] ? a[0].createLabelsAndCalculateWidth() : 0)); N.push(G); if (d && 0 < d.length) for (n = [], k = V = 0; k < d.length; k++)n.push(Math.ceil(d[k] ?
                          d[k].createLabelsAndCalculateWidth() : 0)), V += n[k], X += d[k] ? d[k].margin : 0; else n.push(Math.ceil(d[0] ? d[0].createLabelsAndCalculateWidth() : 0)); aa.push(n); if (b && 0 < b.length) for (k = 0; k < b.length; k++)b[k].lineCoordinates = {}, f = Math.round(g.x1 + Z + e), m = Math.round(g.x2 - V - X > r.width - 10 ? r.width - 10 : g.x2 - V - X), b[k].labelAutoFit && !h(s) && (0 < !a.length && (f = 0 > b[k].labelAngle ? Math.max(f, s) : 0 === b[k].labelAngle ? Math.max(f, s / 2) : f), 0 < !d.length && (m = 0 < b[k].labelAngle ? m - z / 2 : 0 === b[k].labelAngle ? m - z / 2 : m)), b[k].lineCoordinates.x1 = f,
                            b[k].lineCoordinates.x2 = m, b[k].lineCoordinates.width = Math.abs(m - f), b[k].title && (b[k]._titleTextBlock.maxWidth = 0 < b[k].titleMaxWidth && b[k].titleMaxWidth < b[k].lineCoordinates.width ? b[k].titleMaxWidth : b[k].lineCoordinates.width); if (c && 0 < c.length) for (k = 0; k < c.length; k++)c[k].lineCoordinates = {}, f = Math.round(g.x1 + Z + e), m = Math.round(g.x2 - V - X > c[k].chart.width - 10 ? c[k].chart.width - 10 : g.x2 - V - X), c[k] && c[k].labelAutoFit && !h(w) && (0 < !a.length && (f = 0 < c[k].labelAngle ? Math.max(f, w) : 0 === c[k].labelAngle ? Math.max(f, w / 2) :
                              f), 0 < !d.length && (m -= y / 2)), c[k].lineCoordinates.x1 = f, c[k].lineCoordinates.x2 = m, c[k].lineCoordinates.width = Math.abs(m - f), c[k].title && (c[k]._titleTextBlock.maxWidth = 0 < c[k].titleMaxWidth && c[k].titleMaxWidth < c[k].lineCoordinates.width ? c[k].titleMaxWidth : c[k].lineCoordinates.width); if (b && 0 < b.length) for (p = [], k = U = 0; k < b.length; k++)p.push(Math.ceil(b[k] ? b[k].createLabelsAndCalculateHeight() : 0)), U += p[k] + b[k].margin, O += b[k].margin; else p.push(Math.ceil(b[0] ? b[0].createLabelsAndCalculateHeight() : 0)); D.push(p);
                        if (c && 0 < c.length) for (B = [], k = W = 0; k < c.length; k++)B.push(Math.ceil(c[k] ? c[k].createLabelsAndCalculateHeight() : 0)), W += B[k], ba += c[k].margin; else B.push(Math.ceil(c[0] ? c[0].createLabelsAndCalculateHeight() : 0)); t.push(B); if (b && 0 < b.length) for (k = 0; k < b.length; k++)0 < b[k]._labels.length && (l = b[k]._labels[0], u = b[k]._labels[b[k]._labels.length - 1], s = l.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(l.textBlock.angle)) + (l.textBlock.height - u.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(l.textBlock.angle)), z = u.textBlock.width *
                          Math.cos(Math.PI / 180 * Math.abs(u.textBlock.angle)) + (u.textBlock.height - u.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(u.textBlock.angle))); if (c && 0 < c.length) for (k = 0; k < c.length; k++)c[k] && 0 < c[k]._labels.length && (l = c[k]._labels[0], u = c[k]._labels[c[k]._labels.length - 1], w = l.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(l.textBlock.angle)) + (l.textBlock.height - u.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(l.textBlock.angle)), y = u.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(u.textBlock.angle)) +
                            (u.textBlock.height - u.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(u.textBlock.angle))); if (r.panEnabled) for (k = 0; k < b.length; k++)p[k] = h(r.sessionVariables.axisY.height) ? r.sessionVariables.axisY.height = p[k] : r.sessionVariables.axisY.height; else for (k = 0; k < b.length; k++)r.sessionVariables.axisY.height = p[k]; if (b && 0 < b.length) for (k = b.length - 1; 0 <= k; k--)u = Math.round(g.y2), l = Math.round(g.y2 > b[k].chart.height ? b[k].chart.height : g.y2), b[k].lineCoordinates.y1 = u - (p[k] + b[k].margin + T), b[k].lineCoordinates.y2 =
                              u - (p[k] + b[k].margin + T), "inside" === b[k].labelPlacement && 0 < k && (b[k].lineCoordinates.y1 = b[k].lineCoordinates.y1 + p[k] - (b[k]._titleTextBlock ? b[k]._titleTextBlock.height : 0) - ("inside" === b[k].tickPlacement ? b[k].tickLength : 0), b[k].lineCoordinates.y2 = b[k].lineCoordinates.y1 + b[k].lineThickness / 2), b[k].bounds = { x1: f, y1: u - (p[k] + T + b[k].margin), x2: m, y2: l - (T + b[k].margin), width: m - f, height: p[k] }, b[k].title && (b[k]._titleTextBlock.maxWidth = 0 < b[k].titleMaxWidth && b[k].titleMaxWidth < b[k].lineCoordinates.width ? b[k].titleMaxWidth :
                                b[k].lineCoordinates.width), T += p[k] + b[k].margin; if (c && 0 < c.length) for (k = c.length - 1; 0 <= k; k--)c[k] && (u = Math.round(g.y1), l = Math.round(g.y1 + (B[k] + c[k].margin + I)), c[k].lineCoordinates.y1 = l, c[k].lineCoordinates.y2 = l, "inside" === c[k].labelPlacement && 0 < k && (c[k].lineCoordinates.y1 = l - B[k] + (c[k]._titleTextBlock ? c[k]._titleTextBlock.height : 0)), c[k].bounds = { x1: f, y1: u + (c[k].margin + I), x2: m, y2: l, width: m - f, height: W }, c[k].title && (c[k]._titleTextBlock.maxWidth = 0 < c[k].titleMaxWidth && c[k].titleMaxWidth < c[k].lineCoordinates.width ?
                                  c[k].titleMaxWidth : c[k].lineCoordinates.width), I += B[k] + c[k].margin); if (a && 0 < a.length) for (k = 0; k < a.length; k++) {
                                    O = a[k]._labels && 0 < a[k]._labels.length ? a[k]._labels[0].textBlock.fontSize / 2 : 0; f = Math.round(g.x1 + e); u = c && 0 < c.length ? Math.round(c[0] ? c[0].lineCoordinates.y2 : g.y1 < Math.max(O, 10) ? Math.max(O, 10) : g.y1) : g.y1 < Math.max(O, 10) ? Math.max(O, 10) : g.y1; m = Math.round(g.x1 + Z + e); l = b && 0 < b.length ? Math.round(b[0] ? b[0].lineCoordinates.y1 : g.y2 - U > r.height - Math.max(O, 10) ? r.height - Math.max(O, 10) : g.y2 - U) : g.y2 > r.height - Math.max(O,
                                      10) ? r.height - Math.max(O, 10) : g.y2; if (b && 0 < b.length) for (O = 0; O < b.length; O++)b[O] && b[O].labelAutoFit && (m = 0 > b[O].labelAngle ? Math.max(m, s) : 0 === b[O].labelAngle ? Math.max(m, s / 2) : m, f = 0 > b[O].labelAngle || 0 === b[O].labelAngle ? m - Z : f); if (c && 0 < c.length) for (O = 0; O < c.length; O++)c[O] && c[O].labelAutoFit && (m = c[O].lineCoordinates.x1, f = m - Z); a[k].lineCoordinates = { x1: m - Q, y1: u, x2: m - Q, y2: l, height: Math.abs(l - u) }; "inside" === a[k].labelPlacement && 0 < k && (a[k].lineCoordinates.x1 = a[k].lineCoordinates.x1 - (G[k] - (a[k]._titleTextBlock ? a[k]._titleTextBlock.height :
                                        0)) + ("outside" === a[k].tickPlacement ? a[k].tickLength : 0), a[k].lineCoordinates.x2 = a[k].lineCoordinates.x1 + a[k].lineThickness / 2); a[k].bounds = { x1: m - (G[k] + Q), y1: u, x2: m, y2: l, width: m - f, height: l - u }; a[k].title && (a[k]._titleTextBlock.maxWidth = 0 < a[k].titleMaxWidth && a[k].titleMaxWidth < a[k].lineCoordinates.height ? a[k].titleMaxWidth : a[k].lineCoordinates.height); a[k].calculateValueToPixelConversionParameters(); a[k].calculateBreaksSizeInValues(); Q += G[k] + a[k].margin
                                  } if (d && 0 < d.length) for (k = 0; k < d.length; k++) {
                                    O = d[k]._labels &&
                                      0 < d[k]._labels.length ? d[k]._labels[0].textBlock.fontSize / 2 : 0; f = Math.round(g.x1 - e); u = c && 0 < c.length ? Math.round(c[0] ? c[0].lineCoordinates.y2 : g.y1 < Math.max(O, 10) ? Math.max(O, 10) : g.y1) : g.y1 < Math.max(O, 10) ? Math.max(O, 10) : g.y1; m = Math.round(g.x2 - V - X); l = b && 0 < b.length ? Math.round(b[0] ? b[0].lineCoordinates.y1 : g.y2 - U > r.height - Math.max(O, 10) ? r.height - Math.max(O, 10) : g.y2 - U) : g.y2 > r.height - Math.max(O, 10) ? r.height - Math.max(O, 10) : g.y2; if (b && 0 < b.length) for (O = 0; O < b.length; O++)b[O] && b[O].labelAutoFit && (m = 0 > b[O].labelAngle ?
                                        Math.max(m, s) : 0 === b[O].labelAngle ? Math.max(m, s / 2) : m, f = 0 > b[O].labelAngle || 0 === b[O].labelAngle ? m - V : f); if (c && 0 < c.length) for (O = 0; O < c.length; O++)c[O] && c[O].labelAutoFit && (m = c[O].lineCoordinates.x2, f = m - V); d[k].lineCoordinates = { x1: m + R, y1: u, x2: m + R, y2: l, height: Math.abs(l - u) }; "inside" === d[k].labelPlacement && 0 < k && (d[k].lineCoordinates.x1 = d[k].lineCoordinates.x1 + (n[k] - (d[k]._titleTextBlock ? d[k]._titleTextBlock.height : 0) - 2) - ("outside" === d[k].tickPlacement ? d[k].tickLength : 0), d[k].lineCoordinates.x2 = d[k].lineCoordinates.x1 +
                                          d[k].lineThickness / 2); d[k].bounds = { x1: d[k].lineCoordinates.x1, y1: u, x2: m + n[k] + R, y2: l, width: m - f, height: l - u }; d[k].title && (d[k]._titleTextBlock.maxWidth = 0 < d[k].titleMaxWidth && d[k].titleMaxWidth < d[k].lineCoordinates.height ? d[k].titleMaxWidth : d[k].lineCoordinates.height); d[k].calculateValueToPixelConversionParameters(); d[k].calculateBreaksSizeInValues(); R += n[k] + d[k].margin
                                  } for (k = 0; k < q.length; k++)"axisY" === q[k].type && (q[k].calculateValueToPixelConversionParameters(), q[k].calculateBreaksSizeInValues()); if (0 <
                                    v) { if (a && 0 < a.length) for (k = 0; k < a.length; k++)x = N[v - 1][k] === N[v][k] ? !0 : !1; else x = !0; if (d && 0 < d.length) for (k = 0; k < d.length; k++)H = aa[v - 1][k] === aa[v][k] ? !0 : !1; else H = !0; if (b && 0 < b.length) for (k = 0; k < b.length; k++)K = D[v - 1][k] === D[v][k] ? !0 : !1; else K = !0; if (c && 0 < c.length) for (k = 0; k < c.length; k++)M = t[v - 1][k] === t[v][k] ? !0 : !1; else M = !0 } if (x && H && K && M) break; v++
                      } if (b && 0 < b.length) for (k = 0; k < b.length; k++)b[k].calculateStripLinesThicknessInValues(), b[k].calculateBreaksInPixels(); if (c && 0 < c.length) for (k = 0; k < c.length; k++)c[k].calculateStripLinesThicknessInValues(),
                        c[k].calculateBreaksInPixels(); if (a && 0 < a.length) for (k = 0; k < a.length; k++)a[k].calculateStripLinesThicknessInValues(), a[k].calculateBreaksInPixels(); if (d && 0 < d.length) for (k = 0; k < d.length; k++)d[k].calculateStripLinesThicknessInValues(), d[k].calculateBreaksInPixels()
                    }
                  }; B.render = function (a, d, b, c, e) {
                    var g = a[0] ? a[0].chart : d[0].chart; e = g.ctx; var f = g._axes; g.alignVerticalAxes && g.alignVerticalAxes(); e.save(); e.beginPath(); a[0] && e.rect(5, a[0].bounds.y1, a[0].chart.width - 10, a[0].bounds.height); d[0] && e.rect(5, d[d.length -
                      1].bounds.y1, d[0].chart.width - 10, d[0].bounds.height); e.clip(); if (a && 0 < a.length) for (var h = 0; h < a.length; h++)a[h].renderLabelsTicksAndTitle(); if (d && 0 < d.length) for (h = 0; h < d.length; h++)d[h].renderLabelsTicksAndTitle(); e.restore(); if (b && 0 < b.length) for (h = 0; h < b.length; h++)b[h].renderLabelsTicksAndTitle(); if (c && 0 < c.length) for (h = 0; h < c.length; h++)c[h].renderLabelsTicksAndTitle(); g.preparePlotArea(); g = g.plotArea; e.save(); e.beginPath(); e.rect(g.x1, g.y1, Math.abs(g.x2 - g.x1), Math.abs(g.y2 - g.y1)); e.clip(); if (a && 0 <
                        a.length) for (h = 0; h < f.length; h++)f[h].renderStripLinesOfThicknessType("value"); if (d && 0 < d.length) for (h = 0; h < d.length; h++)d[h].renderStripLinesOfThicknessType("value"); if (b && 0 < b.length) for (h = 0; h < b.length; h++)b[h].renderStripLinesOfThicknessType("value"); if (c && 0 < c.length) for (h = 0; h < c.length; h++)c[h].renderStripLinesOfThicknessType("value"); if (a && 0 < a.length) for (h = 0; h < a.length; h++)a[h].renderInterlacedColors(); if (d && 0 < d.length) for (h = 0; h < d.length; h++)d[h].renderInterlacedColors(); if (b && 0 < b.length) for (h = 0; h <
                          b.length; h++)b[h].renderInterlacedColors(); if (c && 0 < c.length) for (h = 0; h < c.length; h++)c[h].renderInterlacedColors(); e.restore(); if (a && 0 < a.length) for (h = 0; h < a.length; h++)a[h].renderGrid(), s && (a[h].createMask(), a[h].renderBreaksBackground()); if (d && 0 < d.length) for (h = 0; h < d.length; h++)d[h].renderGrid(), s && (d[h].createMask(), d[h].renderBreaksBackground()); if (b && 0 < b.length) for (h = 0; h < b.length; h++)b[h].renderGrid(), s && (b[h].createMask(), b[h].renderBreaksBackground()); if (c && 0 < c.length) for (h = 0; h < c.length; h++)c[h].renderGrid(),
                            s && (c[h].createMask(), c[h].renderBreaksBackground()); if (a && 0 < a.length) for (h = 0; h < a.length; h++)a[h].renderAxisLine(); if (d && 0 < d.length) for (h = 0; h < d.length; h++)d[h].renderAxisLine(); if (b && 0 < b.length) for (h = 0; h < b.length; h++)b[h].renderAxisLine(); if (c && 0 < c.length) for (h = 0; h < c.length; h++)c[h].renderAxisLine(); if (a && 0 < a.length) for (h = 0; h < a.length; h++)a[h].renderStripLinesOfThicknessType("pixel"); if (d && 0 < d.length) for (h = 0; h < d.length; h++)d[h].renderStripLinesOfThicknessType("pixel"); if (b && 0 < b.length) for (h = 0; h < b.length; h++)b[h].renderStripLinesOfThicknessType("pixel");
                    if (c && 0 < c.length) for (h = 0; h < c.length; h++)c[h].renderStripLinesOfThicknessType("pixel")
                  }; B.prototype.calculateStripLinesThicknessInValues = function () {
                    for (var a = 0; a < this.stripLines.length; a++)if (null !== this.stripLines[a].startValue && null !== this.stripLines[a].endValue) {
                      var d = Math.min(this.stripLines[a].startValue, this.stripLines[a].endValue), b = Math.max(this.stripLines[a].startValue, this.stripLines[a].endValue), d = this.getApparentDifference(d, b); this.stripLines[a].value = this.logarithmic ? this.stripLines[a].value *
                        Math.sqrt(Math.log(this.stripLines[a].endValue / this.stripLines[a].startValue) / Math.log(d)) : this.stripLines[a].value + (Math.abs(this.stripLines[a].endValue - this.stripLines[a].startValue) - d) / 2; this.stripLines[a].thickness = d; this.stripLines[a]._thicknessType = "value"
                    }
                  }; B.prototype.calculateBreaksSizeInValues = function () {
                    for (var a = "left" === this._position || "right" === this._position ? this.lineCoordinates.height || this.chart.height : this.lineCoordinates.width || this.chart.width, d = this.scaleBreaks ? this.scaleBreaks._appliedBreaks :
                      [], b = this.conversionParameters.pixelPerUnit || a / (this.logarithmic ? this.conversionParameters.maximum / this.conversionParameters.minimum : this.conversionParameters.maximum - this.conversionParameters.minimum), c = this.scaleBreaks && !h(this.scaleBreaks.options.spacing), e, g = 0; g < d.length; g++)e = c || !h(d[g].options.spacing), d[g].spacing = Va(d[g].spacing, a, 8, e ? 0.1 * a : 8, e ? 0 : 3) << 0, d[g].size = 0 > d[g].spacing ? 0 : Math.abs(d[g].spacing / b), this.logarithmic && (d[g].size = Math.pow(this.logarithmBase, d[g].size))
                  }; B.prototype.calculateBreaksInPixels =
                    function () {
                      if (!(this.scaleBreaks && 0 >= this.scaleBreaks._appliedBreaks.length)) {
                        var a = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : []; a.length && (this.scaleBreaks.firstBreakIndex = this.scaleBreaks.lastBreakIndex = null); for (var d = 0; d < a.length && !(a[d].startValue > this.conversionParameters.maximum); d++)a[d].endValue < this.conversionParameters.minimum || (h(this.scaleBreaks.firstBreakIndex) && (this.scaleBreaks.firstBreakIndex = d), a[d].startValue >= this.conversionParameters.minimum && (a[d].startPixel = this.convertValueToPixel(a[d].startValue),
                          this.scaleBreaks.lastBreakIndex = d), a[d].endValue <= this.conversionParameters.maximum && (a[d].endPixel = this.convertValueToPixel(a[d].endValue)))
                      }
                    }; B.prototype.renderLabelsTicksAndTitle = function () {
                      var a = this, d = !1, b = 0, c = 0, e = 1, g = 0; 0 !== this.labelAngle && 360 !== this.labelAngle && (e = 1.2); if ("undefined" === typeof this.options.interval) {
                        if ("bottom" === this._position || "top" === this._position) if (this.logarithmic && !this.equidistantInterval && this.labelAutoFit) {
                          for (var b = [], e = 0 !== this.labelAngle && 360 !== this.labelAngle ?
                            1 : 1.2, f, h = this.viewportMaximum, m = this.lineCoordinates.width / Math.log(this.range), l = this._labels.length - 1; 0 <= l; l--) { p = this._labels[l]; if (p.position < this.viewportMinimum) break; p.position > this.viewportMaximum || !(l === this._labels.length - 1 || f < Math.log(h / p.position) * m / e) || (b.push(p), h = p.position, f = p.textBlock.width * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + p.textBlock.height * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle))) } this._labels = b
                        } else {
                          for (l = 0; l < this._labels.length; l++)p = this._labels[l], p.position <
                            this.viewportMinimum || (f = p.textBlock.width * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + p.textBlock.height * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)), b += f); b > this.lineCoordinates.width * e && this.labelAutoFit && (d = !0)
                        } if ("left" === this._position || "right" === this._position) if (this.logarithmic && !this.equidistantInterval && this.labelAutoFit) {
                          for (var b = [], r, h = this.viewportMaximum, m = this.lineCoordinates.height / Math.log(this.range), l = this._labels.length - 1; 0 <= l; l--) {
                            p = this._labels[l]; if (p.position < this.viewportMinimum) break;
                            p.position > this.viewportMaximum || !(l === this._labels.length - 1 || r < Math.log(h / p.position) * m) || (b.push(p), h = p.position, r = p.textBlock.height * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + p.textBlock.width * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)))
                          } this._labels = b
                        } else {
                          for (l = 0; l < this._labels.length; l++)p = this._labels[l], p.position < this.viewportMinimum || (r = p.textBlock.height * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + p.textBlock.width * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)), c += r); c > this.lineCoordinates.height *
                            e && this.labelAutoFit && (d = !0)
                        }
                      } this.logarithmic && (!this.equidistantInterval && this.labelAutoFit) && this._labels.sort(function (a, b) { return a.position - b.position }); var l = 0, p, q; if ("bottom" === this._position) {
                        for (l = 0; l < this._labels.length; l++)p = this._labels[l], p.position < this.viewportMinimum || p.position > this.viewportMaximum || (q = this.getPixelCoordinatesOnAxis(p.position), this.tickThickness && "inside" != this.tickPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, c = 1 === this.ctx.lineWidth %
                          2 ? (q.x << 0) + 0.5 : q.x << 0, this.ctx.beginPath(), this.ctx.moveTo(c, q.y << 0), this.ctx.lineTo(c, q.y + this.tickLength << 0), this.ctx.stroke()), d && 0 !== g++ % 2 && this.labelAutoFit || (0 === p.textBlock.angle ? (q.x -= p.textBlock.width / 2, q.y = "inside" === this.labelPlacement ? q.y - (("inside" === this.tickPlacement ? this.tickLength : 0) + p.textBlock.height - p.textBlock.fontSize / 2) : q.y + ("inside" === this.tickPlacement ? 0 : this.tickLength) + p.textBlock.fontSize / 2 + 5) : (q.x = "inside" === this.labelPlacement ? 0 > this.labelAngle ? q.x : q.x - p.textBlock.width *
                            Math.cos(Math.PI / 180 * this.labelAngle) : q.x - (0 > this.labelAngle ? p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0), q.y = "inside" === this.labelPlacement ? 0 > this.labelAngle ? q.y - ("inside" === this.tickPlacement ? this.tickLength : 0) - 5 : q.y - ("inside" === this.tickPlacement ? 0 : this.tickLength) - Math.abs(p.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) + 5) : q.y + ("inside" === this.tickPlacement ? 0 : this.tickLength) + Math.abs(0 > this.labelAngle ? p.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) - 5 : 5)), p.textBlock.x =
                            q.x, p.textBlock.y = q.y)); "inside" === this.tickPlacement && this.chart.addEventListener("dataAnimationEnd", function () {
                              for (l = 0; l < a._labels.length; l++)if (p = a._labels[l], !(p.position < a.viewportMinimum || p.position > a.viewportMaximum) && (q = a.getPixelCoordinatesOnAxis(p.position), a.tickThickness)) {
                                a.ctx.lineWidth = a.tickThickness; a.ctx.strokeStyle = a.tickColor; var b = 1 === a.ctx.lineWidth % 2 ? (q.x << 0) + 0.5 : q.x << 0; a.ctx.save(); a.ctx.beginPath(); a.ctx.moveTo(b, q.y << 0); a.ctx.lineTo(b, q.y - a.tickLength << 0); a.ctx.stroke();
                                a.ctx.restore()
                              }
                            }, this); this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.lineCoordinates.x1 + this.lineCoordinates.width / 2 - this._titleTextBlock.width / 2, this._titleTextBlock.y = this.bounds.y2 - this._titleTextBlock.height - 3, this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(!0))
                      } else if ("top" === this._position) {
                        for (l = 0; l < this._labels.length; l++)p = this._labels[l], p.position < this.viewportMinimum || p.position > this.viewportMaximum || (q = this.getPixelCoordinatesOnAxis(p.position),
                          this.tickThickness && "inside" != this.tickPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, c = 1 === this.ctx.lineWidth % 2 ? (q.x << 0) + 0.5 : q.x << 0, this.ctx.beginPath(), this.ctx.moveTo(c, q.y << 0), this.ctx.lineTo(c, q.y - this.tickLength << 0), this.ctx.stroke()), d && 0 !== g++ % 2 && this.labelAutoFit || (0 === p.textBlock.angle ? (q.x -= p.textBlock.width / 2, q.y = "inside" === this.labelPlacement ? q.y + this.labelFontSize / 2 + ("inside" === this.tickPlacement ? this.tickLength : 0) + 5 : q.y - (("inside" === this.tickPlacement ?
                            0 : this.tickLength) + p.textBlock.height - p.textBlock.fontSize / 2)) : (q.x = "inside" === this.labelPlacement ? 0 < this.labelAngle ? q.x : q.x - p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : q.x + (p.textBlock.height - this.labelFontSize) * Math.sin(Math.PI / 180 * this.labelAngle) - (0 < this.labelAngle ? p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0), q.y = "inside" === this.labelPlacement ? 0 < this.labelAngle ? q.y + ("inside" === this.tickPlacement ? this.tickLength : 0) + 5 : q.y - p.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) +
                              ("inside" === this.tickPlacement ? this.tickLength : 0) + 5 : q.y - (("inside" === this.tickPlacement ? 0 : this.tickLength) + ((p.textBlock.height - p.textBlock.fontSize / 2) * Math.cos(Math.PI / 180 * this.labelAngle) + (0 < this.labelAngle ? p.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : 0)))), p.textBlock.x = q.x, p.textBlock.y = q.y)); "inside" === this.tickPlacement && this.chart.addEventListener("dataAnimationEnd", function () {
                                for (l = 0; l < a._labels.length; l++)if (p = a._labels[l], !(p.position < a.viewportMinimum || p.position > a.viewportMaximum) &&
                                  (q = a.getPixelCoordinatesOnAxis(p.position), a.tickThickness)) { a.ctx.lineWidth = a.tickThickness; a.ctx.strokeStyle = a.tickColor; var b = 1 === a.ctx.lineWidth % 2 ? (q.x << 0) + 0.5 : q.x << 0; a.ctx.save(); a.ctx.beginPath(); a.ctx.moveTo(b, q.y << 0); a.ctx.lineTo(b, q.y + a.tickLength << 0); a.ctx.stroke(); a.ctx.restore() }
                              }, this); this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.lineCoordinates.x1 + this.lineCoordinates.width / 2 - this._titleTextBlock.width / 2, this._titleTextBlock.y = this.bounds.y1 + 1, this.titleMaxWidth =
                                this._titleTextBlock.maxWidth, this._titleTextBlock.render(!0))
                      } else if ("left" === this._position) {
                        for (l = 0; l < this._labels.length; l++)p = this._labels[l], p.position < this.viewportMinimum || p.position > this.viewportMaximum || (q = this.getPixelCoordinatesOnAxis(p.position), this.tickThickness && "inside" != this.tickPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, c = 1 === this.ctx.lineWidth % 2 ? (q.y << 0) + 0.5 : q.y << 0, this.ctx.beginPath(), this.ctx.moveTo(q.x << 0, c), this.ctx.lineTo(q.x - this.tickLength <<
                          0, c), this.ctx.stroke()), d && 0 !== g++ % 2 && this.labelAutoFit || (0 === this.labelAngle ? (p.textBlock.y = q.y, p.textBlock.x = "inside" === this.labelPlacement ? q.x + ("inside" === this.tickPlacement ? this.tickLength : 0) + 5 : q.x - p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - ("inside" === this.tickPlacement ? 0 : this.tickLength) - 5) : (p.textBlock.y = "inside" === this.labelPlacement ? q.y : q.y - p.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle), p.textBlock.x = "inside" === this.labelPlacement ? q.x + ("inside" === this.tickPlacement ?
                            this.tickLength : 0) + 5 : 0 < this.labelAngle ? q.x - p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - ("inside" === this.tickPlacement ? 0 : this.tickLength) - 5 : q.x - p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) + (p.textBlock.height - p.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) - ("inside" === this.tickPlacement ? 0 : this.tickLength)))); "inside" === this.tickPlacement && this.chart.addEventListener("dataAnimationEnd", function () {
                              for (l = 0; l < a._labels.length; l++)if (p = a._labels[l], !(p.position < a.viewportMinimum ||
                                p.position > a.viewportMaximum) && (q = a.getPixelCoordinatesOnAxis(p.position), a.tickThickness)) { a.ctx.lineWidth = a.tickThickness; a.ctx.strokeStyle = a.tickColor; var b = 1 === a.ctx.lineWidth % 2 ? (q.y << 0) + 0.5 : q.y << 0; a.ctx.save(); a.ctx.beginPath(); a.ctx.moveTo(q.x << 0, b); a.ctx.lineTo(q.x + a.tickLength << 0, b); a.ctx.stroke(); a.ctx.restore() }
                            }, this); this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.bounds.x1 + 1, this._titleTextBlock.y = this.lineCoordinates.height / 2 + this._titleTextBlock.width / 2 +
                              this.lineCoordinates.y1, this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(!0))
                      } else if ("right" === this._position) {
                        for (l = 0; l < this._labels.length; l++)p = this._labels[l], p.position < this.viewportMinimum || p.position > this.viewportMaximum || (q = this.getPixelCoordinatesOnAxis(p.position), this.tickThickness && "inside" != this.tickPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, c = 1 === this.ctx.lineWidth % 2 ? (q.y << 0) + 0.5 : q.y << 0, this.ctx.beginPath(), this.ctx.moveTo(q.x <<
                          0, c), this.ctx.lineTo(q.x + this.tickLength << 0, c), this.ctx.stroke()), d && 0 !== g++ % 2 && this.labelAutoFit || (0 === this.labelAngle ? (p.textBlock.y = q.y, p.textBlock.x = "inside" === this.labelPlacement ? q.x - p.textBlock.width - ("inside" === this.tickPlacement ? this.tickLength : 0) - 5 : q.x + ("inside" === this.tickPlacement ? 0 : this.tickLength) + 5) : (p.textBlock.y = "inside" === this.labelPlacement ? q.y - p.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : 0 > this.labelAngle ? q.y : q.y - (p.textBlock.height - p.textBlock.fontSize / 2 - 5) * Math.cos(Math.PI /
                            180 * this.labelAngle), p.textBlock.x = "inside" === this.labelPlacement ? q.x - p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - ("inside" === this.tickPlacement ? this.tickLength : 0) - 5 : 0 < this.labelAngle ? q.x + (p.textBlock.height - p.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) + ("inside" === this.tickPlacement ? 0 : this.tickLength) : q.x + ("inside" === this.tickPlacement ? 0 : this.tickLength) + 5))); "inside" === this.tickPlacement && this.chart.addEventListener("dataAnimationEnd", function () {
                              for (l = 0; l < a._labels.length; l++)if (p =
                                a._labels[l], !(p.position < a.viewportMinimum || p.position > a.viewportMaximum) && (q = a.getPixelCoordinatesOnAxis(p.position), a.tickThickness)) { a.ctx.lineWidth = a.tickThickness; a.ctx.strokeStyle = a.tickColor; var b = 1 === a.ctx.lineWidth % 2 ? (q.y << 0) + 0.5 : q.y << 0; a.ctx.save(); a.ctx.beginPath(); a.ctx.moveTo(q.x << 0, b); a.ctx.lineTo(q.x - a.tickLength << 0, b); a.ctx.stroke(); a.ctx.restore() }
                            }, this); this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.bounds.x2 - 1, this._titleTextBlock.y = this.lineCoordinates.height /
                              2 - this._titleTextBlock.width / 2 + this.lineCoordinates.y1, this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(!0))
                      } g = 0; if ("inside" === this.labelPlacement) this.chart.addEventListener("dataAnimationEnd", function () { for (l = 0; l < a._labels.length; l++)p = a._labels[l], p.position < a.viewportMinimum || (p.position > a.viewportMaximum || d && 0 !== g++ % 2 && a.labelAutoFit) || (a.ctx.save(), a.ctx.beginPath(), p.textBlock.render(!0), a.ctx.restore()) }, this); else for (l = 0; l < this._labels.length; l++)p = this._labels[l],
                        p.position < this.viewportMinimum || (p.position > this.viewportMaximum || d && 0 !== g++ % 2 && this.labelAutoFit) || p.textBlock.render(!0)
                    }; B.prototype.renderInterlacedColors = function () {
                      var a = this.chart.plotArea.ctx, d, b, c = this.chart.plotArea, e = 0; d = !0; if (("bottom" === this._position || "top" === this._position) && this.interlacedColor) for (a.fillStyle = this.interlacedColor, e = 0; e < this._labels.length; e++)d ? (d = this.getPixelCoordinatesOnAxis(this._labels[e].position), b = e + 1 > this._labels.length - 1 ? this.getPixelCoordinatesOnAxis(this.viewportMaximum) :
                        this.getPixelCoordinatesOnAxis(this._labels[e + 1].position), a.fillRect(Math.min(b.x, d.x), c.y1, Math.abs(b.x - d.x), Math.abs(c.y1 - c.y2)), d = !1) : d = !0; else if (("left" === this._position || "right" === this._position) && this.interlacedColor) for (a.fillStyle = this.interlacedColor, e = 0; e < this._labels.length; e++)d ? (b = this.getPixelCoordinatesOnAxis(this._labels[e].position), d = e + 1 > this._labels.length - 1 ? this.getPixelCoordinatesOnAxis(this.viewportMaximum) : this.getPixelCoordinatesOnAxis(this._labels[e + 1].position), a.fillRect(c.x1,
                          Math.min(b.y, d.y), Math.abs(c.x1 - c.x2), Math.abs(d.y - b.y)), d = !1) : d = !0; a.beginPath()
                    }; B.prototype.renderStripLinesOfThicknessType = function (a) {
                      if (this.stripLines && 0 < this.stripLines.length && a) {
                        for (var d = this, b, c = 0, e = 0, g = !1, f = !1, m = [], x = [], f = !1, c = 0; c < this.stripLines.length; c++) { var l = this.stripLines[c]; l._thicknessType === a && ("pixel" === a && (l.value < this.viewportMinimum || l.value > this.viewportMaximum || h(l.value) || isNaN(this.range)) || m.push(l)) } for (c = 0; c < this._stripLineLabels.length; c++)if (l = this.stripLines[c],
                          b = this._stripLineLabels[c], !(b.position < this.viewportMinimum || b.position > this.viewportMaximum || isNaN(this.range))) {
                          a = this.getPixelCoordinatesOnAxis(b.position); if ("outside" === b.stripLine.labelPlacement) if (l && (this.ctx.strokeStyle = l.color, "pixel" === l._thicknessType && (this.ctx.lineWidth = l.thickness)), "bottom" === this._position) {
                            var r = 1 === this.ctx.lineWidth % 2 ? (a.x << 0) + 0.5 : a.x << 0; this.ctx.beginPath(); this.ctx.moveTo(r, a.y << 0); this.ctx.lineTo(r, a.y + this.tickLength << 0); this.ctx.stroke(); 0 === this.labelAngle ?
                              (a.x -= b.textBlock.width / 2, a.y += this.tickLength + b.textBlock.fontSize / 2) : (a.x -= 0 > this.labelAngle ? b.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0, a.y += this.tickLength + Math.abs(0 > this.labelAngle ? b.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) - 5 : 5))
                          } else "top" === this._position ? (r = 1 === this.ctx.lineWidth % 2 ? (a.x << 0) + 0.5 : a.x << 0, this.ctx.beginPath(), this.ctx.moveTo(r, a.y << 0), this.ctx.lineTo(r, a.y - this.tickLength << 0), this.ctx.stroke(), 0 === this.labelAngle ? (a.x -= b.textBlock.width / 2, a.y -= this.tickLength +
                            b.textBlock.height) : (a.x += (b.textBlock.height - this.tickLength - this.labelFontSize / 2) * Math.sin(Math.PI / 180 * this.labelAngle) - (0 < this.labelAngle ? b.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0), a.y -= this.tickLength + (b.textBlock.height * Math.cos(Math.PI / 180 * this.labelAngle) + (0 < this.labelAngle ? b.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : 0)))) : "left" === this._position ? (r = 1 === this.ctx.lineWidth % 2 ? (a.y << 0) + 0.5 : a.y << 0, this.ctx.beginPath(), this.ctx.moveTo(a.x << 0, r), this.ctx.lineTo(a.x - this.tickLength <<
                              0, r), this.ctx.stroke(), 0 === this.labelAngle ? a.x = a.x - b.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5 : (a.y -= b.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle), a.x = 0 < this.labelAngle ? a.x - b.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5 : a.x - b.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) + (b.textBlock.height - b.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) - this.tickLength)) : "right" === this._position && (r = 1 === this.ctx.lineWidth %
                                2 ? (a.y << 0) + 0.5 : a.y << 0, this.ctx.beginPath(), this.ctx.moveTo(a.x << 0, r), this.ctx.lineTo(a.x + this.tickLength << 0, r), this.ctx.stroke(), 0 === this.labelAngle ? a.x = a.x + this.tickLength + 5 : (a.y = 0 > this.labelAngle ? a.y : a.y - (b.textBlock.height - b.textBlock.fontSize / 2 - 5) * Math.cos(Math.PI / 180 * this.labelAngle), a.x = 0 < this.labelAngle ? a.x + (b.textBlock.height - b.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) + this.tickLength : a.x + this.tickLength + 5)); else b.textBlock.angle = -90, "bottom" === this._position ? (b.textBlock.maxWidth =
                                  this.options.stripLines[c].labelMaxWidth ? this.options.stripLines[c].labelMaxWidth : this.chart.plotArea.height - 3, b.textBlock.measureText(), a.x - b.textBlock.height > this.chart.plotArea.x1 ? h(l.startValue) ? a.x -= b.textBlock.height - b.textBlock.fontSize / 2 : a.x -= b.textBlock.height / 2 - b.textBlock.fontSize / 2 + 3 : (b.textBlock.angle = 90, h(l.startValue) ? a.x += b.textBlock.height - b.textBlock.fontSize / 2 : a.x += b.textBlock.height / 2 - b.textBlock.fontSize / 2 + 3), a.y = -90 === b.textBlock.angle ? "near" === b.stripLine.labelAlign ? this.chart.plotArea.y2 -
                                    3 : "center" === b.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 + b.textBlock.width) / 2 : this.chart.plotArea.y1 + b.textBlock.width + 3 : "near" === b.stripLine.labelAlign ? this.chart.plotArea.y2 - b.textBlock.width - 3 : "center" === b.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 - b.textBlock.width) / 2 : this.chart.plotArea.y1 + 3) : "top" === this._position ? (b.textBlock.maxWidth = this.options.stripLines[c].labelMaxWidth ? this.options.stripLines[c].labelMaxWidth : this.chart.plotArea.height -
                                      3, b.textBlock.measureText(), a.x - b.textBlock.height > this.chart.plotArea.x1 ? h(l.startValue) ? a.x -= b.textBlock.height - b.textBlock.fontSize / 2 : a.x -= b.textBlock.height / 2 - b.textBlock.fontSize / 2 + 3 : (b.textBlock.angle = 90, h(l.startValue) ? a.x += b.textBlock.height - b.textBlock.fontSize / 2 : a.x += b.textBlock.height / 2 - b.textBlock.fontSize / 2 + 3), a.y = -90 === b.textBlock.angle ? "near" === b.stripLine.labelAlign ? this.chart.plotArea.y1 + b.textBlock.width + 3 : "center" === b.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 +
                                        b.textBlock.width) / 2 : this.chart.plotArea.y2 - 3 : "near" === b.stripLine.labelAlign ? this.chart.plotArea.y1 + 3 : "center" === b.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 - b.textBlock.width) / 2 : this.chart.plotArea.y2 - b.textBlock.width - 3) : "left" === this._position ? (b.textBlock.maxWidth = this.options.stripLines[c].labelMaxWidth ? this.options.stripLines[c].labelMaxWidth : this.chart.plotArea.width - 3, b.textBlock.angle = 0, b.textBlock.measureText(), a.y - b.textBlock.height > this.chart.plotArea.y1 ? h(l.startValue) ?
                                          a.y -= b.textBlock.height - b.textBlock.fontSize / 2 : a.y -= b.textBlock.height / 2 - b.textBlock.fontSize + 3 : a.y - b.textBlock.height < this.chart.plotArea.y2 ? a.y += b.textBlock.fontSize / 2 + 3 : h(l.startValue) ? a.y -= b.textBlock.height - b.textBlock.fontSize / 2 : a.y -= b.textBlock.height / 2 - b.textBlock.fontSize + 3, a.x = "near" === b.stripLine.labelAlign ? this.chart.plotArea.x1 + 3 : "center" === b.stripLine.labelAlign ? (this.chart.plotArea.x2 + this.chart.plotArea.x1) / 2 - b.textBlock.width / 2 : this.chart.plotArea.x2 - b.textBlock.width - 3) : "right" ===
                                          this._position && (b.textBlock.maxWidth = this.options.stripLines[c].labelMaxWidth ? this.options.stripLines[c].labelMaxWidth : this.chart.plotArea.width - 3, b.textBlock.angle = 0, b.textBlock.measureText(), a.y - +b.textBlock.height > this.chart.plotArea.y1 ? h(l.startValue) ? a.y -= b.textBlock.height - b.textBlock.fontSize / 2 : a.y -= b.textBlock.height / 2 - b.textBlock.fontSize / 2 - 3 : a.y - b.textBlock.height < this.chart.plotArea.y2 ? a.y += b.textBlock.fontSize / 2 + 3 : h(l.startValue) ? a.y -= b.textBlock.height - b.textBlock.fontSize / 2 : a.y -= b.textBlock.height /
                                            2 - b.textBlock.fontSize / 2 + 3, a.x = "near" === b.stripLine.labelAlign ? this.chart.plotArea.x2 - b.textBlock.width - 3 : "center" === b.stripLine.labelAlign ? (this.chart.plotArea.x2 + this.chart.plotArea.x1) / 2 - b.textBlock.width / 2 : this.chart.plotArea.x1 + 3); b.textBlock.x = a.x; b.textBlock.y = a.y; x.push(b)
                        } if (!f) {
                          f = !1; this.ctx.save(); this.ctx.beginPath(); this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height); this.ctx.clip(); for (c = 0; c < m.length; c++)l = m[c], l.showOnTop ?
                            g || (g = !0, this.chart.addEventListener("dataAnimationIterationEnd", function () { this.ctx.save(); this.ctx.beginPath(); this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height); this.ctx.clip(); for (e = 0; e < m.length; e++)l = m[e], l.showOnTop && l.render(); this.ctx.restore() }, l)) : l.render(); for (c = 0; c < x.length; c++)b = x[c], b.stripLine.showOnTop ? f || (f = !0, this.chart.addEventListener("dataAnimationIterationEnd", function () {
                              for (e = 0; e < x.length; e++)b = x[e], "inside" ===
                                b.stripLine.labelPlacement && b.stripLine.showOnTop && (d.ctx.save(), d.ctx.beginPath(), d.ctx.rect(d.chart.plotArea.x1, d.chart.plotArea.y1, d.chart.plotArea.width, d.chart.plotArea.height), d.ctx.clip(), b.textBlock.render(!0), d.ctx.restore())
                            }, b.textBlock)) : "inside" === b.stripLine.labelPlacement && b.textBlock.render(!0); this.ctx.restore(); f = !0
                        } if (f) for (f = !1, c = 0; c < x.length; c++)b = x[c], b.stripLine.showOnTop ? f || (f = !0, this.chart.addEventListener("dataAnimationIterationEnd", function () {
                          for (e = 0; e < x.length; e++)b = x[e],
                            "outside" === b.stripLine.labelPlacement && b.stripLine.showOnTop && b.textBlock.render(!0)
                        }, b.textBlock)) : "outside" === b.stripLine.labelPlacement && b.textBlock.render(!0)
                      }
                    }; B.prototype.renderBreaksBackground = function () {
                      this.chart._breaksCanvas && (this.scaleBreaks && 0 < this.scaleBreaks._appliedBreaks.length && this.maskCanvas) && (this.chart._breaksCanvasCtx.save(), this.chart._breaksCanvasCtx.beginPath(), this.chart._breaksCanvasCtx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height),
                        this.chart._breaksCanvasCtx.clip(), this.chart._breaksCanvasCtx.drawImage(this.maskCanvas, 0, 0, this.chart.width, this.chart.height), this.chart._breaksCanvasCtx.restore())
                    }; B.prototype.createMask = function () {
                      if (this.scaleBreaks && 0 < this.scaleBreaks._appliedBreaks.length) {
                        var a = this.scaleBreaks._appliedBreaks; s ? (this.maskCanvas = pa(this.chart.width, this.chart.height), this.maskCtx = this.maskCanvas.getContext("2d")) : (this.maskCanvas = this.chart.plotArea.canvas, this.maskCtx = this.chart.plotArea.ctx); this.maskCtx.save();
                        this.maskCtx.beginPath(); this.maskCtx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height); this.maskCtx.clip(); for (var d = 0; d < a.length; d++)a[d].endValue < this.viewportMinimum || (a[d].startValue > this.viewportMaximum || isNaN(this.range)) || a[d].render(this.maskCtx); this.maskCtx.restore()
                      }
                    }; B.prototype.renderCrosshair = function (a, d) {
                      isFinite(this.minimum) && isFinite(this.maximum) && (this.crosshair.render(a, d), this.crosshair.dispatchEvent("updated", {
                        chart: this.chart,
                        crosshair: this.options, axis: this, value: this.crosshair.value
                      }, this))
                    }; B.prototype.showCrosshair = function (a) { h(a) || (a < this.viewportMinimum || a > this.viewportMaximum) || ("top" === this._position || "bottom" === this._position ? this.crosshair.render(this.convertValueToPixel(a), null, a) : this.crosshair.render(null, this.convertValueToPixel(a), a)) }; B.prototype.renderGrid = function () {
                      if (this.gridThickness && 0 < this.gridThickness) {
                        var a = this.chart.ctx; a.save(); var d, b = this.chart.plotArea; a.lineWidth = this.gridThickness; a.strokeStyle =
                          this.gridColor; a.setLineDash && a.setLineDash(R(this.gridDashType, this.gridThickness)); if ("bottom" === this._position || "top" === this._position) for (c = 0; c < this._labels.length; c++)this._labels[c].position < this.viewportMinimum || (this._labels[c].position > this.viewportMaximum || this._labels[c].breaksLabelType) || (a.beginPath(), d = this.getPixelCoordinatesOnAxis(this._labels[c].position), d = 1 === a.lineWidth % 2 ? (d.x << 0) + 0.5 : d.x << 0, a.moveTo(d, b.y1 << 0), a.lineTo(d, b.y2 << 0), a.stroke()); else if ("left" === this._position || "right" ===
                            this._position) for (var c = 0; c < this._labels.length; c++)this._labels[c].position < this.viewportMinimum || (this._labels[c].position > this.viewportMaximum || this._labels[c].breaksLabelType) || (a.beginPath(), d = this.getPixelCoordinatesOnAxis(this._labels[c].position), d = 1 === a.lineWidth % 2 ? (d.y << 0) + 0.5 : d.y << 0, a.moveTo(b.x1 << 0, d), a.lineTo(b.x2 << 0, d), a.stroke()); a.restore()
                      }
                    }; B.prototype.renderAxisLine = function () {
                      var a = this.chart.ctx, d = s ? this.chart._preRenderCtx : a, b = Math.ceil(this.tickThickness / (this.reversed ? -2 :
                        2)), c = Math.ceil(this.tickThickness / (this.reversed ? 2 : -2)), e, g; d.save(); if ("bottom" === this._position || "top" === this._position) {
                          if (this.lineThickness) {
                            this.reversed ? (e = this.lineCoordinates.x2, g = this.lineCoordinates.x1) : (e = this.lineCoordinates.x1, g = this.lineCoordinates.x2); d.lineWidth = this.lineThickness; d.strokeStyle = this.lineColor ? this.lineColor : "black"; d.setLineDash && d.setLineDash(R(this.lineDashType, this.lineThickness)); var f = 1 === this.lineThickness % 2 ? (this.lineCoordinates.y1 << 0) + 0.5 : this.lineCoordinates.y1 <<
                              0; d.beginPath(); if (this.scaleBreaks && !h(this.scaleBreaks.firstBreakIndex)) if (h(this.scaleBreaks.lastBreakIndex)) e = this.scaleBreaks._appliedBreaks[this.scaleBreaks.firstBreakIndex].endPixel + c; else for (var m = this.scaleBreaks.firstBreakIndex; m <= this.scaleBreaks.lastBreakIndex; m++)d.moveTo(e, f), d.lineTo(this.scaleBreaks._appliedBreaks[m].startPixel + b, f), e = this.scaleBreaks._appliedBreaks[m].endPixel + c; e && (d.moveTo(e, f), d.lineTo(g, f)); d.stroke()
                          }
                        } else if (("left" === this._position || "right" === this._position) &&
                          this.lineThickness) {
                        this.reversed ? (e = this.lineCoordinates.y1, g = this.lineCoordinates.y2) : (e = this.lineCoordinates.y2, g = this.lineCoordinates.y1); d.lineWidth = this.lineThickness; d.strokeStyle = this.lineColor; d.setLineDash && d.setLineDash(R(this.lineDashType, this.lineThickness)); f = 1 === this.lineThickness % 2 ? (this.lineCoordinates.x1 << 0) + 0.5 : this.lineCoordinates.x1 << 0; d.beginPath(); if (this.scaleBreaks && !h(this.scaleBreaks.firstBreakIndex)) if (h(this.scaleBreaks.lastBreakIndex)) e = this.scaleBreaks._appliedBreaks[this.scaleBreaks.firstBreakIndex].endPixel +
                          b; else for (m = this.scaleBreaks.firstBreakIndex; m <= this.scaleBreaks.lastBreakIndex; m++)d.moveTo(f, e), d.lineTo(f, this.scaleBreaks._appliedBreaks[m].startPixel + c), e = this.scaleBreaks._appliedBreaks[m].endPixel + b; e && (d.moveTo(f, e), d.lineTo(f, g)); d.stroke()
                      } s && (a.drawImage(this.chart._preRenderCanvas, 0, 0, this.chart.width, this.chart.height), this.chart._breaksCanvasCtx && this.chart._breaksCanvasCtx.drawImage(this.chart._preRenderCanvas, 0, 0, this.chart.width, this.chart.height), d.clearRect(0, 0, this.chart.width,
                        this.chart.height)); d.restore()
                    }; B.prototype.getPixelCoordinatesOnAxis = function (a) { var d = {}; if ("bottom" === this._position || "top" === this._position) d.x = this.convertValueToPixel(a), d.y = this.lineCoordinates.y1; if ("left" === this._position || "right" === this._position) d.y = this.convertValueToPixel(a), d.x = this.lineCoordinates.x2; return d }; B.prototype.convertPixelToValue = function (a) {
                      if ("undefined" === typeof a) return null; var d = 0, b = 0, c, d = !0, e = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [], b = "number" === typeof a ?
                        a : "left" === this._position || "right" === this._position ? a.y : a.x; if (this.logarithmic) {
                          a = c = Math.pow(this.logarithmBase, (b - this.conversionParameters.reference) / this.conversionParameters.pixelPerUnit); if (b <= this.conversionParameters.reference === ("left" === this._position || "right" === this._position) !== this.reversed) for (b = 0; b < e.length; b++) {
                            if (!(e[b].endValue < this.conversionParameters.minimum)) if (d) if (e[b].startValue < this.conversionParameters.minimum) {
                              if (1 < e[b].size && this.conversionParameters.minimum * Math.pow(e[b].endValue /
                                e[b].startValue, Math.log(c) / Math.log(e[b].size)) < e[b].endValue) { a = Math.pow(e[b].endValue / e[b].startValue, Math.log(c) / Math.log(e[b].size)); break } else a *= e[b].endValue / this.conversionParameters.minimum / Math.pow(e[b].size, Math.log(e[b].endValue / this.conversionParameters.minimum) / Math.log(e[b].endValue / e[b].startValue)), c /= Math.pow(e[b].size, Math.log(e[b].endValue / this.conversionParameters.minimum) / Math.log(e[b].endValue / e[b].startValue)); d = !1
                            } else if (c > e[b].startValue / this.conversionParameters.minimum) {
                              c /=
                                e[b].startValue / this.conversionParameters.minimum; if (c < e[b].size) { a *= Math.pow(e[b].endValue / e[b].startValue, 1 === e[b].size ? 1 : Math.log(c) / Math.log(e[b].size)) / c; break } else a *= e[b].endValue / e[b].startValue / e[b].size; c /= e[b].size; d = !1
                            } else break; else if (c > e[b].startValue / e[b - 1].endValue) { c /= e[b].startValue / e[b - 1].endValue; if (c < e[b].size) { a *= Math.pow(e[b].endValue / e[b].startValue, 1 === e[b].size ? 1 : Math.log(c) / Math.log(e[b].size)) / c; break } else a *= e[b].endValue / e[b].startValue / e[b].size; c /= e[b].size } else break
                          } else for (b =
                            e.length - 1; 0 <= b; b--)if (!(e[b].startValue > this.conversionParameters.minimum)) if (d) if (e[b].endValue > this.conversionParameters.minimum) {
                              if (1 < e[b].size && this.conversionParameters.minimum * Math.pow(e[b].endValue / e[b].startValue, Math.log(c) / Math.log(e[b].size)) > e[b].startValue) { a = Math.pow(e[b].endValue / e[b].startValue, Math.log(c) / Math.log(e[b].size)); break } else a *= e[b].startValue / this.conversionParameters.minimum * Math.pow(e[b].size, Math.log(e[b].startValue / this.conversionParameters.minimum) / Math.log(e[b].endValue /
                                e[b].startValue)) * c, c *= Math.pow(e[b].size, Math.log(this.conversionParameters.minimum / e[b].startValue) / Math.log(e[b].endValue / e[b].startValue)); d = !1
                            } else if (c < e[b].endValue / this.conversionParameters.minimum) { c /= e[b].endValue / this.conversionParameters.minimum; if (c > 1 / e[b].size) { a *= Math.pow(e[b].endValue / e[b].startValue, 1 >= e[b].size ? 1 : Math.log(c) / Math.log(e[b].size)) * c; break } else a /= e[b].endValue / e[b].startValue / e[b].size; c *= e[b].size; d = !1 } else break; else if (c < e[b].endValue / e[b + 1].startValue) {
                              c /= e[b].endValue /
                                e[b + 1].startValue; if (c > 1 / e[b].size) { a *= Math.pow(e[b].endValue / e[b].startValue, 1 >= e[b].size ? 1 : Math.log(c) / Math.log(e[b].size)) * c; break } else a /= e[b].endValue / e[b].startValue / e[b].size; c *= e[b].size
                            } else break; d = a * this.viewportMinimum
                        } else {
                        a = c = (b - this.conversionParameters.reference) / this.conversionParameters.pixelPerUnit; if (b <= this.conversionParameters.reference === ("left" === this._position || "right" === this._position) !== this.reversed) for (b = 0; b < e.length; b++) {
                          if (!(e[b].endValue < this.conversionParameters.minimum)) if (d) if (e[b].startValue <
                            this.conversionParameters.minimum) { if (e[b].size && this.conversionParameters.minimum + c * (e[b].endValue - e[b].startValue) / e[b].size < e[b].endValue) { a = 0 >= e[b].size ? 0 : c * (e[b].endValue - e[b].startValue) / e[b].size; break } else a += e[b].endValue - this.conversionParameters.minimum - e[b].size * (e[b].endValue - this.conversionParameters.minimum) / (e[b].endValue - e[b].startValue), c -= e[b].size * (e[b].endValue - this.conversionParameters.minimum) / (e[b].endValue - e[b].startValue); d = !1 } else if (c > e[b].startValue - this.conversionParameters.minimum) {
                              c -=
                                e[b].startValue - this.conversionParameters.minimum; if (c < e[b].size) { a += (e[b].endValue - e[b].startValue) * (0 === e[b].size ? 1 : c / e[b].size) - c; break } else a += e[b].endValue - e[b].startValue - e[b].size; c -= e[b].size; d = !1
                            } else break; else if (c > e[b].startValue - e[b - 1].endValue) { c -= e[b].startValue - e[b - 1].endValue; if (c < e[b].size) { a += (e[b].endValue - e[b].startValue) * (0 === e[b].size ? 1 : c / e[b].size) - c; break } else a += e[b].endValue - e[b].startValue - e[b].size; c -= e[b].size } else break
                        } else for (b = e.length - 1; 0 <= b; b--)if (!(e[b].startValue >
                          this.conversionParameters.minimum)) if (d) if (e[b].endValue > this.conversionParameters.minimum) if (e[b].size && this.conversionParameters.minimum + c * (e[b].endValue - e[b].startValue) / e[b].size > e[b].startValue) { a = 0 >= e[b].size ? 0 : c * (e[b].endValue - e[b].startValue) / e[b].size; break } else a += e[b].startValue - this.conversionParameters.minimum + e[b].size * (this.conversionParameters.minimum - e[b].startValue) / (e[b].endValue - e[b].startValue), c += e[b].size * (this.conversionParameters.minimum - e[b].startValue) / (e[b].endValue - e[b].startValue),
                            d = !1; else if (c < e[b].endValue - this.conversionParameters.minimum) { c -= e[b].endValue - this.conversionParameters.minimum; if (c > -1 * e[b].size) { a += (e[b].endValue - e[b].startValue) * (0 === e[b].size ? 1 : c / e[b].size) + c; break } else a -= e[b].endValue - e[b].startValue - e[b].size; c += e[b].size; d = !1 } else break; else if (c < e[b].endValue - e[b + 1].startValue) {
                              c -= e[b].endValue - e[b + 1].startValue; if (c > -1 * e[b].size) { a += (e[b].endValue - e[b].startValue) * (0 === e[b].size ? 1 : c / e[b].size) + c; break } else a -= e[b].endValue - e[b].startValue - e[b].size;
                              c += e[b].size
                            } else break; d = this.conversionParameters.minimum + a
                      } return d
                    }; B.prototype.convertValueToPixel = function (a) {
                      a = this.getApparentDifference(this.conversionParameters.minimum, a, a); return this.logarithmic ? this.conversionParameters.reference + this.conversionParameters.pixelPerUnit * Math.log(a / this.conversionParameters.minimum) / this.conversionParameters.lnLogarithmBase + 0.5 << 0 : "axisX" === this.type ? this.conversionParameters.reference + this.conversionParameters.pixelPerUnit * (a - this.conversionParameters.minimum) +
                        0.5 << 0 : this.conversionParameters.reference + this.conversionParameters.pixelPerUnit * (a - this.conversionParameters.minimum) + 0.5
                    }; B.prototype.getApparentDifference = function (a, d, b, c) {
                      var e = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : []; if (this.logarithmic) {
                        b = h(b) ? d / a : b; for (var g = 0; g < e.length && !(d < e[g].startValue); g++)a > e[g].endValue || (a <= e[g].startValue && d >= e[g].endValue ? b = b / e[g].endValue * e[g].startValue * e[g].size : a >= e[g].startValue && d >= e[g].endValue ? b = b / e[g].endValue * a * Math.pow(e[g].size, Math.log(e[g].endValue /
                          a) / Math.log(e[g].endValue / e[g].startValue)) : a <= e[g].startValue && d <= e[g].endValue ? b = b / d * e[g].startValue * Math.pow(e[g].size, Math.log(d / e[g].startValue) / Math.log(e[g].endValue / e[g].startValue)) : !c && (a > e[g].startValue && d < e[g].endValue) && (b = a * Math.pow(e[g].size, Math.log(d / a) / Math.log(e[g].endValue / e[g].startValue))))
                      } else for (b = h(b) ? Math.abs(d - a) : b, g = 0; g < e.length && !(d < e[g].startValue); g++)a > e[g].endValue || (a <= e[g].startValue && d >= e[g].endValue ? b = b - e[g].endValue + e[g].startValue + e[g].size : a > e[g].startValue &&
                        d >= e[g].endValue ? b = b - e[g].endValue + a + e[g].size * (e[g].endValue - a) / (e[g].endValue - e[g].startValue) : a <= e[g].startValue && d < e[g].endValue ? b = b - d + e[g].startValue + e[g].size * (d - e[g].startValue) / (e[g].endValue - e[g].startValue) : !c && (a > e[g].startValue && d < e[g].endValue) && (b = a + e[g].size * (d - a) / (e[g].endValue - e[g].startValue))); return b
                    }; B.prototype.setViewPortRange = function (a, d) {
                      this.sessionVariables.newViewportMinimum = this.viewportMinimum = Math.min(a, d); this.sessionVariables.newViewportMaximum = this.viewportMaximum =
                        Math.max(a, d)
                    }; B.prototype.getXValueAt = function (a) { if (!a) return null; var d = null; "left" === this._position ? d = this.convertPixelToValue(a.y) : "bottom" === this._position && (d = this.convertPixelToValue(a.x)); return d }; B.prototype.calculateValueToPixelConversionParameters = function (a) {
                      a = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : []; var d = { pixelPerUnit: null, minimum: null, reference: null }, b = this.lineCoordinates.width, c = this.lineCoordinates.height, b = "bottom" === this._position || "top" === this._position ? b : c, c = Math.abs(this.range);
                      if (this.logarithmic) for (var e = 0; e < a.length && !(this.viewportMaximum < a[e].startValue); e++)this.viewportMinimum > a[e].endValue || (this.viewportMinimum >= a[e].startValue && this.viewportMaximum <= a[e].endValue ? b = 0 : this.viewportMinimum <= a[e].startValue && this.viewportMaximum >= a[e].endValue ? (c = c / a[e].endValue * a[e].startValue, b = 0 < a[e].spacing.toString().indexOf("%") ? b * (1 - parseFloat(a[e].spacing) / 100) : b - Math.min(a[e].spacing, 0.1 * b)) : this.viewportMinimum > a[e].startValue && this.viewportMaximum >= a[e].endValue ? (c = c /
                        a[e].endValue * this.viewportMinimum, b = 0 < a[e].spacing.toString().indexOf("%") ? b * (1 - parseFloat(a[e].spacing) / 100 * Math.log(a[e].endValue / this.viewportMinimum) / Math.log(a[e].endValue / a[e].startValue)) : b - Math.min(a[e].spacing, 0.1 * b) * Math.log(a[e].endValue / this.viewportMinimum) / Math.log(a[e].endValue / a[e].startValue)) : this.viewportMinimum <= a[e].startValue && this.viewportMaximum < a[e].endValue && (c = c / this.viewportMaximum * a[e].startValue, b = 0 < a[e].spacing.toString().indexOf("%") ? b * (1 - parseFloat(a[e].spacing) /
                          100 * Math.log(this.viewportMaximum / a[e].startValue) / Math.log(a[e].endValue / a[e].startValue)) : b - Math.min(a[e].spacing, 0.1 * b) * Math.log(this.viewportMaximum / a[e].startValue) / Math.log(a[e].endValue / a[e].startValue))); else for (e = 0; e < a.length && !(this.viewportMaximum < a[e].startValue); e++)this.viewportMinimum > a[e].endValue || (this.viewportMinimum >= a[e].startValue && this.viewportMaximum <= a[e].endValue ? b = 0 : this.viewportMinimum <= a[e].startValue && this.viewportMaximum >= a[e].endValue ? (c = c - a[e].endValue + a[e].startValue,
                            b = 0 < a[e].spacing.toString().indexOf("%") ? b * (1 - parseFloat(a[e].spacing) / 100) : b - Math.min(a[e].spacing, 0.1 * b)) : this.viewportMinimum > a[e].startValue && this.viewportMaximum >= a[e].endValue ? (c = c - a[e].endValue + this.viewportMinimum, b = 0 < a[e].spacing.toString().indexOf("%") ? b * (1 - parseFloat(a[e].spacing) / 100 * (a[e].endValue - this.viewportMinimum) / (a[e].endValue - a[e].startValue)) : b - Math.min(a[e].spacing, 0.1 * b) * (a[e].endValue - this.viewportMinimum) / (a[e].endValue - a[e].startValue)) : this.viewportMinimum <= a[e].startValue &&
                              this.viewportMaximum < a[e].endValue && (c = c - this.viewportMaximum + a[e].startValue, b = 0 < a[e].spacing.toString().indexOf("%") ? b * (1 - parseFloat(a[e].spacing) / 100 * (this.viewportMaximum - a[e].startValue) / (a[e].endValue - a[e].startValue)) : b - Math.min(a[e].spacing, 0.1 * b) * (this.viewportMaximum - a[e].startValue) / (a[e].endValue - a[e].startValue))); d.minimum = this.viewportMinimum; d.maximum = this.viewportMaximum; d.range = c; if ("bottom" === this._position || "top" === this._position) this.logarithmic ? (d.lnLogarithmBase = Math.log(this.logarithmBase),
                                d.pixelPerUnit = (this.reversed ? -1 : 1) * b * d.lnLogarithmBase / Math.log(Math.abs(c))) : d.pixelPerUnit = (this.reversed ? -1 : 1) * b / Math.abs(c), d.reference = this.reversed ? this.lineCoordinates.x2 : this.lineCoordinates.x1; if ("left" === this._position || "right" === this._position) this.logarithmic ? (d.lnLogarithmBase = Math.log(this.logarithmBase), d.pixelPerUnit = (this.reversed ? 1 : -1) * b * d.lnLogarithmBase / Math.log(Math.abs(c))) : d.pixelPerUnit = (this.reversed ? 1 : -1) * b / Math.abs(c), d.reference = this.reversed ? this.lineCoordinates.y1 : this.lineCoordinates.y2;
                      this.conversionParameters = d
                    }; B.prototype.calculateAxisParameters = function () {
                      if (this.logarithmic) this.calculateLogarithmicAxisParameters(); else {
                        var a = this.chart.layoutManager.getFreeSpace(), d = !1, b = !1; "bottom" === this._position || "top" === this._position ? (this.maxWidth = a.width, this.maxHeight = a.height) : (this.maxWidth = a.height, this.maxHeight = a.width); var a = "axisX" === this.type ? "xySwapped" === this.chart.plotInfo.axisPlacement ? 62 : 70 : "xySwapped" === this.chart.plotInfo.axisPlacement ? 50 : 40, c = 4; "axisX" === this.type &&
                          (c = 600 > this.maxWidth ? 8 : 6); var a = Math.max(c, Math.floor(this.maxWidth / a)), e, g, f, c = 0; !h(this.options.viewportMinimum) && (!h(this.options.viewportMaximum) && this.options.viewportMinimum >= this.options.viewportMaximum) && (this.viewportMinimum = this.viewportMaximum = null); if (h(this.options.viewportMinimum) && !h(this.sessionVariables.newViewportMinimum) && !isNaN(this.sessionVariables.newViewportMinimum)) this.viewportMinimum = this.sessionVariables.newViewportMinimum; else if (null === this.viewportMinimum || isNaN(this.viewportMinimum)) this.viewportMinimum =
                            this.minimum; if (h(this.options.viewportMaximum) && !h(this.sessionVariables.newViewportMaximum) && !isNaN(this.sessionVariables.newViewportMaximum)) this.viewportMaximum = this.sessionVariables.newViewportMaximum; else if (null === this.viewportMaximum || isNaN(this.viewportMaximum)) this.viewportMaximum = this.maximum; if (this.scaleBreaks) for (c = 0; c < this.scaleBreaks._appliedBreaks.length; c++)if ((!h(this.sessionVariables.newViewportMinimum) && this.sessionVariables.newViewportMinimum >= this.scaleBreaks._appliedBreaks[c].startValue ||
                              !h(this.options.minimum) && this.options.minimum >= this.scaleBreaks._appliedBreaks[c].startValue || !h(this.options.viewportMinimum) && this.viewportMinimum >= this.scaleBreaks._appliedBreaks[c].startValue) && (!h(this.sessionVariables.newViewportMaximum) && this.sessionVariables.newViewportMaximum <= this.scaleBreaks._appliedBreaks[c].endValue || !h(this.options.maximum) && this.options.maximum <= this.scaleBreaks._appliedBreaks[c].endValue || !h(this.options.viewportMaximum) && this.viewportMaximum <= this.scaleBreaks._appliedBreaks[c].endValue)) {
                              this.scaleBreaks._appliedBreaks.splice(c,
                                1); break
                            } if ("axisX" === this.type) {
                              if (this.dataSeries && 0 < this.dataSeries.length) for (e = 0; e < this.dataSeries.length; e++)"dateTime" === this.dataSeries[e].xValueType && (b = !0); e = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin; g = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax; 0 === g - e && (c = "undefined" === typeof this.options.interval ? 0.4 : this.options.interval, g += c, e -= c); Infinity !== this.dataInfo.minDiff ? f = this.dataInfo.minDiff : 1 < g - e ? f = 0.5 * Math.abs(g - e) : (f = 1, b &&
                                (d = !0))
                            } else "axisY" === this.type && (e = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, g = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax, isFinite(e) || isFinite(g) ? isFinite(e) ? isFinite(g) || (g = e) : e = g : (g = "undefined" === typeof this.options.interval ? -Infinity : this.options.interval, e = "undefined" !== typeof this.options.interval || isFinite(this.dataInfo.minDiff) ? 0 : Infinity), 0 === e && 0 === g ? (g += 9, e = 0) : 0 === g - e ? (c = Math.min(Math.abs(0.01 * Math.abs(g)), 5), g += c, e -= c) :
                              e > g ? (c = Math.min(0.01 * Math.abs(this.getApparentDifference(g, e, null, !0)), 5), 0 <= g ? e = g - c : g = isFinite(e) ? e + c : 0) : (c = Math.min(0.01 * Math.abs(this.getApparentDifference(e, g, null, !0)), 0.05), 0 !== g && (g += c), 0 !== e && (e -= c)), f = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : 1 < g - e ? 0.5 * Math.abs(g - e) : 1, this.includeZero && (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && 0 < e && (e = 0), this.includeZero && (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && 0 > g && (g = 0)); c = this.getApparentDifference(isNaN(this.viewportMinimum) ||
                                null === this.viewportMinimum ? e : this.viewportMinimum, isNaN(this.viewportMaximum) || null === this.viewportMaximum ? g : this.viewportMaximum, null, !0); if ("axisX" === this.type && b) {
                                  this.intervalType || (c / 1 <= a ? (this.interval = 1, this.intervalType = "millisecond") : c / 2 <= a ? (this.interval = 2, this.intervalType = "millisecond") : c / 5 <= a ? (this.interval = 5, this.intervalType = "millisecond") : c / 10 <= a ? (this.interval = 10, this.intervalType = "millisecond") : c / 20 <= a ? (this.interval = 20, this.intervalType = "millisecond") : c / 50 <= a ? (this.interval = 50,
                                    this.intervalType = "millisecond") : c / 100 <= a ? (this.interval = 100, this.intervalType = "millisecond") : c / 200 <= a ? (this.interval = 200, this.intervalType = "millisecond") : c / 250 <= a ? (this.interval = 250, this.intervalType = "millisecond") : c / 300 <= a ? (this.interval = 300, this.intervalType = "millisecond") : c / 400 <= a ? (this.interval = 400, this.intervalType = "millisecond") : c / 500 <= a ? (this.interval = 500, this.intervalType = "millisecond") : c / (1 * U.secondDuration) <= a ? (this.interval = 1, this.intervalType = "second") : c / (2 * U.secondDuration) <= a ? (this.interval =
                                      2, this.intervalType = "second") : c / (5 * U.secondDuration) <= a ? (this.interval = 5, this.intervalType = "second") : c / (10 * U.secondDuration) <= a ? (this.interval = 10, this.intervalType = "second") : c / (15 * U.secondDuration) <= a ? (this.interval = 15, this.intervalType = "second") : c / (20 * U.secondDuration) <= a ? (this.interval = 20, this.intervalType = "second") : c / (30 * U.secondDuration) <= a ? (this.interval = 30, this.intervalType = "second") : c / (1 * U.minuteDuration) <= a ? (this.interval = 1, this.intervalType = "minute") : c / (2 * U.minuteDuration) <= a ? (this.interval =
                                        2, this.intervalType = "minute") : c / (5 * U.minuteDuration) <= a ? (this.interval = 5, this.intervalType = "minute") : c / (10 * U.minuteDuration) <= a ? (this.interval = 10, this.intervalType = "minute") : c / (15 * U.minuteDuration) <= a ? (this.interval = 15, this.intervalType = "minute") : c / (20 * U.minuteDuration) <= a ? (this.interval = 20, this.intervalType = "minute") : c / (30 * U.minuteDuration) <= a ? (this.interval = 30, this.intervalType = "minute") : c / (1 * U.hourDuration) <= a ? (this.interval = 1, this.intervalType = "hour") : c / (2 * U.hourDuration) <= a ? (this.interval = 2,
                                          this.intervalType = "hour") : c / (3 * U.hourDuration) <= a ? (this.interval = 3, this.intervalType = "hour") : c / (6 * U.hourDuration) <= a ? (this.interval = 6, this.intervalType = "hour") : c / (1 * U.dayDuration) <= a ? (this.interval = 1, this.intervalType = "day") : c / (2 * U.dayDuration) <= a ? (this.interval = 2, this.intervalType = "day") : c / (4 * U.dayDuration) <= a ? (this.interval = 4, this.intervalType = "day") : c / (1 * U.weekDuration) <= a ? (this.interval = 1, this.intervalType = "week") : c / (2 * U.weekDuration) <= a ? (this.interval = 2, this.intervalType = "week") : c / (3 * U.weekDuration) <=
                                            a ? (this.interval = 3, this.intervalType = "week") : c / (1 * U.monthDuration) <= a ? (this.interval = 1, this.intervalType = "month") : c / (2 * U.monthDuration) <= a ? (this.interval = 2, this.intervalType = "month") : c / (3 * U.monthDuration) <= a ? (this.interval = 3, this.intervalType = "month") : c / (6 * U.monthDuration) <= a ? (this.interval = 6, this.intervalType = "month") : (this.interval = c / (1 * U.yearDuration) <= a ? 1 : c / (2 * U.yearDuration) <= a ? 2 : c / (4 * U.yearDuration) <= a ? 4 : Math.floor(B.getNiceNumber(c / (a - 1), !0) / U.yearDuration), this.intervalType = "year")); if (null ===
                                              this.viewportMinimum || isNaN(this.viewportMinimum)) this.viewportMinimum = e - f / 2; if (null === this.viewportMaximum || isNaN(this.viewportMaximum)) this.viewportMaximum = g + f / 2; d ? this.autoValueFormatString = "MMM DD YYYY HH:mm" : "year" === this.intervalType ? this.autoValueFormatString = "YYYY" : "month" === this.intervalType ? this.autoValueFormatString = "MMM YYYY" : "week" === this.intervalType ? this.autoValueFormatString = "MMM DD YYYY" : "day" === this.intervalType ? this.autoValueFormatString = "MMM DD YYYY" : "hour" === this.intervalType ?
                                                this.autoValueFormatString = "hh:mm TT" : "minute" === this.intervalType ? this.autoValueFormatString = "hh:mm TT" : "second" === this.intervalType ? this.autoValueFormatString = "hh:mm:ss TT" : "millisecond" === this.intervalType && (this.autoValueFormatString = "fff'ms'"); this.valueFormatString || (this.valueFormatString = this.autoValueFormatString)
                                } else {
                          this.intervalType = "number"; c = B.getNiceNumber(c, !1); this.interval = this.options && 0 < this.options.interval ? this.options.interval : B.getNiceNumber(c / (a - 1), !0); if (null === this.viewportMinimum ||
                            isNaN(this.viewportMinimum)) this.viewportMinimum = "axisX" === this.type ? e - f / 2 : Math.floor(e / this.interval) * this.interval; if (null === this.viewportMaximum || isNaN(this.viewportMaximum)) this.viewportMaximum = "axisX" === this.type ? g + f / 2 : Math.ceil(g / this.interval) * this.interval; 0 === this.viewportMaximum && 0 === this.viewportMinimum && (0 === this.options.viewportMinimum ? this.viewportMaximum += 10 : 0 === this.options.viewportMaximum && (this.viewportMinimum -= 10), this.options && "undefined" === typeof this.options.interval && (this.interval =
                              B.getNiceNumber((this.viewportMaximum - this.viewportMinimum) / (a - 1), !0)))
                        } if (null === this.minimum || null === this.maximum) if ("axisX" === this.type ? (e = null !== this.minimum ? this.minimum : this.dataInfo.min, g = null !== this.maximum ? this.maximum : this.dataInfo.max, 0 === g - e && (c = "undefined" === typeof this.options.interval ? 0.4 : this.options.interval, g += c, e -= c), f = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : 1 < g - e ? 0.5 * Math.abs(g - e) : 1) : "axisY" === this.type && (e = null !== this.minimum ? this.minimum : this.dataInfo.min, g = null !==
                          this.maximum ? this.maximum : this.dataInfo.max, isFinite(e) || isFinite(g) ? 0 === e && 0 === g ? (g += 9, e = 0) : 0 === g - e ? (c = Math.min(Math.abs(0.01 * Math.abs(g)), 5), g += c, e -= c) : e > g ? (c = Math.min(0.01 * Math.abs(this.getApparentDifference(g, e, null, !0)), 5), 0 <= g ? e = g - c : g = isFinite(e) ? e + c : 0) : (c = Math.min(0.01 * Math.abs(this.getApparentDifference(e, g, null, !0)), 0.05), 0 !== g && (g += c), 0 !== e && (e -= c)) : (g = "undefined" === typeof this.options.interval ? -Infinity : this.options.interval, e = "undefined" !== typeof this.options.interval || isFinite(this.dataInfo.minDiff) ?
                            0 : Infinity), f = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : 1 < g - e ? 0.5 * Math.abs(g - e) : 1, this.includeZero && (null === this.minimum || isNaN(this.minimum)) && 0 < e && (e = 0), this.includeZero && (null === this.maximum || isNaN(this.maximum)) && 0 > g && (g = 0)), Math.abs(this.getApparentDifference(e, g, null, !0)), "axisX" === this.type && b) { this.valueType = "dateTime"; if (null === this.minimum || isNaN(this.minimum)) this.minimum = e - f / 2; if (null === this.maximum || isNaN(this.maximum)) this.maximum = g + f / 2 } else this.intervalType = this.valueType =
                              "number", null === this.minimum && (this.minimum = "axisX" === this.type ? e - f / 2 : Math.floor(e / this.interval) * this.interval, this.minimum = Math.min(this.minimum, null === this.sessionVariables.viewportMinimum || isNaN(this.sessionVariables.viewportMinimum) ? Infinity : this.sessionVariables.viewportMinimum)), null === this.maximum && (this.maximum = "axisX" === this.type ? g + f / 2 : Math.ceil(g / this.interval) * this.interval, this.maximum = Math.max(this.maximum, null === this.sessionVariables.viewportMaximum || isNaN(this.sessionVariables.viewportMaximum) ?
                                -Infinity : this.sessionVariables.viewportMaximum)), 0 === this.maximum && 0 === this.minimum && (0 === this.options.minimum ? this.maximum += 10 : 0 === this.options.maximum && (this.minimum -= 10)); h(this.sessionVariables.newViewportMinimum) && (this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum)); h(this.sessionVariables.newViewportMaximum) && (this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum)); this.range = this.viewportMaximum - this.viewportMinimum; this.intervalStartPosition = "axisX" === this.type && b ?
                                  this.getLabelStartPoint(new Date(this.viewportMinimum), this.intervalType, this.interval) : Math.floor((this.viewportMinimum + 0.2 * this.interval) / this.interval) * this.interval; this.valueFormatString || (this.valueFormatString = B.generateValueFormatString(this.range, 2))
                      }
                    }; B.prototype.calculateLogarithmicAxisParameters = function () {
                      var a = this.chart.layoutManager.getFreeSpace(), d = Math.log(this.logarithmBase), b; "bottom" === this._position || "top" === this._position ? (this.maxWidth = a.width, this.maxHeight = a.height) : (this.maxWidth =
                        a.height, this.maxHeight = a.width); var a = "axisX" === this.type ? 500 > this.maxWidth ? 7 : Math.max(7, Math.floor(this.maxWidth / 100)) : Math.max(Math.floor(this.maxWidth / 50), 3), c, e, g, f; f = 1; if (null === this.viewportMinimum || isNaN(this.viewportMinimum)) this.viewportMinimum = this.minimum; if (null === this.viewportMaximum || isNaN(this.viewportMaximum)) this.viewportMaximum = this.maximum; if (this.scaleBreaks) for (f = 0; f < this.scaleBreaks._appliedBreaks.length; f++)if ((!h(this.sessionVariables.newViewportMinimum) && this.sessionVariables.newViewportMinimum >=
                          this.scaleBreaks._appliedBreaks[f].startValue || !h(this.options.minimum) && this.options.minimum >= this.scaleBreaks._appliedBreaks[f].startValue || !h(this.options.viewportMinimum) && this.viewportMinimum >= this.scaleBreaks._appliedBreaks[f].startValue) && (!h(this.sessionVariables.newViewportMaximum) && this.sessionVariables.newViewportMaximum <= this.scaleBreaks._appliedBreaks[f].endValue || !h(this.options.maximum) && this.options.maximum <= this.scaleBreaks._appliedBreaks[f].endValue || !h(this.options.viewportMaximum) &&
                            this.viewportMaximum <= this.scaleBreaks._appliedBreaks[f].endValue)) { this.scaleBreaks._appliedBreaks.splice(f, 1); break } "axisX" === this.type ? (c = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, e = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax, 1 === e / c && (f = Math.pow(this.logarithmBase, "undefined" === typeof this.options.interval ? 0.4 : this.options.interval), e *= f, c /= f), g = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : e / c > this.logarithmBase ? e / c * Math.pow(this.logarithmBase,
                              0.5) : this.logarithmBase) : "axisY" === this.type && (c = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, e = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax, 0 >= c && !isFinite(e) ? (e = "undefined" === typeof this.options.interval ? 0 : this.options.interval, c = 1) : 0 >= c ? c = e : isFinite(e) || (e = c), 1 === c && 1 === e ? (e *= this.logarithmBase - 1 / this.logarithmBase, c = 1) : 1 === e / c ? (f = Math.min(e * Math.pow(this.logarithmBase, 0.01), Math.pow(this.logarithmBase, 5)), e *= f, c /= f) : c > e ? (f = Math.min(c /
                                e * Math.pow(this.logarithmBase, 0.01), Math.pow(this.logarithmBase, 5)), 1 <= e ? c = e / f : e = c * f) : (f = Math.min(e / c * Math.pow(this.logarithmBase, 0.01), Math.pow(this.logarithmBase, 0.04)), 1 !== e && (e *= f), 1 !== c && (c /= f)), g = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : e / c > this.logarithmBase ? e / c * Math.pow(this.logarithmBase, 0.5) : this.logarithmBase, this.includeZero && (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && 1 < c && (c = 1), this.includeZero && (null === this.viewportMaximum || isNaN(this.viewportMaximum)) &&
                                1 > e && (e = 1)); f = (isNaN(this.viewportMaximum) || null === this.viewportMaximum ? e : this.viewportMaximum) / (isNaN(this.viewportMinimum) || null === this.viewportMinimum ? c : this.viewportMinimum); var m = (isNaN(this.viewportMaximum) || null === this.viewportMaximum ? e : this.viewportMaximum) - (isNaN(this.viewportMinimum) || null === this.viewportMinimum ? c : this.viewportMinimum); this.intervalType = "number"; f = Math.pow(this.logarithmBase, B.getNiceNumber(Math.abs(Math.log(f) / d), !1)); this.options && 0 < this.options.interval ? this.interval =
                                  this.options.interval : (this.interval = B.getNiceExponent(Math.log(f) / d / (a - 1), !0), b = B.getNiceNumber(m / (a - 1), !0)); if (null === this.viewportMinimum || isNaN(this.viewportMinimum)) this.viewportMinimum = "axisX" === this.type ? c / Math.sqrt(g) : Math.pow(this.logarithmBase, this.interval * Math.floor(Math.log(c) / d / this.interval)); if (null === this.viewportMaximum || isNaN(this.viewportMaximum)) this.viewportMaximum = "axisX" === this.type ? e * Math.sqrt(g) : Math.pow(this.logarithmBase, this.interval * Math.ceil(Math.log(e) / d / this.interval));
                      1 === this.viewportMaximum && 1 === this.viewportMinimum && (1 === this.options.viewportMinimum ? this.viewportMaximum *= this.logarithmBase - 1 / this.logarithmBase : 1 === this.options.viewportMaximum && (this.viewportMinimum /= this.logarithmBase - 1 / this.logarithmBase), this.options && "undefined" === typeof this.options.interval && (this.interval = B.getNiceExponent(Math.ceil(Math.log(f) / d) / (a - 1)), b = B.getNiceNumber((this.viewportMaximum - this.viewportMinimum) / (a - 1), !0))); if (null === this.minimum || null === this.maximum) "axisX" === this.type ?
                        (c = null !== this.minimum ? this.minimum : this.dataInfo.min, e = null !== this.maximum ? this.maximum : this.dataInfo.max, 1 === e / c && (f = Math.pow(this.logarithmBase, "undefined" === typeof this.options.interval ? 0.4 : this.options.interval), e *= f, c /= f), g = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : e / c > this.logarithmBase ? e / c * Math.pow(this.logarithmBase, 0.5) : this.logarithmBase) : "axisY" === this.type && (c = null !== this.minimum ? this.minimum : this.dataInfo.min, e = null !== this.maximum ? this.maximum : this.dataInfo.max, isFinite(c) ||
                          isFinite(e) ? 1 === c && 1 === e ? (e *= this.logarithmBase, c /= this.logarithmBase) : 1 === e / c ? (f = Math.pow(this.logarithmBase, this.interval), e *= f, c /= f) : c > e ? (f = Math.min(0.01 * (c / e), 5), 1 <= e ? c = e / f : e = c * f) : (f = Math.min(e / c * Math.pow(this.logarithmBase, 0.01), Math.pow(this.logarithmBase, 0.04)), 1 !== e && (e *= f), 1 !== c && (c /= f)) : (e = "undefined" === typeof this.options.interval ? 0 : this.options.interval, c = 1), g = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : e / c > this.logarithmBase ? e / c * Math.pow(this.logarithmBase, 0.5) : this.logarithmBase,
                          this.includeZero && (null === this.minimum || isNaN(this.minimum)) && 1 < c && (c = 1), this.includeZero && (null === this.maximum || isNaN(this.maximum)) && 1 > e && (e = 1)), this.intervalType = "number", null === this.minimum && (this.minimum = "axisX" === this.type ? c / Math.sqrt(g) : Math.pow(this.logarithmBase, this.interval * Math.floor(Math.log(c) / d / this.interval)), this.minimum = Math.min(this.minimum, null === this.sessionVariables.viewportMinimum || isNaN(this.sessionVariables.viewportMinimum) ? "undefined" === typeof this.sessionVariables.newViewportMinimum ?
                            Infinity : this.sessionVariables.newViewportMinimum : this.sessionVariables.viewportMinimum)), null === this.maximum && (this.maximum = "axisX" === this.type ? e * Math.sqrt(g) : Math.pow(this.logarithmBase, this.interval * Math.ceil(Math.log(e) / d / this.interval)), this.maximum = Math.max(this.maximum, null === this.sessionVariables.viewportMaximum || isNaN(this.sessionVariables.viewportMaximum) ? "undefined" === typeof this.sessionVariables.newViewportMaximum ? 0 : this.sessionVariables.newViewportMaximum : this.sessionVariables.viewportMaximum)),
                        1 === this.maximum && 1 === this.minimum && (1 === this.options.minimum ? this.maximum *= this.logarithmBase - 1 / this.logarithmBase : 1 === this.options.maximum && (this.minimum /= this.logarithmBase - 1 / this.logarithmBase)); this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum); this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum); this.viewportMinimum > this.viewportMaximum && (!this.options.viewportMinimum && !this.options.minimum || this.options.viewportMaximum || this.options.maximum ? this.options.viewportMinimum ||
                          this.options.minimum || !this.options.viewportMaximum && !this.options.maximum || (this.viewportMinimum = this.minimum = (this.options.viewportMaximum || this.options.maximum) / Math.pow(this.logarithmBase, 2 * Math.ceil(this.interval))) : this.viewportMaximum = this.maximum = this.options.viewportMinimum || this.options.minimum); c = Math.pow(this.logarithmBase, Math.floor(Math.log(this.viewportMinimum) / (d * this.interval) + 0.2) * this.interval); this.range = this.viewportMaximum / this.viewportMinimum; this.noTicks = a; if (!this.options.interval &&
                            this.range < Math.pow(this.logarithmBase, 8 > this.viewportMaximum || 3 > a ? 2 : 3)) { for (d = Math.floor(this.viewportMinimum / b + 0.5) * b; d < this.viewportMinimum;)d += b; this.equidistantInterval = !1; this.intervalStartPosition = d; this.interval = b } else this.options.interval || (b = Math.ceil(this.interval), this.range > this.interval && (this.interval = b, c = Math.pow(this.logarithmBase, Math.floor(Math.log(this.viewportMinimum) / (d * this.interval) + 0.2) * this.interval))), this.equidistantInterval = !0, this.intervalStartPosition = c; if (!this.valueFormatString &&
                              (this.valueFormatString = "#,##0.##", 1 > this.viewportMinimum)) { d = Math.floor(Math.abs(Math.log(this.viewportMinimum) / Math.LN10)) + 2; if (isNaN(d) || !isFinite(d)) d = 2; if (2 < d) for (f = 0; f < d - 2; f++)this.valueFormatString += "#" }
                    }; B.generateValueFormatString = function (a, d) { var b = "#,##0.", c = d; 1 > a && (c += Math.floor(Math.abs(Math.log(a) / Math.LN10)), isNaN(c) || !isFinite(c)) && (c = d); for (var e = 0; e < c; e++)b += "#"; return b }; B.getNiceExponent = function (a, d) {
                      var b = Math.floor(Math.log(a) / Math.LN10), c = a / Math.pow(10, b), c = 0 > b ? 1 >= c ? 1 : 5 >=
                        c ? 5 : 10 : Math.max(Math.floor(c), 1); return -20 > b ? Number(c * Math.pow(10, b)) : Number((c * Math.pow(10, b)).toFixed(20))
                    }; B.getNiceNumber = function (a, d) { var b = Math.floor(Math.log(a) / Math.LN10), c = a / Math.pow(10, b), c = d ? 1.5 > c ? 1 : 3 > c ? 2 : 7 > c ? 5 : 10 : 1 >= c ? 1 : 2 >= c ? 2 : 5 >= c ? 5 : 10; return -20 > b ? Number(c * Math.pow(10, b)) : Number((c * Math.pow(10, b)).toFixed(20)) }; B.prototype.getLabelStartPoint = function () {
                      var a = U[this.intervalType + "Duration"] * this.interval, a = new Date(Math.floor(this.viewportMinimum / a) * a); if ("millisecond" !== this.intervalType) if ("second" ===
                        this.intervalType) 0 < a.getMilliseconds() && (a.setSeconds(a.getSeconds() + 1), a.setMilliseconds(0)); else if ("minute" === this.intervalType) { if (0 < a.getSeconds() || 0 < a.getMilliseconds()) a.setMinutes(a.getMinutes() + 1), a.setSeconds(0), a.setMilliseconds(0) } else if ("hour" === this.intervalType) { if (0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds()) a.setHours(a.getHours() + 1), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0) } else if ("day" === this.intervalType) {
                          if (0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() ||
                            0 < a.getMilliseconds()) a.setDate(a.getDate() + 1), a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0)
                        } else if ("week" === this.intervalType) { if (0 < a.getDay() || 0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds()) a.setDate(a.getDate() + (7 - a.getDay())), a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0) } else if ("month" === this.intervalType) {
                          if (1 < a.getDate() || 0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds()) a.setMonth(a.getMonth() + 1),
                            a.setDate(1), a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0)
                        } else "year" === this.intervalType && (0 < a.getMonth() || 1 < a.getDate() || 0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds()) && (a.setFullYear(a.getFullYear() + 1), a.setMonth(0), a.setDate(1), a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0)); return a
                    }; V(N, K); V(W, K); W.prototype.createUserOptions = function (a) {
                      if ("undefined" !== typeof a || this.options._isPlaceholder) {
                        var d = 0; this.parent.options._isPlaceholder &&
                          this.parent.createUserOptions(); this.options._isPlaceholder || (Ea(this.parent[this.optionsName]), d = this.parent.options[this.optionsName].indexOf(this.options)); this.options = "undefined" === typeof a ? {} : a; this.parent.options[this.optionsName][d] = this.options
                      }
                    }; W.prototype.render = function (a) {
                      if (0 !== this.spacing || 0 !== this.options.lineThickness && ("undefined" !== typeof this.options.lineThickness || 0 !== this.parent.lineThickness)) {
                        var d = this.ctx, b = this.ctx.globalAlpha; this.ctx = a || this.ctx; this.ctx.save(); this.ctx.beginPath();
                        this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height); this.ctx.clip(); var c = this.scaleBreaks.parent.getPixelCoordinatesOnAxis(this.startValue), e = this.scaleBreaks.parent.getPixelCoordinatesOnAxis(this.endValue); this.ctx.strokeStyle = this.lineColor; this.ctx.fillStyle = this.color; this.ctx.beginPath(); this.ctx.globalAlpha = 1; Q(this.id); var g, f, h, m, l, r; a = Math.max(this.spacing, 3); var p = Math.max(0, this.lineThickness); this.ctx.lineWidth = p; this.ctx.setLineDash &&
                          this.ctx.setLineDash(R(this.lineDashType, p)); if ("bottom" === this.scaleBreaks.parent._position || "top" === this.scaleBreaks.parent._position) if (c = 1 === p % 2 ? (c.x << 0) + 0.5 : c.x << 0, f = 1 === p % 2 ? (e.x << 0) + 0.5 : e.x << 0, "top" === this.scaleBreaks.parent._position ? (e = this.chart.plotArea.y1, h = this.chart.plotArea.y2 + p / 2 + 0.5 << 0) : (e = this.chart.plotArea.y2, h = this.chart.plotArea.y1 - p / 2 + 0.5 << 0, a *= -1), this.bounds = { x1: c - p / 2, y1: e, x2: f + p / 2, y2: h }, this.ctx.moveTo(c, e), "straight" === this.type || "top" === this.scaleBreaks.parent._position &&
                            0 >= a || "bottom" === this.scaleBreaks.parent._position && 0 <= a) this.ctx.lineTo(c, h), this.ctx.lineTo(f, h), this.ctx.lineTo(f, e); else if ("wavy" === this.type) { m = c; l = e; g = 0.5; r = (h - l) / a / 3; for (var q = 0; q < r; q++)this.ctx.bezierCurveTo(m + g * a, l + a, m + g * a, l + 2 * a, m, l + 3 * a), l += 3 * a, g *= -1; this.ctx.bezierCurveTo(m + g * a, l + a, m + g * a, l + 2 * a, m, l + 3 * a); m = f; g *= -1; this.ctx.lineTo(m, l); for (q = 0; q < r; q++)this.ctx.bezierCurveTo(m + g * a, l - a, m + g * a, l - 2 * a, m, l - 3 * a), l -= 3 * a, g *= -1 } else {
                              if ("zigzag" === this.type) {
                                g = -1; l = e + a; m = c + a; r = (h - l) / a / 2; for (q = 0; q < r; q++)this.ctx.lineTo(m,
                                  l), m += 2 * g * a, l += 2 * a, g *= -1; this.ctx.lineTo(m, l); m += f - c; for (q = 0; q < r + 1; q++)this.ctx.lineTo(m, l), m += 2 * g * a, l -= 2 * a, g *= -1; this.ctx.lineTo(m + g * a, l + a)
                              }
                            } else if ("left" === this.scaleBreaks.parent._position || "right" === this.scaleBreaks.parent._position) if (e = 1 === p % 2 ? (e.y << 0) + 0.5 : e.y << 0, h = 1 === p % 2 ? (c.y << 0) + 0.5 : c.y << 0, "left" === this.scaleBreaks.parent._position ? (c = this.chart.plotArea.x1, f = this.chart.plotArea.x2 + p / 2 + 0.5 << 0) : (c = this.chart.plotArea.x2, f = this.chart.plotArea.x1 - p / 2 + 0.5 << 0, a *= -1), this.bounds = {
                              x1: c, y1: e - p /
                                2, x2: f, y2: h + p / 2
                            }, this.ctx.moveTo(c, e), "straight" === this.type || "left" === this.scaleBreaks.parent._position && 0 >= a || "right" === this.scaleBreaks.parent._position && 0 <= a) this.ctx.lineTo(f, e), this.ctx.lineTo(f, h), this.ctx.lineTo(c, h); else if ("wavy" === this.type) {
                              m = c; l = e; g = 0.5; r = (f - m) / a / 3; for (q = 0; q < r; q++)this.ctx.bezierCurveTo(m + a, l + g * a, m + 2 * a, l + g * a, m + 3 * a, l), m += 3 * a, g *= -1; this.ctx.bezierCurveTo(m + a, l + g * a, m + 2 * a, l + g * a, m + 3 * a, l); l = h; g *= -1; this.ctx.lineTo(m, l); for (q = 0; q < r; q++)this.ctx.bezierCurveTo(m - a, l + g * a, m - 2 * a,
                                l + g * a, m - 3 * a, l), m -= 3 * a, g *= -1
                            } else if ("zigzag" === this.type) { g = 1; l = e - a; m = c + a; r = (f - m) / a / 2; for (q = 0; q < r; q++)this.ctx.lineTo(m, l), l += 2 * g * a, m += 2 * a, g *= -1; this.ctx.lineTo(m, l); l += h - e; for (q = 0; q < r + 1; q++)this.ctx.lineTo(m, l), l += 2 * g * a, m -= 2 * a, g *= -1; this.ctx.lineTo(m + a, l + g * a) } 0 < p && this.ctx.stroke(); this.ctx.closePath(); this.ctx.globalAlpha = this.fillOpacity; this.ctx.globalCompositeOperation = "destination-over"; this.ctx.fill(); this.ctx.restore(); this.ctx.globalAlpha = b; this.ctx = d
                      }
                    }; V(M, K); M.prototype.createUserOptions =
                      function (a) { if ("undefined" !== typeof a || this.options._isPlaceholder) { var d = 0; this.parent.options._isPlaceholder && this.parent.createUserOptions(); this.options._isPlaceholder || (Ea(this.parent.stripLines), d = this.parent.options.stripLines.indexOf(this.options)); this.options = "undefined" === typeof a ? {} : a; this.parent.options.stripLines[d] = this.options } }; M.prototype.render = function () {
                        this.ctx.save(); var a = this.parent.getPixelCoordinatesOnAxis(this.value), d = Math.abs("pixel" === this._thicknessType ? this.thickness :
                          this.parent.conversionParameters.pixelPerUnit * this.thickness); if (0 < d) {
                            var b = null === this.opacity ? 1 : this.opacity; this.ctx.strokeStyle = this.color; this.ctx.beginPath(); var c = this.ctx.globalAlpha; this.ctx.globalAlpha = b; Q(this.id); var e, g, f, h; this.ctx.lineWidth = d; this.ctx.setLineDash && this.ctx.setLineDash(R(this.lineDashType, d)); if ("bottom" === this.parent._position || "top" === this.parent._position) e = g = 1 === this.ctx.lineWidth % 2 ? (a.x << 0) + 0.5 : a.x << 0, f = this.chart.plotArea.y1, h = this.chart.plotArea.y2, this.bounds =
                              { x1: e - d / 2, y1: f, x2: g + d / 2, y2: h }; else if ("left" === this.parent._position || "right" === this.parent._position) f = h = 1 === this.ctx.lineWidth % 2 ? (a.y << 0) + 0.5 : a.y << 0, e = this.chart.plotArea.x1, g = this.chart.plotArea.x2, this.bounds = { x1: e, y1: f - d / 2, x2: g, y2: h + d / 2 }; this.ctx.moveTo(e, f); this.ctx.lineTo(g, h); this.ctx.stroke(); this.ctx.globalAlpha = c
                          } this.ctx.restore()
                      }; V(T, K); T.prototype.showAt = function (a) {
                        if (!this.enabled) return !1; var d = this.chart, b = !1; d.resetOverlayedCanvas(); d.clearedOverlayedCanvas = this.parent.type; if ("xySwapped" ===
                          d.plotInfo.axisPlacement) if ("bottom" === this.parent._position) for (var c = 0; c < d.axisY.length; c++)this.parent === d.axisY[c] && (d.axisY[c]._crosshairValue = a >= d.axisY[c].viewportMinimum && a <= d.axisY[c].viewportMaximum ? a : null); else if ("top" === this.parent._position) for (c = 0; c < d.axisY2.length; c++)this.parent === d.axisY2[c] && (d.axisY2[c]._crosshairValue = a >= d.axisY2[c].viewportMinimum && a <= d.axisY2[c].viewportMaximum ? a : null); else if ("left" === this.parent._position) for (c = 0; c < d.axisX.length; c++)this.parent === d.axisX[c] &&
                            (d.axisX[c]._crosshairValue = a >= d.axisX[c].viewportMinimum && a <= d.axisX[c].viewportMaximum ? a : null); else { if ("right" === this.parent._position) for (c = 0; c < d.axisX2.length; c++)this.parent === d.axisX2[c] && (d.axisX2[c]._crosshairValue = a >= d.axisX2[c].viewportMinimum && a <= d.axisX2[c].viewportMaximum ? a : null) } else if ("bottom" === this.parent._position) for (c = 0; c < d.axisX.length; c++)this.parent === d.axisX[c] && (d.axisX[c]._crosshairValue = a >= d.axisX[c].viewportMinimum && a <= d.axisX[c].viewportMaximum ? a : null); else if ("top" ===
                              this.parent._position) for (c = 0; c < d.axisX2.length; c++)this.parent === d.axisX2[c] && (d.axisX2[c]._crosshairValue = a >= d.axisX2[c].viewportMinimum && a <= d.axisX2[c].viewportMaximum ? a : null); else if ("left" === this.parent._position) for (c = 0; c < d.axisY.length; c++)this.parent === d.axisY[c] && (d.axisY[c]._crosshairValue = a >= d.axisY[c].viewportMinimum && a <= d.axisY[c].viewportMaximum ? a : null); else if ("right" === this.parent._position) for (c = 0; c < d.axisY2.length; c++)this.parent === d.axisY2[c] && (d.axisY2[c]._crosshairValue = a >= d.axisY2[c].viewportMinimum &&
                                a <= d.axisY2[c].viewportMaximum ? a : null); for (c = 0; c < d.axisX.length; c++)a = d.axisX[c]._crosshairValue, d.axisX[c].crosshair && (d.axisX[c].crosshair.enabled && !h(a) && a >= d.axisX[c].viewportMinimum && a <= d.axisX[c].viewportMaximum) && (d.axisX[c].showCrosshair(a), d.axisX[c].crosshair._updatedValue = a, this === d.axisX[c].crosshair && (b = !0)); for (c = 0; c < d.axisX2.length; c++)a = d.axisX2[c]._crosshairValue, d.axisX2[c].crosshair && (d.axisX2[c].crosshair.enabled && !h(a) && a >= d.axisX2[c].viewportMinimum && a <= d.axisX2[c].viewportMaximum) &&
                                  (d.axisX2[c].showCrosshair(a), d.axisX2[c].crosshair._updatedValue = a, this === d.axisX2[c].crosshair && (b = !0)); for (c = 0; c < d.axisY.length; c++)a = d.axisY[c]._crosshairValue, d.axisY[c].crosshair && (d.axisY[c].crosshair.enabled && !h(a) && a >= d.axisY[c].viewportMinimum && a <= d.axisY[c].viewportMaximum) && (d.axisY[c].showCrosshair(a), d.axisY[c].crosshair._updatedValue = a, this === d.axisY[c].crosshair && (b = !0)); for (c = 0; c < d.axisY2.length; c++)a = d.axisY2[c]._crosshairValue, d.axisY2[c].crosshair && (d.axisY2[c].crosshair.enabled &&
                                    !h(a) && d._crosshairY2Value >= d.axisY2[c].viewportMinimum && d._crosshairY2Value <= d.axisY2[c].viewportMaximum) && (d.axisY2[c].showCrosshair(a), d.axisY2[c].crosshair._updatedValue = a, this === d.axisY2[c].crosshair && (b = !0)); this.chart.toolTip && this.chart.toolTip._entries && this.chart.toolTip.highlightObjects(this.chart.toolTip._entries); return b
                      }; T.prototype.hide = function () { this.chart.resetOverlayedCanvas(); this.chart.renderCrosshairs(this.parent); this._hidden = !0 }; T.prototype.render = function (a, d, b) {
                        var c, e,
                          g, f, m = null, x = null, l = null, r = ""; if (!this.valueFormatString) if ("dateTime" === this.parent.valueType) this.valueFormatString = this.parent.valueFormatString; else {
                            var p = 0, p = "xySwapped" === this.chart.plotInfo.axisPlacement ? 50 < this.parent.range ? 0 : 500 < this.chart.width && 25 > this.parent.range ? 2 : Math.floor(Math.abs(Math.log(this.parent.range) / Math.LN10)) + (5 > this.parent.range ? 2 : 10 > this.parent.range ? 1 : 0) : 50 < this.parent.range ? 0 : Math.floor(Math.abs(Math.log(this.parent.range) / Math.LN10)) + (5 > this.parent.range ? 2 : 10 > this.parent.range ?
                              1 : 0); this.valueFormatString = B.generateValueFormatString(this.parent.range, p)
                          } var l = null === this.opacity ? 1 : this.opacity, p = Math.abs("pixel" === this._thicknessType ? this.thickness : this.parent.conversionParameters.pixelPerUnit * this.thickness), q = this.chart.overlaidCanvasCtx, k = q.globalAlpha; q.globalAlpha = l; q.beginPath(); q.strokeStyle = this.color; q.lineWidth = p; q.save(); this.labelFontSize = h(this.options.labelFontSize) ? this.parent.labelFontSize : this.labelFontSize; this.labelMaxWidth = h(this.options.labelMaxWidth) ?
                            0.3 * this.chart.width : this.labelMaxWidth; this.labelMaxHeight = h(this.options.labelWrap) || this.labelWrap ? 0.3 * this.chart.height : 2 * this.labelFontSize; 0 < p && q.setLineDash && q.setLineDash(R(this.lineDashType, p)); l = new ja(q, {
                              x: 0, y: 0, padding: { top: 2, right: 3, bottom: 2, left: 4 }, backgroundColor: this.labelBackgroundColor, borderColor: this.labelBorderColor, borderThickness: this.labelBorderThickness, cornerRadius: this.labelCornerRadius, maxWidth: this.labelMaxWidth, maxHeight: this.labelMaxHeight, angle: this.labelAngle, text: r,
                              horizontalAlign: "left", fontSize: this.labelFontSize, fontFamily: this.labelFontFamily, fontWeight: this.labelFontWeight, fontColor: this.labelFontColor, fontStyle: this.labelFontStyle, textBaseline: "middle"
                            }); if (this.snapToDataPoint) {
                              var v = 0, r = []; if ("xySwapped" === this.chart.plotInfo.axisPlacement) {
                                var n = null; if ("bottom" === this.parent._position || "top" === this.parent._position) v = this.parent.dataSeries[0].axisX.convertPixelToValue({ y: d }); else if ("left" === this.parent._position || "right" === this.parent._position) v =
                                  this.parent.convertPixelToValue({ y: d }); for (var s = 0; s < this.parent.dataSeries.length; s++)(n = this.parent.dataSeries[s].getDataPointAtX(v, !0)) && 0 <= n.index && (n.dataSeries = this.parent.dataSeries[s], null !== n.dataPoint.y && r.push(n)); n = null; if (0 === r.length) return; r.sort(function (a, b) { return a.distance - b.distance }); n = Math.abs(a - this.parent.convertValueToPixel(r[0].dataPoint.y)); s = 0; if ("rangeBar" === r[0].dataSeries.type || "error" === r[0].dataSeries.type) for (var n = Math.abs(a - this.parent.convertValueToPixel(r[s].dataPoint.y[0])),
                                    t = 0, v = 0; v < r.length; v++)if (r[v].dataPoint.y && r[v].dataPoint.y.length) for (var z = 0; z < r[v].dataPoint.y.length; z++)t = Math.abs(a - this.parent.convertValueToPixel(r[v].dataPoint.y[z])), t < n && (n = t, s = v); else t = Math.abs(a - this.parent.convertValueToPixel(r[v].dataPoint.y)), t < n && (n = t, s = v); else if ("stackedBar" === r[0].dataSeries.type) for (var n = Math.abs(a - this.parent.convertValueToPixel(r[0].dataPoint.y)), w = t = 0, v = s = 0; v < r.length; v++)if (r[v].dataPoint.y && r[v].dataPoint.y.length) for (z = 0; z < r[v].dataPoint.y.length; z++)t =
                                      Math.abs(a - this.parent.convertValueToPixel(r[v].dataPoint.y[z])), t < n && (n = t, s = v); else w += r[v].dataPoint.y, t = Math.abs(a - this.parent.convertValueToPixel(w)), t < n && (n = t, s = v); else if ("stackedBar100" === r[0].dataSeries.type) for (var n = Math.abs(a - this.parent.convertValueToPixel(r[0].dataPoint.y)), y = w = t = 0, v = 0; v < r.length; v++)if (r[v].dataPoint.y && r[v].dataPoint.y.length) for (z = 0; z < r[v].dataPoint.y.length; z++)t = Math.abs(a - this.parent.convertValueToPixel(r[v].dataPoint.y[z])), t < n && (n = t, s = v); else w += r[v].dataPoint.y,
                                        y = r[v].dataPoint.x.getTime ? r[v].dataPoint.x.getTime() : r[v].dataPoint.x, y = 100 * (w / r[v].dataSeries.plotUnit.dataPointYSums[y]), t = Math.abs(a - this.parent.convertValueToPixel(y)), t < n && (n = t, s = v); else for (n = Math.abs(a - this.parent.convertValueToPixel(r[0].dataPoint.y)), v = s = t = 0; v < r.length; v++)if (r[v].dataPoint.y && r[v].dataPoint.y.length) for (z = 0; z < r[v].dataPoint.y.length; z++)t = Math.abs(a - this.parent.convertValueToPixel(r[v].dataPoint.y[z])), t < n && (n = t, s = v); else t = Math.abs(a - this.parent.convertValueToPixel(r[v].dataPoint.y)),
                                          t < n && (n = t, s = v); z = r[s]; if ("bottom" === this.parent._position || "top" === this.parent._position) {
                                            c = 0; if ("rangeBar" === this.parent.dataSeries[s].type || "error" === this.parent.dataSeries[s].type) {
                                              n = Math.abs(a - this.parent.convertValueToPixel(z.dataPoint.y[0])); for (v = t = 0; v < z.dataPoint.y.length; v++)t = Math.abs(a - this.parent.convertValueToPixel(z.dataPoint.y[v])), t < n && (n = t, c = v); m = 1 === q.lineWidth % 2 ? (this.parent.convertValueToPixel(z.dataPoint.y[c]) << 0) + 0.5 : this.parent.convertValueToPixel(z.dataPoint.y[c]) << 0; l.text =
                                                this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: b ? b : z.dataPoint.y[c] }) : h(this.options.label) ? Z(b ? b : z.dataPoint.y[c], this.valueFormatString, this.chart._cultureInfo) : this.label
                                            } else if ("stackedBar" === this.parent.dataSeries[s].type) {
                                              n = Math.abs(a - this.parent.convertValueToPixel(r[0].dataPoint.y)); w = t = 0; for (v = s; 0 <= v; v--)w += r[v].dataPoint.y, t = Math.abs(a - this.parent.convertValueToPixel(w)), t < n && (n = t, c = v); m = 1 === q.lineWidth % 2 ? (this.parent.convertValueToPixel(w) <<
                                                0) + 0.5 : this.parent.convertValueToPixel(w) << 0; l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: b ? b : z.dataPoint.y }) : h(this.options.label) ? Z(b ? b : z.dataPoint.y, this.valueFormatString, this.chart._cultureInfo) : this.label
                                            } else if ("stackedBar100" === this.parent.dataSeries[s].type) {
                                              n = Math.abs(a - this.parent.convertValueToPixel(r[0].dataPoint.y)); y = w = t = 0; for (v = s; 0 <= v; v--)w += r[v].dataPoint.y, y = r[v].dataPoint.x.getTime ? r[v].dataPoint.x.getTime() :
                                                r[v].dataPoint.x, y = 100 * (w / r[v].dataSeries.plotUnit.dataPointYSums[y]), t = Math.abs(a - this.parent.convertValueToPixel(y)), t < n && (n = t, c = v); m = 1 === q.lineWidth % 2 ? (this.parent.convertValueToPixel(y) << 0) + 0.5 : this.parent.convertValueToPixel(y) << 0; l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: b ? b : y }) : h(this.options.label) ? Z(b ? b : y, this.valueFormatString, this.chart._cultureInfo) : this.label
                                            } else m = 1 === q.lineWidth % 2 ? (this.parent.convertValueToPixel(z.dataPoint.y) <<
                                              0) + 0.5 : this.parent.convertValueToPixel(z.dataPoint.y) << 0, l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: b ? b : z.dataPoint.y }) : h(this.options.label) ? Z(b ? b : z.dataPoint.y, this.valueFormatString, this.chart._cultureInfo) : this.label; c = e = m; g = this.chart.plotArea.y1; f = this.chart.plotArea.y2; this.bounds = { x1: c - p / 2, y1: g, x2: e + p / 2, y2: f }; l.x = c - l.measureText().width / 2; l.x + l.width > this.chart.bounds.x2 ? l.x = this.chart.bounds.x2 - l.width : l.x < this.chart.bounds.x1 &&
                                                (l.x = this.chart.bounds.x1); l.y = this.parent.lineCoordinates.y2 + l.fontSize / 2 + 2; l.y + l.height > this.chart.bounds.y2 ? l.y = this.chart.bounds.y2 - l.height : l.y < this.chart.bounds.y1 && (l.y = this.chart.bounds.y1)
                                          } else if ("left" === this.parent._position || "right" === this.parent._position) {
                                            g = f = x = 1 === q.lineWidth % 2 ? (this.parent.convertValueToPixel(z.dataPoint.x) << 0) + 0.5 : this.parent.convertValueToPixel(z.dataPoint.x) << 0; c = this.chart.plotArea.x1; e = this.chart.plotArea.x2; this.bounds = { x1: c, y1: g - p / 2, x2: e, y2: f + p / 2 }; y = !1; if (this.parent.labels) for (r =
                                              Math.ceil(this.parent.interval), v = 0; v < this.parent.viewportMaximum; v += r)if (this.parent.labels[v]) y = !0; else { y = !1; break } if (y) { if ("axisX" === this.parent.type) for (v = this.parent.convertPixelToValue({ y: d }), n = null, s = 0; s < this.parent.dataSeries.length; s++)(n = this.parent.dataSeries[s].getDataPointAtX(v, !0)) && 0 <= n.index && (l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: z.dataPoint.x }) : h(this.options.label) ? n.dataPoint.label : this.label) } else "dateTime" ===
                                                this.parent.valueType ? l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: b ? b : z.dataPoint.x }) : h(this.options.label) ? ka(b ? b : z.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label : "number" === this.parent.valueType && (l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: b ? b : z.dataPoint.x }) : h(this.options.label) ? Z(b ? b : z.dataPoint.x, this.valueFormatString,
                                                  this.chart._cultureInfo) : this.label); l.y = f + l.fontSize / 2 - l.measureText().height / 2 + 2; l.y - l.fontSize / 2 < this.chart.bounds.y1 ? l.y = this.chart.bounds.y1 + l.fontSize / 2 + 2 : l.y + l.measureText().height - l.fontSize / 2 > this.chart.bounds.y2 && (l.y = this.chart.bounds.y2 - l.measureText().height + l.fontSize / 2); "left" === this.parent._position ? l.x = this.parent.lineCoordinates.x2 - l.measureText().width : "right" === this.parent._position && (l.x = this.parent.lineCoordinates.x2)
                                          }
                              } else if ("bottom" === this.parent._position || "top" === this.parent._position) {
                                v =
                                  this.parent.convertPixelToValue({ x: a }); for (s = 0; s < this.parent.dataSeries.length; s++)(n = this.parent.dataSeries[s].getDataPointAtX(v, !0)) && 0 <= n.index && (n.dataSeries = this.parent.dataSeries[s], null !== n.dataPoint.y && r.push(n)); if (0 === r.length) return; r.sort(function (a, b) { return a.distance - b.distance }); z = r[0]; c = e = m = 1 === q.lineWidth % 2 ? (this.parent.convertValueToPixel(z.dataPoint.x) << 0) + 0.5 : this.parent.convertValueToPixel(z.dataPoint.x) << 0; g = this.chart.plotArea.y1; f = this.chart.plotArea.y2; this.bounds = {
                                    x1: c -
                                      p / 2, y1: g, x2: e + p / 2, y2: f
                                  }; y = !1; if (this.parent.labels) for (r = Math.ceil(this.parent.interval), v = 0; v < this.parent.viewportMaximum; v += r)if (this.parent.labels[v]) y = !0; else { y = !1; break } if (y) {
                                    if ("axisX" === this.parent.type) for (v = this.parent.convertPixelToValue({ x: a }), n = null, s = 0; s < this.parent.dataSeries.length; s++)(n = this.parent.dataSeries[s].getDataPointAtX(v, !0)) && 0 <= n.index && (l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: z.dataPoint.x }) :
                                      h(this.options.label) ? n.dataPoint.label : this.label)
                                  } else "dateTime" === this.parent.valueType ? l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: z.dataPoint.x }) : h(this.options.label) ? ka(b ? b : z.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label : "number" === this.parent.valueType && (l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: z.dataPoint.x }) : h(this.options.label) ?
                                    Z(b ? b : z.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label); this.value = z.dataPoint.x; l.x = c - l.measureText().width / 2; l.x + l.width > this.chart.bounds.x2 && (l.x = this.chart.bounds.x2 - l.width); l.x < this.chart.bounds.x1 && (l.x = this.chart.bounds.x1); "bottom" === this.parent._position ? l.y = this.parent.lineCoordinates.y2 + l.fontSize / 2 + 2 : "top" === this.parent._position && (l.y = this.parent.lineCoordinates.y1 - l.height + l.fontSize / 2 + 2)
                              } else if ("left" === this.parent._position || "right" === this.parent._position) {
                                !h(this.parent.dataSeries) &&
                                  0 < this.parent.dataSeries.length && (v = this.parent.dataSeries[0].axisX.convertPixelToValue({ x: a })); for (s = 0; s < this.parent.dataSeries.length; s++)(n = this.parent.dataSeries[s].getDataPointAtX(v, !0)) && 0 <= n.index && (n.dataSeries = this.parent.dataSeries[s], null !== n.dataPoint.y && r.push(n)); if (0 === r.length) return; r.sort(function (a, b) { return a.distance - b.distance }); s = 0; if ("rangeColumn" === r[0].dataSeries.type || "rangeArea" === r[0].dataSeries.type || "error" === r[0].dataSeries.type || "rangeSplineArea" === r[0].dataSeries.type ||
                                    "candlestick" === r[0].dataSeries.type || "ohlc" === r[0].dataSeries.type || "boxAndWhisker" === r[0].dataSeries.type) for (n = Math.abs(d - this.parent.convertValueToPixel(r[0].dataPoint.y[0])), v = t = 0; v < r.length; v++)if (r[v].dataPoint.y && r[v].dataPoint.y.length) for (z = 0; z < r[v].dataPoint.y.length; z++)t = Math.abs(d - this.parent.convertValueToPixel(r[v].dataPoint.y[z])), t < n && (n = t, s = v); else t = Math.abs(d - this.parent.convertValueToPixel(r[v].dataPoint.y)), t < n && (n = t, s = v); else if ("stackedColumn" === r[0].dataSeries.type || "stackedArea" ===
                                      r[0].dataSeries.type) for (n = Math.abs(d - this.parent.convertValueToPixel(r[0].dataPoint.y)), v = w = t = 0; v < r.length; v++)if (r[v].dataPoint.y && r[v].dataPoint.y.length) for (z = 0; z < r[v].dataPoint.y.length; z++)t = Math.abs(d - this.parent.convertValueToPixel(r[v].dataPoint.y[z])), t < n && (n = t, s = v); else w += r[v].dataPoint.y, t = Math.abs(d - this.parent.convertValueToPixel(w)), t < n && (n = t, s = v); else if ("stackedColumn100" === r[0].dataSeries.type || "stackedArea100" === r[0].dataSeries.type) for (n = Math.abs(d - this.parent.convertValueToPixel(r[0].dataPoint.y)),
                                        v = y = w = t = 0; v < r.length; v++)if (r[v].dataPoint.y && r[v].dataPoint.y.length) for (z = 0; z < r[v].dataPoint.y.length; z++)t = Math.abs(d - this.parent.convertValueToPixel(r[v].dataPoint.y[z])), t < n && (n = t, s = v); else w += r[v].dataPoint.y, y = r[v].dataPoint.x.getTime ? r[v].dataPoint.x.getTime() : r[v].dataPoint.x, y = 100 * (w / r[v].dataSeries.plotUnit.dataPointYSums[y]), t = Math.abs(d - this.parent.convertValueToPixel(y)), t < n && (n = t, s = v); else for (n = Math.abs(d - this.parent.convertValueToPixel(r[0].dataPoint.y)), v = t = 0; v < r.length; v++)if (r[v].dataPoint.y &&
                                          r[v].dataPoint.y.length) for (z = 0; z < r[v].dataPoint.y.length; z++)t = Math.abs(d - this.parent.convertValueToPixel(r[v].dataPoint.y[z])), t < n && (n = t, s = v); else t = Math.abs(d - this.parent.convertValueToPixel(r[v].dataPoint.y)), t < n && (n = t, s = v); z = r[s]; c = 0; if ("rangeColumn" === this.parent.dataSeries[s].type || "rangeArea" === this.parent.dataSeries[s].type || "error" === this.parent.dataSeries[s].type || "rangeSplineArea" === this.parent.dataSeries[s].type || "candlestick" === this.parent.dataSeries[s].type || "ohlc" === this.parent.dataSeries[s].type ||
                                            "boxAndWhisker" === this.parent.dataSeries[s].type) {
                                  n = Math.abs(d - this.parent.convertValueToPixel(z.dataPoint.y[0])); for (v = t = 0; v < z.dataPoint.y.length; v++)t = Math.abs(d - this.parent.convertValueToPixel(z.dataPoint.y[v])), t < n && (n = t, c = v); x = 1 === q.lineWidth % 2 ? (this.parent.convertValueToPixel(z.dataPoint.y[c]) << 0) + 0.5 : this.parent.convertValueToPixel(z.dataPoint.y[c]) << 0; l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: b ? b : z.dataPoint.y[c] }) :
                                    h(this.options.label) ? Z(b ? b : z.dataPoint.y[c], this.valueFormatString, this.chart._cultureInfo) : this.label; this.value = z.dataPoint.y[c]
                                } else if ("stackedColumn" === this.parent.dataSeries[s].type || "stackedArea" === this.parent.dataSeries[s].type) {
                                  n = Math.abs(d - this.parent.convertValueToPixel(r[0].dataPoint.y)); w = t = 0; for (v = s; 0 <= v; v--)w += r[v].dataPoint.y, t = Math.abs(d - this.parent.convertValueToPixel(w)), t < n && (n = t, c = v); x = 1 === q.lineWidth % 2 ? (this.parent.convertValueToPixel(w) << 0) + 0.5 : this.parent.convertValueToPixel(w) <<
                                    0; l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: b ? b : z.dataPoint.y }) : h(this.options.label) ? Z(b ? b : z.dataPoint.y, this.valueFormatString, this.chart._cultureInfo) : this.label; this.value = w
                                } else if ("stackedColumn100" === this.parent.dataSeries[s].type || "stackedArea100" === this.parent.dataSeries[s].type) {
                                  n = Math.abs(d - this.parent.convertValueToPixel(r[0].dataPoint.y)); w = t = 0; for (v = s; 0 <= v; v--)w += r[v].dataPoint.y, y = r[v].dataPoint.x.getTime ?
                                    r[v].dataPoint.x.getTime() : r[v].dataPoint.x, y = 100 * (w / r[v].dataSeries.plotUnit.dataPointYSums[y]), t = Math.abs(d - this.parent.convertValueToPixel(y)), t < n && (n = t, c = v); x = 1 === q.lineWidth % 2 ? (this.parent.convertValueToPixel(y) << 0) + 0.5 : this.parent.convertValueToPixel(y) << 0; l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: b ? b : y }) : h(this.options.label) ? Z(b ? b : y, this.valueFormatString, this.chart._cultureInfo) : this.label; this.value = y
                                } else "waterfall" ===
                                  this.parent.dataSeries[s].type ? (x = 1 === q.lineWidth % 2 ? (this.parent.convertValueToPixel(z.dataSeries.dataPointEOs[z.index].cumulativeSum) << 0) + 0.5 : this.parent.convertValueToPixel(z.dataSeries.dataPointEOs[z.index].cumulativeSum) << 0, l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: b ? b : z.dataSeries.dataPointEOs[z.index].cumulativeSum }) : h(this.options.label) ? Z(b ? b : z.dataSeries.dataPointEOs[z.index].cumulativeSum, this.valueFormatString,
                                    this.chart._cultureInfo) : this.label, this.value = z.dataSeries.dataPointEOs[z.index].cumulativeSum) : (x = 1 === q.lineWidth % 2 ? (h(a) ? d : this.parent.convertValueToPixel(z.dataPoint.y) << 0) + 0.5 : h(a) ? d : this.parent.convertValueToPixel(z.dataPoint.y) << 0, l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: z.dataPoint.y }) : h(this.options.label) ? Z(b ? b : z.dataPoint.y, this.valueFormatString, this.chart._cultureInfo) : this.label, this.value = z.dataPoint.y); g =
                                      f = x; c = this.chart.plotArea.x1; e = this.chart.plotArea.x2; this.bounds = { x1: c, y1: g - p / 2, x2: e, y2: f + p / 2 }; l.y = f + l.fontSize / 2 - l.measureText().height / 2 + 2; l.y - l.fontSize / 2 < this.chart.bounds.y1 ? l.y = this.chart.bounds.y1 + l.fontSize / 2 + 2 : l.y + l.measureText().height - l.fontSize / 2 > this.chart.bounds.y2 && (l.y = this.chart.bounds.y2 - l.measureText().height + l.fontSize / 2); "left" === this.parent._position ? l.x = this.parent.lineCoordinates.x2 - l.measureText().width : "right" === this.parent._position && (l.x = this.parent.lineCoordinates.x2)
                              } r =
                                null; if ("bottom" === this.parent._position || "top" === this.parent._position) "top" === this.parent._position && l.y - l.fontSize / 2 < this.chart.bounds.y1 && (l.y = this.chart.bounds.y1 + l.fontSize / 2), "bottom" === this.parent._position && this.parent.lineCoordinates.y2 - l.fontSize / 2 + l.measureText().height > this.chart.bounds.y2 && (l.y = this.chart.bounds.y2 - l.height + l.fontSize / 2 + 2), c >= this.parent.convertValueToPixel(this.parent.viewportMinimum) && e <= this.parent.convertValueToPixel(this.parent.viewportMaximum) && (0 < p && (q.moveTo(c,
                                  g), q.lineTo(e, f), q.stroke(), this._hidden = !1), q.restore(), !h(l.text) && ("number" === typeof l.text.valueOf() || 0 < l.text.length) && l.render(!0)); if ("left" === this.parent._position || "right" === this.parent._position) "left" === this.parent._position && l.x < this.chart.bounds.x1 && (l.x = this.chart.bounds.x1), "right" === this.parent._position && l.x + l.measureText().width > this.chart.bounds.x2 && (l.x = this.chart.bounds.x2 - l.measureText().width), f >= this.parent.convertValueToPixel(this.parent.viewportMaximum) && g <= this.parent.convertValueToPixel(this.parent.viewportMinimum) &&
                                    (0 < p && (q.moveTo(c, g), q.lineTo(e, f), q.stroke(), this._hidden = !1), q.restore(), !h(l.text) && ("number" === typeof l.text.valueOf() || 0 < l.text.length) && l.render(!0))
                            } else {
                          if ("bottom" === this.parent._position || "top" === this.parent._position) c = e = m = 1 === q.lineWidth % 2 ? (a << 0) + 0.5 : a << 0, g = this.chart.plotArea.y1, f = this.chart.plotArea.y2, this.bounds = { x1: c - p / 2, y1: g, x2: e + p / 2, y2: f }; else if ("left" === this.parent._position || "right" === this.parent._position) g = f = x = 1 === q.lineWidth % 2 ? (d << 0) + 0.5 : d << 0, c = this.chart.plotArea.x1, e = this.chart.plotArea.x2,
                            this.bounds = { x1: c, y1: g - p / 2, x2: e, y2: f + p / 2 }; if ("xySwapped" === this.chart.plotInfo.axisPlacement) if ("left" === this.parent._position || "right" === this.parent._position) {
                              y = !1; if (this.parent.labels) for (r = Math.ceil(this.parent.interval), v = 0; v < this.parent.viewportMaximum; v += r)if (this.parent.labels[v]) y = !0; else { y = !1; break } if (y) {
                                if ("axisX" === this.parent.type) for (v = this.parent.convertPixelToValue({ y: d }), n = null, s = 0; s < this.parent.dataSeries.length; s++)(n = this.parent.dataSeries[s].getDataPointAtX(v, !0)) && 0 <= n.index &&
                                  (l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: b ? b : this.parent.convertPixelToValue(a) }) : h(this.options.label) ? n.dataPoint.label : this.label)
                              } else "dateTime" === this.parent.valueType ? l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: b ? b : this.parent.convertPixelToValue(d) }) : h(this.options.label) ? ka(b ? b : this.parent.convertPixelToValue(d), this.valueFormatString, this.chart._cultureInfo) :
                                this.label : "number" === this.parent.valueType && (l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: b ? b : this.parent.convertPixelToValue(d) }) : h(this.options.label) ? Z(b ? b : this.parent.convertPixelToValue(d), this.valueFormatString, this.chart._cultureInfo) : this.label); l.y = d + l.fontSize / 2 - l.measureText().height / 2 + 2; l.y - l.fontSize / 2 < this.chart.bounds.y1 ? l.y = this.chart.bounds.y1 + l.fontSize / 2 + 2 : l.y + l.measureText().height - l.fontSize / 2 > this.chart.bounds.y2 &&
                                  (l.y = this.chart.bounds.y2 - l.measureText().height + l.fontSize / 2); "left" === this.parent._position ? l.x = this.parent.lineCoordinates.x1 - l.measureText().width : "right" === this.parent._position && (l.x = this.parent.lineCoordinates.x2)
                            } else {
                              if ("bottom" === this.parent._position || "top" === this.parent._position) l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: b ? b : this.parent.convertPixelToValue(a) }) : h(this.options.label) ? Z(b ? b : this.parent.convertPixelToValue(a),
                                this.valueFormatString, this.chart._cultureInfo) : this.label, l.x = c - l.measureText().width / 2, l.x + l.width > this.chart.bounds.x2 && (l.x = this.chart.bounds.x2 - l.width), l.x < this.chart.bounds.x1 && (l.x = this.chart.bounds.x1), "bottom" === this.parent._position ? l.y = this.parent.lineCoordinates.y2 + l.fontSize / 2 + 2 : "top" === this.parent._position && (l.y = this.parent.lineCoordinates.y1 - l.height + l.fontSize / 2 + 2)
                            } else if ("bottom" === this.parent._position || "top" === this.parent._position) {
                              y = !1; r = ""; if (this.parent.labels) for (r = Math.ceil(this.parent.interval),
                                v = 0; v < this.parent.viewportMaximum; v += r)if (this.parent.labels[v]) y = !0; else { y = !1; break } if (y) { if ("axisX" === this.parent.type) for (v = this.parent.convertPixelToValue({ x: a }), n = null, s = 0; s < this.parent.dataSeries.length; s++)(n = this.parent.dataSeries[s].getDataPointAtX(v, !0)) && 0 <= n.index && (l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: b ? b : this.parent.convertPixelToValue(a) }) : h(this.options.label) ? b ? b : n.dataPoint.label : this.label) } else "dateTime" ===
                                  this.parent.valueType ? l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: b ? b : this.parent.convertPixelToValue(a) }) : h(this.options.label) ? ka(b ? b : this.parent.convertPixelToValue(a), this.valueFormatString, this.chart._cultureInfo) : this.label : "number" === this.parent.valueType && (l.text = this.labelFormatter ? this.labelFormatter({
                                    chart: this.chart, axis: this.parent.options, crosshair: this.options, value: b ? b : 0 < this.parent.dataSeries.length ? this.parent.convertPixelToValue(a) :
                                      ""
                                  }) : h(this.options.label) ? Z(b ? b : this.parent.convertPixelToValue(a), this.valueFormatString, this.chart._cultureInfo) : this.label); l.x = c - l.measureText().width / 2; l.x + l.width > this.chart.bounds.x2 && (l.x = this.chart.bounds.x2 - l.width); l.x < this.chart.bounds.x1 && (l.x = this.chart.bounds.x1); "bottom" === this.parent._position ? l.y = this.parent.lineCoordinates.y2 + l.fontSize / 2 + 2 : "top" === this.parent._position && (l.y = this.parent.lineCoordinates.y1 - l.height + l.fontSize / 2 + 2)
                            } else if ("left" === this.parent._position || "right" ===
                              this.parent._position) l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: b ? b : this.parent.convertPixelToValue(d) }) : h(this.options.label) ? Z(b ? b : this.parent.convertPixelToValue(d), this.valueFormatString, this.chart._cultureInfo) : this.label, l.y = d + l.fontSize / 2 - l.measureText().height / 2 + 2, l.y - l.fontSize / 2 < this.chart.bounds.y1 ? l.y = this.chart.bounds.y1 + l.fontSize / 2 + 2 : l.y + l.measureText().height - l.fontSize / 2 > this.chart.bounds.y2 && (l.y = this.chart.bounds.y2 -
                                l.measureText().height + l.fontSize / 2), "left" === this.parent._position ? l.x = this.parent.lineCoordinates.x2 - l.measureText().width : "right" === this.parent._position && (l.x = this.parent.lineCoordinates.x2); "left" === this.parent._position && l.x < this.chart.bounds.x1 ? l.x = this.chart.bounds.x1 : "right" === this.parent._position && l.x + l.measureText().width > this.chart.bounds.x2 ? l.x = this.chart.bounds.x2 - l.measureText().width : "top" === this.parent._position && l.y - l.fontSize / 2 < this.chart.bounds.y1 ? l.y = this.chart.bounds.y1 + l.fontSize /
                                  2 : "bottom" === this.parent._position && this.parent.lineCoordinates.y2 - l.fontSize / 2 + l.measureText().height > this.chart.bounds.y2 && (l.y = this.chart.bounds.y2 - l.height + l.fontSize / 2 + 2); 0 < p && (q.moveTo(c, g), q.lineTo(e, f), q.stroke(), this._hidden = !1); q.restore(); !h(l.text) && ("number" === typeof l.text.valueOf() || 0 < l.text.length) && l.render(!0); this.value = "bottom" === this.parent._position || "top" === this.parent._position ? this.parent.convertPixelToValue(a) : this.parent.convertPixelToValue(d)
                        } if ("bottom" === this.parent._position ||
                          "top" === this.parent._position) this._updatedValue = this.parent.convertPixelToValue(m); if ("left" === this.parent._position || "right" === this.parent._position) this._updatedValue = this.parent.convertPixelToValue(x); q.globalAlpha = k
                      }; V(la, K); la.prototype._initialize = function () {
                        this.updateOption("updated"); this.updateOption("hidden"); if (this.enabled) {
                          this.container = document.createElement("div"); this.container.setAttribute("class", "canvasjs-chart-tooltip"); this.container.style.position = "absolute"; this.container.style.height =
                            "auto"; this.container.style.boxShadow = "1px 1px 2px 2px rgba(0,0,0,0.1)"; this.container.style.zIndex = "1000"; this.container.style.pointerEvents = "none"; this.container.style.display = "none"; var a; a = '<div style=" width: auto;height: auto;min-width: 50px;'; a += "line-height: auto;"; a += "margin: 0px 0px 0px 0px;"; a += "padding: 5px;"; a += "font-family: Calibri, Arial, Georgia, serif;"; a += "font-weight: normal;"; a += "font-style: " + (s ? "italic;" : "normal;"); a += "font-size: 14px;"; a += "color: #000000;"; a += "text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.1);";
                          a += "text-align: left;"; a += "border: 2px solid gray;"; a += s ? "background: rgba(255,255,255,.9);" : "background: rgb(255,255,255);"; a += "text-indent: 0px;"; a += "white-space: nowrap;"; a += "border-radius: 5px;"; a += "-moz-user-select:none;"; a += "-khtml-user-select: none;"; a += "-webkit-user-select: none;"; a += "-ms-user-select: none;"; a += "user-select: none;"; s || (a += "filter: alpha(opacity = 90);", a += "filter: progid:DXImageTransform.Microsoft.Shadow(Strength=3, Direction=135, Color='#666666');"); a += '} "> Sample Tooltip</div>';
                          this.container.innerHTML = a; this.contentDiv = this.container.firstChild; this.container.style.borderRadius = this.contentDiv.style.borderRadius; this.chart._canvasJSContainer.appendChild(this.container)
                        }
                      }; la.prototype.mouseMoveHandler = function (a, d) { this._lastUpdated && 4 > (new Date).getTime() - this._lastUpdated || (this._lastUpdated = (new Date).getTime(), this.chart.resetOverlayedCanvas(), this._updateToolTip(a, d)) }; la.prototype._updateToolTip = function (a, d, b) {
                        b = "undefined" === typeof b ? !0 : b; this.container || this._initialize();
                        this.enabled || (this.hide(), this.dispatchEvent("hidden", { chart: this.chart, toolTip: this }, this)); if (!this.chart.disableToolTip) {
                          if ("undefined" === typeof a || "undefined" === typeof d) { if (isNaN(this._prevX) || isNaN(this._prevY)) return; a = this._prevX; d = this._prevY } else this._prevX = a, this._prevY = d; var c = null, e = null, g = [], f = 0; if (this.shared && this.enabled && "none" !== this.chart.plotInfo.axisPlacement) {
                            if ("xySwapped" === this.chart.plotInfo.axisPlacement) {
                              var m = []; if (this.chart.axisX) for (var v = 0; v < this.chart.axisX.length; v++) {
                                for (var f =
                                  this.chart.axisX[v].convertPixelToValue({ y: d }), l = null, c = 0; c < this.chart.axisX[v].dataSeries.length; c++)(l = this.chart.axisX[v].dataSeries[c].getDataPointAtX(f, b)) && 0 <= l.index && (l.dataSeries = this.chart.axisX[v].dataSeries[c], null !== l.dataPoint.y && m.push(l)); l = null
                              } if (this.chart.axisX2) for (v = 0; v < this.chart.axisX2.length; v++) {
                                f = this.chart.axisX2[v].convertPixelToValue({ y: d }); l = null; for (c = 0; c < this.chart.axisX2[v].dataSeries.length; c++)(l = this.chart.axisX2[v].dataSeries[c].getDataPointAtX(f, b)) && 0 <= l.index &&
                                  (l.dataSeries = this.chart.axisX2[v].dataSeries[c], null !== l.dataPoint.y && m.push(l)); l = null
                              }
                            } else {
                              m = []; if (this.chart.axisX) for (v = 0; v < this.chart.axisX.length; v++)for (f = this.chart.axisX[v].convertPixelToValue({ x: a }), l = null, c = 0; c < this.chart.axisX[v].dataSeries.length; c++)(l = this.chart.axisX[v].dataSeries[c].getDataPointAtX(f, b)) && 0 <= l.index && (l.dataSeries = this.chart.axisX[v].dataSeries[c], null !== l.dataPoint.y && m.push(l)); if (this.chart.axisX2) for (v = 0; v < this.chart.axisX2.length; v++)for (f = this.chart.axisX2[v].convertPixelToValue({ x: a }),
                                l = null, c = 0; c < this.chart.axisX2[v].dataSeries.length; c++)(l = this.chart.axisX2[v].dataSeries[c].getDataPointAtX(f, b)) && 0 <= l.index && (l.dataSeries = this.chart.axisX2[v].dataSeries[c], null !== l.dataPoint.y && m.push(l))
                            } if (0 === m.length) return; m.sort(function (a, b) { return a.distance - b.distance }); b = m[0]; for (c = 0; c < m.length; c++)m[c].dataPoint.x.valueOf() === b.dataPoint.x.valueOf() && g.push(m[c]); m = null
                          } else {
                            if (l = this.chart.getDataPointAtXY(a, d, b)) this.currentDataPointIndex = l.dataPointIndex, this.currentSeriesIndex =
                              l.dataSeries.index; else if (s) if (l = jb(a, d, this.chart._eventManager.ghostCtx), 0 < l && "undefined" !== typeof this.chart._eventManager.objectMap[l]) { l = this.chart._eventManager.objectMap[l]; if ("legendItem" === l.objectType) return; this.currentSeriesIndex = l.dataSeriesIndex; this.currentDataPointIndex = 0 <= l.dataPointIndex ? l.dataPointIndex : -1 } else this.currentDataPointIndex = -1; else this.currentDataPointIndex = -1; if (0 <= this.currentSeriesIndex) {
                                e = this.chart.data[this.currentSeriesIndex]; l = {}; if (0 <= this.currentDataPointIndex) c =
                                  e.dataPoints[this.currentDataPointIndex], l.dataSeries = e, l.dataPoint = c, l.index = this.currentDataPointIndex, l.distance = Math.abs(c.x - f), "waterfall" === e.type && (l.cumulativeSumYStartValue = e.dataPointEOs[this.currentDataPointIndex].cumulativeSumYStartValue, l.cumulativeSum = e.dataPointEOs[this.currentDataPointIndex].cumulativeSum); else {
                                  if (!this.enabled || "line" !== e.type && "stepLine" !== e.type && "spline" !== e.type && "area" !== e.type && "stepArea" !== e.type && "splineArea" !== e.type && "stackedArea" !== e.type && "stackedArea100" !==
                                    e.type && "rangeArea" !== e.type && "rangeSplineArea" !== e.type && "candlestick" !== e.type && "ohlc" !== e.type && "boxAndWhisker" !== e.type) return; f = e.axisX.convertPixelToValue({ x: a }); l = e.getDataPointAtX(f, b); h(l) || (l.dataSeries = e, this.currentDataPointIndex = l.index, c = l.dataPoint)
                                } if (!h(l) && !h(l.dataPoint) && !h(l.dataPoint.y)) if (l.dataSeries.axisY) if (0 < l.dataPoint.y.length) {
                                  for (c = b = 0; c < l.dataPoint.y.length; c++)l.dataPoint.y[c] < l.dataSeries.axisY.viewportMinimum ? b-- : l.dataPoint.y[c] > l.dataSeries.axisY.viewportMaximum &&
                                    b++; b < l.dataPoint.y.length && b > -l.dataPoint.y.length && g.push(l)
                                } else "column" === e.type || "bar" === e.type ? 0 > l.dataPoint.y ? 0 > l.dataSeries.axisY.viewportMinimum && l.dataSeries.axisY.viewportMaximum >= l.dataPoint.y && g.push(l) : l.dataSeries.axisY.viewportMinimum <= l.dataPoint.y && 0 <= l.dataSeries.axisY.viewportMaximum && g.push(l) : "bubble" === e.type ? (b = this.chart._eventManager.objectMap[e.dataPointIds[l.index]].size / 2, l.dataPoint.y >= l.dataSeries.axisY.viewportMinimum - b && l.dataPoint.y <= l.dataSeries.axisY.viewportMaximum +
                                  b && g.push(l)) : "waterfall" === e.type ? (b = 0, l.cumulativeSumYStartValue < l.dataSeries.axisY.viewportMinimum ? b-- : l.cumulativeSumYStartValue > l.dataSeries.axisY.viewportMaximum && b++, l.cumulativeSum < l.dataSeries.axisY.viewportMinimum ? b-- : l.cumulativeSum > l.dataSeries.axisY.viewportMaximum && b++, 2 > b && -2 < b && g.push(l)) : (0 <= l.dataSeries.type.indexOf("100") || "stackedColumn" === e.type || "stackedBar" === e.type || l.dataPoint.y >= l.dataSeries.axisY.viewportMinimum && l.dataPoint.y <= l.dataSeries.axisY.viewportMaximum) && g.push(l);
                                else g.push(l)
                              }
                          } if (0 < g.length) {
                            this.highlightObjects(g); if (this.enabled) {
                              var r = "", r = this.getToolTipInnerHTML({ entries: g }); if (null !== r) {
                                this.contentDiv.innerHTML = r; b = !1; "none" === this.container.style.display && (b = !0, this.container.style.display = "block"); try {
                                  this.contentDiv.style.background = this.backgroundColor ? this.backgroundColor : s ? "rgba(255,255,255,.9)" : "rgb(255,255,255)", this.borderColor = "waterfall" === g[0].dataSeries.type ? this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor =
                                    this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : g[0].dataPoint.color ? g[0].dataPoint.color : 0 < g[0].dataPoint.y ? g[0].dataSeries.risingColor : g[0].dataSeries.fallingColor : "error" === g[0].dataSeries.type ? this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : g[0].dataSeries.color ? g[0].dataSeries.color : g[0].dataSeries._colorSet[e.index % g[0].dataSeries._colorSet.length] :
                                      this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : g[0].dataPoint.color ? g[0].dataPoint.color : g[0].dataSeries.color ? g[0].dataSeries.color : g[0].dataSeries._colorSet[g[0].index % g[0].dataSeries._colorSet.length], this.contentDiv.style.borderWidth = this.borderThickness || 0 === this.borderThickness ? this.borderThickness + "px" : "2px", this.contentDiv.style.borderRadius = this.cornerRadius || 0 === this.cornerRadius ?
                                        this.cornerRadius + "px" : "5px", this.container.style.borderRadius = this.contentDiv.style.borderRadius, this.contentDiv.style.fontSize = this.fontSize || 0 === this.fontSize ? this.fontSize + "px" : "14px", this.contentDiv.style.color = this.fontColor ? this.fontColor : "#000000", this.contentDiv.style.fontFamily = this.fontFamily ? this.fontFamily : "Calibri, Arial, Georgia, serif;", this.contentDiv.style.fontWeight = this.fontWeight ? this.fontWeight : "normal", this.contentDiv.style.fontStyle = this.fontStyle ? this.fontStyle : s ? "italic" :
                                          "normal"
                                } catch (p) { } "pie" === g[0].dataSeries.type || "doughnut" === g[0].dataSeries.type || "funnel" === g[0].dataSeries.type || "pyramid" === g[0].dataSeries.type || "bar" === g[0].dataSeries.type || "rangeBar" === g[0].dataSeries.type || "stackedBar" === g[0].dataSeries.type || "stackedBar100" === g[0].dataSeries.type ? a = a - 10 - this.container.clientWidth : (a = g[0].dataSeries.axisX.convertValueToPixel(g[0].dataPoint.x) - this.container.clientWidth << 0, a -= 10); 0 > a && (a += this.container.clientWidth + 20); a + this.container.clientWidth > Math.max(this.chart.container.clientWidth,
                                  this.chart.width) && (a = Math.max(0, Math.max(this.chart.container.clientWidth, this.chart.width) - this.container.clientWidth)); d = 1 !== g.length || this.shared || "line" !== g[0].dataSeries.type && "stepLine" !== g[0].dataSeries.type && "spline" !== g[0].dataSeries.type && "area" !== g[0].dataSeries.type && "stepArea" !== g[0].dataSeries.type && "splineArea" !== g[0].dataSeries.type ? "bar" === g[0].dataSeries.type || "rangeBar" === g[0].dataSeries.type || "stackedBar" === g[0].dataSeries.type || "stackedBar100" === g[0].dataSeries.type ? g[0].dataSeries.axisX.convertValueToPixel(g[0].dataPoint.x) :
                                    d : g[0].dataSeries.axisY.convertValueToPixel(g[0].dataPoint.y); d = -d + 10; 0 < d + this.container.clientHeight + 5 && (d -= d + this.container.clientHeight + 5 - 0); this.fixMozTransitionDelay(a, d); !this.animationEnabled || b ? this.disableAnimation() : (this.enableAnimation(), this.container.style.MozTransition = this.mozContainerTransition); this.positionLeft = a; this.positionBottom = d; this.container.style.left = a + "px"; this.container.style.bottom = d + "px"
                              } else this.hide(!1), this.dispatchEvent("hidden", { chart: this.chart, toolTip: this },
                                this)
                            } d = []; for (c = 0; c < g.length; c++)d.push({ xValue: g[c].dataPoint.x, dataPoint: g[c].dataPoint, dataSeries: g[c].dataSeries, dataPointIndex: g[c].index, dataSeriesIndex: g[c].dataSeries._index }); r = { chart: this.chart, toolTip: this.options, content: r, entries: d }; this._entries = g; this.dispatchEvent("updated", r, this)
                          } else this.hide()
                        }
                      }; la.prototype.highlightObjects = function (a) {
                        var d = this.chart.overlaidCanvasCtx; if (h(this.chart.clearedOverlayedCanvas) || "toolTip" === this.chart.clearedOverlayedCanvas) this.chart.resetOverlayedCanvas(),
                          d.clearRect(0, 0, this.chart.width, this.chart.height), this.chart.clearedOverlayedCanvas = "toolTip"; d.save(); var b = this.chart.plotArea, c = 0; d.beginPath(); d.rect(b.x1, b.y1, b.x2 - b.x1, b.y2 - b.y1); d.clip(); for (b = 0; b < a.length; b++) {
                            var e = a[b]; if ((e = this.chart._eventManager.objectMap[e.dataSeries.dataPointIds[e.index]]) && e.objectType && "dataPoint" === e.objectType) {
                              var c = this.chart.data[e.dataSeriesIndex], g = c.dataPoints[e.dataPointIndex], m = e.dataPointIndex; !1 === g.highlightEnabled || !0 !== c.highlightEnabled && !0 !== g.highlightEnabled ||
                                ("line" === c.type || "stepLine" === c.type || "spline" === c.type || "scatter" === c.type || "area" === c.type || "stepArea" === c.type || "splineArea" === c.type || "stackedArea" === c.type || "stackedArea100" === c.type || "rangeArea" === c.type || "rangeSplineArea" === c.type ? (g = c.getMarkerProperties(m, e.x1, e.y1, this.chart.overlaidCanvasCtx), g.size = Math.max(1.5 * g.size << 0, 10), g.borderColor = g.borderColor || "#FFFFFF", g.borderThickness = g.borderThickness || Math.ceil(0.1 * g.size), z.drawMarkers([g]), "undefined" !== typeof e.y2 && (g = c.getMarkerProperties(m,
                                  e.x1, e.y2, this.chart.overlaidCanvasCtx), g.size = Math.max(1.5 * g.size << 0, 10), g.borderColor = g.borderColor || "#FFFFFF", g.borderThickness = g.borderThickness || Math.ceil(0.1 * g.size), z.drawMarkers([g]))) : "bubble" === c.type ? (g = c.getMarkerProperties(m, e.x1, e.y1, this.chart.overlaidCanvasCtx), g.size = e.size, g.color = "white", g.borderColor = "white", d.globalAlpha = 0.3, z.drawMarkers([g]), d.globalAlpha = 1) : "column" === c.type || "stackedColumn" === c.type || "stackedColumn100" === c.type || "bar" === c.type || "rangeBar" === c.type || "stackedBar" ===
                                    c.type || "stackedBar100" === c.type || "rangeColumn" === c.type || "waterfall" === c.type ? X(d, e.x1, e.y1, e.x2, e.y2, "white", 0, null, !1, !1, !1, !1, 0.3) : "pie" === c.type || "doughnut" === c.type ? f(d, e.center, e.radius, "white", c.type, e.startAngle, e.endAngle, 0.3, e.percentInnerRadius) : "funnel" === c.type || "pyramid" === c.type ? x(d, e.funnelSection, 0.3, "white") : "candlestick" === c.type ? (d.globalAlpha = 1, d.strokeStyle = e.color, d.lineWidth = 2 * e.borderThickness, c = 0 === d.lineWidth % 2 ? 0 : 0.5, d.beginPath(), d.moveTo(e.x3 - c, Math.min(e.y2, e.y3)), d.lineTo(e.x3 -
                                      c, Math.min(e.y1, e.y4)), d.stroke(), d.beginPath(), d.moveTo(e.x3 - c, Math.max(e.y1, e.y4)), d.lineTo(e.x3 - c, Math.max(e.y2, e.y3)), d.stroke(), X(d, e.x1, Math.min(e.y1, e.y4), e.x2, Math.max(e.y1, e.y4), "transparent", 2 * e.borderThickness, e.color, !1, !1, !1, !1), d.globalAlpha = 1) : "ohlc" === c.type ? (d.globalAlpha = 1, d.strokeStyle = e.color, d.lineWidth = 2 * e.borderThickness, c = 0 === d.lineWidth % 2 ? 0 : 0.5, d.beginPath(), d.moveTo(e.x3 - c, e.y2), d.lineTo(e.x3 - c, e.y3), d.stroke(), d.beginPath(), d.moveTo(e.x3, e.y1), d.lineTo(e.x1, e.y1), d.stroke(),
                                        d.beginPath(), d.moveTo(e.x3, e.y4), d.lineTo(e.x2, e.y4), d.stroke(), d.globalAlpha = 1) : "boxAndWhisker" === c.type ? (d.save(), d.globalAlpha = 1, d.strokeStyle = e.stemColor, d.lineWidth = 2 * e.stemThickness, 0 < e.stemThickness && (d.beginPath(), d.moveTo(e.x3, e.y2 + e.borderThickness / 2), d.lineTo(e.x3, e.y1 + e.whiskerThickness / 2), d.stroke(), d.beginPath(), d.moveTo(e.x3, e.y4 - e.whiskerThickness / 2), d.lineTo(e.x3, e.y3 - e.borderThickness / 2), d.stroke()), d.beginPath(), X(d, e.x1 - e.borderThickness / 2, Math.max(e.y2 + e.borderThickness / 2, e.y3 +
                                          e.borderThickness / 2), e.x2 + e.borderThickness / 2, Math.min(e.y2 - e.borderThickness / 2, e.y3 - e.borderThickness / 2), "transparent", e.borderThickness, e.color, !1, !1, !1, !1), d.globalAlpha = 1, d.strokeStyle = e.whiskerColor, d.lineWidth = 2 * e.whiskerThickness, 0 < e.whiskerThickness && (d.beginPath(), d.moveTo(Math.floor(e.x3 - e.whiskerLength / 2), e.y4), d.lineTo(Math.ceil(e.x3 + e.whiskerLength / 2), e.y4), d.stroke(), d.beginPath(), d.moveTo(Math.floor(e.x3 - e.whiskerLength / 2), e.y1), d.lineTo(Math.ceil(e.x3 + e.whiskerLength / 2), e.y1), d.stroke()),
                                          d.globalAlpha = 1, d.strokeStyle = e.lineColor, d.lineWidth = 2 * e.lineThickness, 0 < e.lineThickness && (d.beginPath(), d.moveTo(e.x1, e.y5), d.lineTo(e.x2, e.y5), d.stroke()), d.restore(), d.globalAlpha = 1) : "error" === c.type && D(d, e.x1, e.y1, e.x2, e.y2, "white", e.whiskerProperties, e.stemProperties, e.isXYSwapped, 0.3))
                            }
                          } d.restore(); d.globalAlpha = 1; d.beginPath()
                      }; la.prototype.getToolTipInnerHTML = function (a) {
                        a = a.entries; for (var d = null, b = null, c = null, e = 0, g = "", f = !0, h = 0; h < a.length; h++)if (a[h].dataSeries.toolTipContent || a[h].dataPoint.toolTipContent) {
                          f =
                            !1; break
                        } if (f && (this.content && "function" === typeof this.content || this.contentFormatter)) a = { chart: this.chart, toolTip: this.options, entries: a }, d = this.contentFormatter ? this.contentFormatter(a) : this.content(a); else if (this.shared && "none" !== this.chart.plotInfo.axisPlacement) {
                          for (var m = null, l = "", h = 0; h < a.length; h++)b = a[h].dataSeries, c = a[h].dataPoint, e = a[h].index, g = "", 0 === h && (f && !this.content) && (this.chart.axisX && 0 < this.chart.axisX.length ? l += "undefined" !== typeof this.chart.axisX[0].labels[c.x] ? this.chart.axisX[0].labels[c.x] :
                            "{x}" : this.chart.axisX2 && 0 < this.chart.axisX2.length && (l += "undefined" !== typeof this.chart.axisX2[0].labels[c.x] ? this.chart.axisX2[0].labels[c.x] : "{x}"), l += "</br>", l = this.chart.replaceKeywordsWithValue(l, c, b, e)), null === c.toolTipContent || "undefined" === typeof c.toolTipContent && null === b.options.toolTipContent || ("line" === b.type || "stepLine" === b.type || "spline" === b.type || "area" === b.type || "stepArea" === b.type || "splineArea" === b.type || "column" === b.type || "bar" === b.type || "scatter" === b.type || "stackedColumn" === b.type ||
                              "stackedColumn100" === b.type || "stackedBar" === b.type || "stackedBar100" === b.type || "stackedArea" === b.type || "stackedArea100" === b.type || "waterfall" === b.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (g += m != b.axisXIndex ? b.axisX.title ? b.axisX.title + "<br/>" : "X:{axisXIndex}<br/>" : ""), g += c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && "function" !== typeof this.content ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>{name}:</span>&nbsp;&nbsp;{y}",
                                m = b.axisXIndex) : "bubble" === b.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (g += m != b.axisXIndex ? b.axisX.title ? b.axisX.title + "<br/>" : "X:{axisXIndex}<br/>" : ""), g += c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && "function" !== typeof this.content ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>{name}:</span>&nbsp;&nbsp;{y}, &nbsp;&nbsp;{z}") : "rangeColumn" === b.type || "rangeBar" === b.type || "rangeArea" === b.type || "rangeSplineArea" === b.type ||
                                  "error" === b.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (g += m != b.axisXIndex ? b.axisX.title ? b.axisX.title + "<br/>" : "X:{axisXIndex}<br/>" : ""), g += c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && "function" !== typeof this.content ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>{name}:</span>&nbsp;&nbsp;{y[0]},&nbsp;{y[1]}") : "candlestick" === b.type || "ohlc" === b.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (g += m != b.axisXIndex ? b.axisX.title ?
                                    b.axisX.title + "<br/>" : "X:{axisXIndex}<br/>" : ""), g += c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && "function" !== typeof this.content ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>{name}:</span><br/>Open: &nbsp;&nbsp;{y[0]}<br/>High: &nbsp;&nbsp;&nbsp;{y[1]}<br/>Low:&nbsp;&nbsp;&nbsp;{y[2]}<br/>Close: &nbsp;&nbsp;{y[3]}") : "boxAndWhisker" === b.type && (this.chart.axisX && 1 < this.chart.axisX.length && (g += m != b.axisXIndex ? b.axisX.title ? b.axisX.title +
                                      "<br/>" : "X:{axisXIndex}<br/>" : ""), g += c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && "function" !== typeof this.content ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>{name}:</span><br/>Minimum: &nbsp;&nbsp;{y[0]}<br/>Q1: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[1]}<br/>Q2: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[4]}<br/>Q3: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Maximum: &nbsp;{y[3]}"),
                              null === d && (d = ""), !0 === this.reversed ? (d = this.chart.replaceKeywordsWithValue(g, c, b, e) + d, h < a.length - 1 && (d = "</br>" + d)) : (d += this.chart.replaceKeywordsWithValue(g, c, b, e), h < a.length - 1 && (d += "</br>"))); null !== d && (d = l + d)
                        } else {
                          b = a[0].dataSeries; c = a[0].dataPoint; e = a[0].index; if (null === c.toolTipContent || "undefined" === typeof c.toolTipContent && null === b.options.toolTipContent) return null; "line" === b.type || "stepLine" === b.type || "spline" === b.type || "area" === b.type || "stepArea" === b.type || "splineArea" === b.type || "column" ===
                            b.type || "bar" === b.type || "scatter" === b.type || "stackedColumn" === b.type || "stackedColumn100" === b.type || "stackedBar" === b.type || "stackedBar100" === b.type || "stackedArea" === b.type || "stackedArea100" === b.type || "waterfall" === b.type ? g = c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && "function" !== typeof this.content ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>" + (c.label ? "{label}" : "{x}") + ":</span>&nbsp;&nbsp;{y}" : "bubble" === b.type ? g = c.toolTipContent ?
                              c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && "function" !== typeof this.content ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>" + (c.label ? "{label}" : "{x}") + ":</span>&nbsp;&nbsp;{y}, &nbsp;&nbsp;{z}" : "pie" === b.type || "doughnut" === b.type || "funnel" === b.type || "pyramid" === b.type ? g = c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && "function" !== typeof this.content ? this.content : "<span style='\"" + (this.options.fontColor ? "" :
                                "'color:{color};'") + "\"'>" + (c.name ? "{name}:</span>&nbsp;&nbsp;" : c.label ? "{label}:</span>&nbsp;&nbsp;" : "</span>") + "{y}" : "rangeColumn" === b.type || "rangeBar" === b.type || "rangeArea" === b.type || "rangeSplineArea" === b.type || "error" === b.type ? g = c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && "function" !== typeof this.content ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>" + (c.label ? "{label}" : "{x}") + " :</span>&nbsp;&nbsp;{y[0]}, &nbsp;{y[1]}" :
                                  "candlestick" === b.type || "ohlc" === b.type ? g = c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && "function" !== typeof this.content ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>" + (c.label ? "{label}" : "{x}") + "</span><br/>Open: &nbsp;&nbsp;{y[0]}<br/>High: &nbsp;&nbsp;&nbsp;{y[1]}<br/>Low: &nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Close: &nbsp;&nbsp;{y[3]}" : "boxAndWhisker" === b.type && (g = c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent :
                                    this.content && "function" !== typeof this.content ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>" + (c.label ? "{label}" : "{x}") + "</span><br/>Minimum: &nbsp;&nbsp;{y[0]}<br/>Q1: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[1]}<br/>Q2: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[4]}<br/>Q3: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Maximum: &nbsp;{y[3]}");
                          null === d && (d = ""); d += this.chart.replaceKeywordsWithValue(g, c, b, e)
                        } return d
                      }; la.prototype.enableAnimation = function () { if (!this.container.style.WebkitTransition) { var a = this.getContainerTransition(this.containerTransitionDuration); this.container.style.WebkitTransition = a; this.container.style.MsTransition = a; this.container.style.transition = a; this.container.style.MozTransition = this.mozContainerTransition } }; la.prototype.disableAnimation = function () {
                        this.container.style.WebkitTransition && (this.container.style.WebkitTransition =
                          "", this.container.style.MozTransition = "", this.container.style.MsTransition = "", this.container.style.transition = "")
                      }; la.prototype.hide = function (a) { this.container && (this.container.style.display = "none", this.currentSeriesIndex = -1, this._prevY = this._prevX = NaN, ("undefined" === typeof a || a) && this.chart.resetOverlayedCanvas()) }; la.prototype.show = function (a, d, b) { this._updateToolTip(a, d, "undefined" === typeof b ? !1 : b) }; la.prototype.showAtIndex = function (a, d) { }; la.prototype.showAtX = function (a, d) {
                        if (!this.enabled) return !1;
                        this.chart.clearedOverlayedCanvas = null; var b, c, e, g = []; e = !1; d = !h(d) && 0 <= d && d < this.chart.data.length ? d : 0; if (this.shared) for (var f = 0; f < this.chart.data.length; f++)b = this.chart.data[f], (c = b.getDataPointAtX(a, !1)) && (c.dataPoint && !h(c.dataPoint.y) && b.visible) && (c.dataSeries = b, g.push(c)); else b = this.chart.data[d], (c = b.getDataPointAtX(a, !1)) && (c.dataPoint && !h(c.dataPoint.y) && b.visible) && (c.dataSeries = b, g.push(c)); if (0 < g.length) {
                          for (f = 0; f < g.length; f++)if (c = g[f], c.dataPoint.x < c.dataSeries.axisX.viewportMinimum ||
                            c.dataPoint.x > c.dataSeries.axisX.viewportMaximum || c.dataPoint.y < c.dataSeries.axisY.viewportMinimum || c.dataPoint.y > c.dataSeries.axisY.viewportMaximum) e = !0; else { e = !1; break } if (e) return this.hide(), !1; this.highlightObjects(g); this._entries = g; c = ""; c = this.getToolTipInnerHTML({ entries: g }); if (null !== c) {
                              this.contentDiv.innerHTML = c; c = !1; "none" === this.container.style.display && (c = !0, this.container.style.display = "block"); try {
                                this.contentDiv.style.background = this.backgroundColor ? this.backgroundColor : s ? "rgba(255,255,255,.9)" :
                                  "rgb(255,255,255)", this.borderColor = "waterfall" === g[0].dataSeries.type ? this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : g[0].dataPoint.color ? g[0].dataPoint.color : 0 < g[0].dataPoint.y ? g[0].dataSeries.risingColor : g[0].dataSeries.fallingColor : "error" === g[0].dataSeries.type ? this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ?
                                    this.options.borderColor : g[0].dataSeries.color ? g[0].dataSeries.color : g[0].dataSeries._colorSet[b.index % g[0].dataSeries._colorSet.length] : this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : g[0].dataPoint.color ? g[0].dataPoint.color : g[0].dataSeries.color ? g[0].dataSeries.color : g[0].dataSeries._colorSet[g[0].index % g[0].dataSeries._colorSet.length], this.contentDiv.style.borderWidth = this.borderThickness ||
                                      0 === this.borderThickness ? this.borderThickness + "px" : "2px", this.contentDiv.style.borderRadius = this.cornerRadius || 0 === this.cornerRadius ? this.cornerRadius + "px" : "5px", this.container.style.borderRadius = this.contentDiv.style.borderRadius, this.contentDiv.style.fontSize = this.fontSize || 0 === this.fontSize ? this.fontSize + "px" : "14px", this.contentDiv.style.color = this.fontColor ? this.fontColor : "#000000", this.contentDiv.style.fontFamily = this.fontFamily ? this.fontFamily : "Calibri, Arial, Georgia, serif;", this.contentDiv.style.fontWeight =
                                  this.fontWeight ? this.fontWeight : "normal", this.contentDiv.style.fontStyle = this.fontStyle ? this.fontStyle : s ? "italic" : "normal"
                              } catch (m) { } "pie" === g[0].dataSeries.type || "doughnut" === g[0].dataSeries.type || "funnel" === g[0].dataSeries.type || "pyramid" === g[0].dataSeries.type ? b = mouseX - 10 - this.container.clientWidth : (b = "bar" === g[0].dataSeries.type || "rangeBar" === g[0].dataSeries.type || "stackedBar" === g[0].dataSeries.type || "stackedBar100" === g[0].dataSeries.type ? g[0].dataSeries.axisY.convertValueToPixel(g[0].dataPoint.y) -
                                this.container.clientWidth << 0 : g[0].dataSeries.axisX.convertValueToPixel(g[0].dataPoint.x) - this.container.clientWidth << 0, b -= 10); 0 > b && (b += this.container.clientWidth + 20); b + this.container.clientWidth > Math.max(this.chart.container.clientWidth, this.chart.width) && (b = Math.max(0, Math.max(this.chart.container.clientWidth, this.chart.width) - this.container.clientWidth)); g = 1 !== g.length || this.shared || "line" !== g[0].dataSeries.type && "stepLine" !== g[0].dataSeries.type && "spline" !== g[0].dataSeries.type && "area" !== g[0].dataSeries.type &&
                                  "stepArea" !== g[0].dataSeries.type && "splineArea" !== g[0].dataSeries.type ? "bar" === g[0].dataSeries.type || "rangeBar" === g[0].dataSeries.type || "stackedBar" === g[0].dataSeries.type || "stackedBar100" === g[0].dataSeries.type ? g[0].dataSeries.axisX.convertValueToPixel(g[0].dataPoint.x) : g[0].dataSeries.axisY.convertValueToPixel(g[0].dataPoint.y) : g[0].dataSeries.axisY.convertValueToPixel(g[0].dataPoint.y); g = -g + 10; 0 < g + this.container.clientHeight + 5 && (g -= g + this.container.clientHeight + 5 - 0); this.fixMozTransitionDelay(b,
                                    g); !this.animationEnabled || c ? this.disableAnimation() : (this.enableAnimation(), this.container.style.MozTransition = this.mozContainerTransition); this.container.style.left = b + "px"; this.container.style.bottom = g + "px"
                            } else return this.hide(!1), !1
                        } else return this.hide(), !1; return !0
                      }; la.prototype.fixMozTransitionDelay = function (a, d) {
                        if (20 < this.chart._eventManager.lastObjectId) this.mozContainerTransition = this.getContainerTransition(0); else {
                          var b = parseFloat(this.container.style.left), b = isNaN(b) ? 0 : b, c = parseFloat(this.container.style.bottom),
                            c = isNaN(c) ? 0 : c; 10 < Math.sqrt(Math.pow(b - a, 2) + Math.pow(c - d, 2)) ? this.mozContainerTransition = this.getContainerTransition(0.1) : this.mozContainerTransition = this.getContainerTransition(0)
                        }
                      }; la.prototype.getContainerTransition = function (a) { return "left " + a + "s ease-out 0s, bottom " + a + "s ease-out 0s" }; Y.prototype.reset = function () {
                        this.lastObjectId = 0; this.objectMap = []; this.rectangularRegionEventSubscriptions = []; this.previousDataPointEventObject = null; this.eventObjects = []; s && (this.ghostCtx.clearRect(0, 0, this.chart.width,
                          this.chart.height), this.ghostCtx.beginPath())
                      }; Y.prototype.getNewObjectTrackingId = function () { return ++this.lastObjectId }; Y.prototype.mouseEventHandler = function (a) {
                        if ("mousemove" === a.type || "click" === a.type) {
                          var d = [], b = Aa(a), c = null; if ((c = this.chart.getObjectAtXY(b.x, b.y, !1)) && "undefined" !== typeof this.objectMap[c]) if (c = this.objectMap[c], "dataPoint" === c.objectType) {
                            var e = this.chart.data[c.dataSeriesIndex], f = e.dataPoints[c.dataPointIndex], h = c.dataPointIndex; c.eventParameter = {
                              x: b.x, y: b.y, dataPoint: f, dataSeries: e.options,
                              dataPointIndex: h, dataSeriesIndex: e.index, chart: this.chart
                            }; c.eventContext = { context: f, userContext: f, mouseover: "mouseover", mousemove: "mousemove", mouseout: "mouseout", click: "click" }; d.push(c); c = this.objectMap[e.id]; c.eventParameter = { x: b.x, y: b.y, dataPoint: f, dataSeries: e.options, dataPointIndex: h, dataSeriesIndex: e.index, chart: this.chart }; c.eventContext = { context: e, userContext: e.options, mouseover: "mouseover", mousemove: "mousemove", mouseout: "mouseout", click: "click" }; d.push(this.objectMap[e.id])
                          } else "legendItem" ===
                            c.objectType && (e = this.chart.data[c.dataSeriesIndex], f = null !== c.dataPointIndex ? e.dataPoints[c.dataPointIndex] : null, c.eventParameter = { x: b.x, y: b.y, dataSeries: e.options, dataPoint: f, dataPointIndex: c.dataPointIndex, dataSeriesIndex: c.dataSeriesIndex, chart: this.chart }, c.eventContext = { context: this.chart.legend, userContext: this.chart.legend.options, mouseover: "itemmouseover", mousemove: "itemmousemove", mouseout: "itemmouseout", click: "itemclick" }, d.push(c)); e = []; for (b = 0; b < this.mouseoveredObjectMaps.length; b++) {
                              f =
                                !0; for (c = 0; c < d.length; c++)if (d[c].id === this.mouseoveredObjectMaps[b].id) { f = !1; break } f ? this.fireEvent(this.mouseoveredObjectMaps[b], "mouseout", a) : e.push(this.mouseoveredObjectMaps[b])
                            } this.mouseoveredObjectMaps = e; for (b = 0; b < d.length; b++) {
                              e = !1; for (c = 0; c < this.mouseoveredObjectMaps.length; c++)if (d[b].id === this.mouseoveredObjectMaps[c].id) { e = !0; break } e || (this.fireEvent(d[b], "mouseover", a), this.mouseoveredObjectMaps.push(d[b])); "click" === a.type ? this.fireEvent(d[b], "click", a) : "mousemove" === a.type && this.fireEvent(d[b],
                                "mousemove", a)
                            }
                        }
                      }; Y.prototype.fireEvent = function (a, d, b) {
                        if (a && d) {
                          var c = a.eventParameter, e = a.eventContext, f = a.eventContext.userContext; f && (e && f[e[d]]) && f[e[d]].call(f, c); "mouseout" !== d ? f.cursor && f.cursor !== b.target.style.cursor && (b.target.style.cursor = f.cursor) : (b.target.style.cursor = this.chart._defaultCursor, delete a.eventParameter, delete a.eventContext); "click" === d && ("dataPoint" === a.objectType && this.chart.pieDoughnutClickHandler) && this.chart.pieDoughnutClickHandler.call(this.chart.data[a.dataSeriesIndex],
                            c); "click" === d && ("dataPoint" === a.objectType && this.chart.funnelPyramidClickHandler) && this.chart.funnelPyramidClickHandler.call(this.chart.data[a.dataSeriesIndex], c)
                        }
                      }; ha.prototype.animate = function (a, d, b, c, e) {
                        var f = this; this.chart.isAnimating = !0; e = e || v.easing.linear; b && this.animations.push({ startTime: (new Date).getTime() + (a ? a : 0), duration: d, animationCallback: b, onComplete: c }); for (a = []; 0 < this.animations.length;)if (d = this.animations.shift(), b = (new Date).getTime(), c = 0, d.startTime <= b && (c = e(Math.min(b - d.startTime,
                          d.duration), 0, 1, d.duration), c = Math.min(c, 1), isNaN(c) || !isFinite(c)) && (c = 1), 1 > c && a.push(d), d.animationCallback(c), 1 <= c && d.onComplete) d.onComplete(); this.animations = a; 0 < this.animations.length ? this.animationRequestId = this.chart.requestAnimFrame.call(window, function () { f.animate.call(f) }) : this.chart.isAnimating = !1
                      }; ha.prototype.cancelAllAnimations = function () {
                        this.animations = []; this.animationRequestId && this.chart.cancelRequestAnimFrame.call(window, this.animationRequestId); this.animationRequestId = null; this.chart.isAnimating =
                          !1
                      }; var v = {
                        yScaleAnimation: function (a, d) { if (0 !== a) { var b = d.dest, c = d.source.canvas, e = d.animationBase; b.drawImage(c, 0, 0, c.width, c.height, 0, e - e * a, b.canvas.width / ga, a * b.canvas.height / ga) } }, xScaleAnimation: function (a, d) { if (0 !== a) { var b = d.dest, c = d.source.canvas, e = d.animationBase; b.drawImage(c, 0, 0, c.width, c.height, e - e * a, 0, a * b.canvas.width / ga, b.canvas.height / ga) } }, xClipAnimation: function (a, d) {
                          if (0 !== a) {
                            var b = d.dest, c = d.source.canvas; b.save(); 0 < a && b.drawImage(c, 0, 0, c.width * a, c.height, 0, 0, c.width * a / ga, c.height /
                              ga); b.restore()
                          }
                        }, fadeInAnimation: function (a, d) { if (0 !== a) { var b = d.dest, c = d.source.canvas; b.save(); b.globalAlpha = a; b.drawImage(c, 0, 0, c.width, c.height, 0, 0, b.canvas.width / ga, b.canvas.height / ga); b.restore() } }, easing: { linear: function (a, d, b, c) { return b * a / c + d }, easeOutQuad: function (a, d, b, c) { return -b * (a /= c) * (a - 2) + d }, easeOutQuart: function (a, d, b, c) { return -b * ((a = a / c - 1) * a * a * a - 1) + d }, easeInQuad: function (a, d, b, c) { return b * (a /= c) * a + d }, easeInQuart: function (a, d, b, c) { return b * (a /= c) * a * a * a + d } }
                      }, z = {
                        drawMarker: function (a,
                          d, b, c, e, f, h, m) {
                          if (b) {
                            var v = 1; b.fillStyle = f ? f : "#000000"; b.strokeStyle = h ? h : "#000000"; b.lineWidth = m ? m : 0; b.setLineDash && b.setLineDash(R("solid", m)); "circle" === c ? (b.moveTo(a, d), b.beginPath(), b.arc(a, d, e / 2, 0, 2 * Math.PI, !1), f && b.fill(), m && (h ? b.stroke() : (v = b.globalAlpha, b.globalAlpha = 0.15, b.strokeStyle = "black", b.stroke(), b.globalAlpha = v))) : "square" === c ? (b.beginPath(), b.rect(a - e / 2, d - e / 2, e, e), f && b.fill(), m && (h ? b.stroke() : (v = b.globalAlpha, b.globalAlpha = 0.15, b.strokeStyle = "black", b.stroke(), b.globalAlpha = v))) :
                              "triangle" === c ? (b.beginPath(), b.moveTo(a - e / 2, d + e / 2), b.lineTo(a + e / 2, d + e / 2), b.lineTo(a, d - e / 2), b.closePath(), f && b.fill(), m && (h ? b.stroke() : (v = b.globalAlpha, b.globalAlpha = 0.15, b.strokeStyle = "black", b.stroke(), b.globalAlpha = v)), b.beginPath()) : "cross" === c && (b.strokeStyle = f, b.lineWidth = e / 4, b.beginPath(), b.moveTo(a - e / 2, d - e / 2), b.lineTo(a + e / 2, d + e / 2), b.stroke(), b.moveTo(a + e / 2, d - e / 2), b.lineTo(a - e / 2, d + e / 2), b.stroke())
                          }
                        }, drawMarkers: function (a) {
                          for (var d = 0; d < a.length; d++) {
                            var b = a[d]; z.drawMarker(b.x, b.y, b.ctx, b.type,
                              b.size, b.color, b.borderColor, b.borderThickness)
                          }
                        }
                      }; return n
      }(); Ka.version = "v3.0.5 GA"; window.CanvasJS && (Ka && !window.CanvasJS.Chart) && (window.CanvasJS.Chart = Ka); Y.StockChart = {
        width: 500, height: 600, backgroundColor: "white", theme: "light1", animationEnabled: !1, animationDuration: 1200, culture: "en", creditHref: "", creditText: "CanvasJS", exportEnabled: !1, exportFileName: "StockChart", colorSet: "colorSet1", rangeChanging: null, rangeChanged: null, publicProperties: {
          title: "readWrite", subtitles: "readWrite", navigator: "readWrite",
          rangeSelector: "readWrite", charts: "readWrite", options: "readWrite", bounds: "readOnly", container: "readOnly"
        }
      }; Y.Navigator = {
        enabled: !0, width: 500, height: 70, verticalAlign: "bottom", horizontalAlign: "center", dynamicUpdate: !0, backgroundColor: "#fff", animationEnabled: !1, animationDuration: 1200, theme: "light1", publicProperties: {
          slider: "readWrite", backgroundColor: "readWrite", animationEnabled: "readWrite", animationDuration: "readWrite", theme: "readWrite", axisX: "readWrite", axisY: "readWrite", axisX2: "readWrite", axisY2: "readWrite",
          data: "readWrite", options: "readWrite", bounds: "readOnly"
        }
      }; Y.RangeSelector = { enabled: !0, width: 500, height: 35, label: "Range", verticalAlign: "top", horizontalAlign: "center", selectedRangeButtonIndex: null, publicProperties: { options: "readWrite", buttons: "readWrite", inputFields: "readWrite", buttonStyle: "readWrite", bounds: "readOnly" } }; Y.RangeButton = {
        range: null, rangeType: null, label: null, style: "position: inline; margin: 5px 0;text-align:center;cursor: pointer;", backgroundColorDisabled: "#ddd", publicProperties: {
          options: "readWrite",
          bounds: "readOnly"
        }
      }; Y.ButtonStyle = { backgroundColor: "#fff", backgroundColorOnHover: "#2196f3", backgroundColorOnSelect: "#2196f3", borderColor: "#2196f3", borderThickness: 2, labelFontColor: "#000", labelFontColorOnHover: "#fff", labelFontSize: 14, labelFontStyle: "normal", labelFontFamily: s ? "Trebuchet MS, Helvetica, sans-serif" : "Arial", labelFontWeight: "normal", width: null, maxWidth: null, padding: { left: 5, right: 5, top: 2, bottom: 2 }, spacing: 5, cursor: "pointer", publicProperties: { options: "readWrite" } }; Y.InputFields = {
        enabled: !0,
        startValue: null, endValue: null, valueType: "dateTime", valueFormatString: "MMM DD YYYY", publicProperties: { style: "readWrite", options: "readWrite" }
      }; Y.Style = { backgroundColor: "#fff", borderColor: "#2196f3", borderColorOnFocus: "#008eff", borderThickness: 2, fontColor: "#000", fontSize: 12, fontStyle: "normal", fontFamily: s ? "Trebuchet MS, Helvetica, sans-serif" : "Arial", fontWeight: "normal", width: null, maxWidth: null, padding: { left: 5, right: 5, top: 2, bottom: 2 }, spacing: 5, cursor: "text", publicProperties: { options: "readWrite" } }; Y.Slider =
        { maskColor: "#d9e8f9", maskInverted: !1, maskOpacity: 0.7, handleColor: "#ddd", handleBorderColor: "#aaa", handleBorderThickness: 1, handleWidth: 8, handleHeight: 18, minimum: null, maximum: null, outlineThickness: 1, outlineColor: "#666", outlineInverted: !1, publicProperties: { options: "readWrite" } }; Y.CultureInfo.rangeSelector = { fromText: "From", toText: "To", rangeText: "Range" }; G = "#FFFFFF"; W = "#333333"; N = "#000000"; Ga = {
          colorSet: "colorSet1", backgroundColor: G, title: Ga.title, subtitles: Ga.subtitles, charts: [Ga], rangeSelector: {
            buttonStyle: {
              backgroundColor: "#FEFEFE",
              backgroundColorOnHover: "#41a5f5", backgroundColorOnSelect: "#2196f3", borderColor: "#2196f3", borderThickness: 1, labelFontColor: N, labelFontColorOnHover: "#ffffff", labelFontSize: 14, labelFontStyle: "normal", labelFontFamily: w, labelFontWeight: "normal", spacing: 0
            }, inputFields: { style: { backgroundColor: "#ffffff", borderColor: "#2196f3", borderColorOnFocus: "#2196f3", borderThickness: 1, fontColor: N, fontSize: 14, fontStyle: "normal", fontFamily: w, fontWeight: "normal" } }
          }, navigator: {
            backgroundColor: G, slider: {
              maskColor: "#d9e8f9",
              maskOpacity: 0.6, handleColor: "#efefef", handleBorderColor: "#666666", handleBorderThickness: 1, outlineColor: "#666666", outlineThickness: 1
            }
          }, toolbar: Ga.toolbar
        }; G = "#FFFFFF"; W = "#3A3A3A"; N = "#666666"; Ja = {
          colorSet: "colorSet2", backgroundColor: G, title: Ja.title, subtitles: Ja.subtitles, charts: [Ja], rangeSelector: {
            buttonStyle: {
              backgroundColor: "#FEFEFE", backgroundColorOnHover: "#41a5f5", backgroundColorOnSelect: "#2196f3", borderColor: "#2196f3", borderThickness: 1, labelFontColor: N, labelFontColorOnHover: "#ffffff", labelFontSize: 14,
              labelFontStyle: "normal", labelFontFamily: w, labelFontWeight: "normal", spacing: 0
            }, inputFields: { style: { backgroundColor: "#ffffff", borderColor: "#2196f3", borderColorOnFocus: "#2196f3", borderThickness: 1, fontColor: N, fontSize: 14, fontStyle: "normal", fontFamily: w, fontWeight: "normal" } }
          }, navigator: { backgroundColor: G, slider: { maskColor: "#D9E8F9", maskOpacity: 0.6, handleColor: "#EFEFEF", handleBorderColor: "#BBBBBB", handleBorderThickness: 1, outlineColor: "#BBBBBB", outlineThickness: 1 } }, toolbar: Ja.toolbar
        }; G = "#2A2A2A"; N = W = "#F5F5F5";
  za = {
    colorSet: "colorSet1", backgroundColor: G, title: za.title, subtitles: za.subtitles, charts: [za], rangeSelector: {
      buttonStyle: { backgroundColor: "#666666", backgroundColorOnHover: "#FF7372", backgroundColorOnSelect: "#FF7372", borderColor: "#FF7372", borderThickness: 1, labelFontColor: N, labelFontColorOnHover: "#F5F5F5", labelFontSize: 14, labelFontStyle: "normal", labelFontFamily: w, labelFontWeight: "normal", spacing: 0 }, inputFields: {
        style: {
          backgroundColor: "#666666", borderColor: "#FF7372", borderColorOnFocus: "#FF7372", borderThickness: 1,
          fontColor: N, fontSize: 14, fontStyle: "normal", fontFamily: w, fontWeight: "normal"
        }
      }
    }, navigator: { backgroundColor: G, slider: { maskColor: "#d9e8f9", maskOpacity: 0.6, handleColor: "#efefef", handleBorderColor: "#666666", handleBorderThickness: 1, outlineColor: "#FFFFFF", outlineThickness: 1 } }, toolbar: za.toolbar
  }; G = "#32373A"; N = W = "#FAFAFA"; var bb = {
    light1: Ga, light2: Ja, dark1: za, dark2: {
      colorSet: "colorSet2", backgroundColor: G, title: T.title, subtitles: T.subtitles, charts: [T], rangeSelector: {
        buttonStyle: {
          backgroundColor: "#666666", backgroundColorOnHover: "#FF7372",
          backgroundColorOnSelect: "#FF7372", borderColor: "#FF7372", borderThickness: 1, labelFontColor: N, labelFontColorOnHover: "#F5F5F5", labelFontSize: 14, labelFontStyle: "normal", labelFontFamily: w, labelFontWeight: "normal", spacing: 0
        }, inputFields: { style: { backgroundColor: "#666666", borderColor: "#FF7372", borderColorOnFocus: "#FF7372", borderThickness: 1, fontColor: N, fontSize: 14, fontStyle: "normal", fontFamily: w, fontWeight: "normal" } }
      }, navigator: {
        backgroundColor: G, slider: {
          maskColor: "#d9e8f9", maskOpacity: 0.6, handleColor: "#efefef",
          handleBorderColor: "#666666", handleBorderThickness: 1, outlineColor: "#FFFFFF", outlineThickness: 1
        }
      }, toolbar: T.toolbar
    }
  }; W = Ra.StockChart = function () {
    function m(f) { var h; h = document.createElement("div"); h.setAttribute("class", f); h.style.position = "absolute"; h.style.textAlign = "left"; h.style.cursor = "auto"; return h } function n(f, m, v) { f = document.createElement(f); f.setAttribute("class", m); h(v) || f.setAttribute("type", v); return f } function D(f, m) {
      m = m || {}; this.theme = h(m.theme) || h(ab[m.theme]) ? "light1" : m.theme; this.predefinedThemes =
        bb; D.base.constructor.call(this, "StockChart", null, m, null, null); this.optionsName = "stockChart"; var v = this; this.sessionVariables = {}; this._axisXMax = this._axisXMin = null; this._containerId = f; this._objectsInitialized = !1; this.ctx = null; this.plotArea = { canvas: null, ctx: null, x1: 0, y1: 0, x2: 0, y2: 0, width: 0, height: 0 }; this._dataInRenderedOrder = []; this.allDOMEventHandlers = []; if (this.container = "string" === typeof this._containerId ? document.getElementById(this._containerId) : this._containerId) {
          this.container.innerHTML = "";
          var n = 0, a = 0; this._defaultCursor = "default"; n = this.options.width ? this.width : 0 < this.container.clientWidth ? this.container.clientWidth : this.width; a = this.options.height ? this.height : 0 < this.container.clientHeight ? this.container.clientHeight : this.height; this.width = n; this.height = a; this.x1 = this.y1 = 0; this.x2 = this.width; this.y2 = this.height; this._selectedColorSet = "undefined" !== typeof wa[this.colorSet] ? wa[this.colorSet] : wa.colorSet1; this._canvasJSContainer = document.createElement("div"); this._canvasJSContainer.setAttribute("class",
            "canvasjs-stock-container"); this._canvasJSContainer.style.position = "relative"; this._canvasJSContainer.style.userSelect = this._canvasJSContainer.style.WebkitUserSelect = this._canvasJSContainer.style.MozUserSelect = this._canvasJSContainer.style.msUserSelect = "none"; this._canvasJSContainer.style.textAlign = "left"; this._canvasJSContainer.style.cursor = "auto"; this._canvasJSContainer.style.direction = "ltr"; this._canvasJSContainer.style.fontFamily = w; s || (this._canvasJSContainer.style.height = "0px"); this.container.appendChild(this._canvasJSContainer);
          this.canvas = pa(n, a); this.canvas.style.position = "absolute"; this.canvas.getContext && (this._canvasJSContainer.appendChild(this.canvas), this.ctx = this.canvas.getContext("2d"), this.ctx.textBaseline = "top", Ha(this.ctx), this.overlaidCanvas = pa(n, a), this.overlaidCanvas.style.position = "absolute", this.overlaidCanvas.style.webkitTapHighlightColor = "transparent", this.overlaidCanvas.getContext && (this._canvasJSContainer.appendChild(this.overlaidCanvas), this.overlaidCanvasCtx = this.overlaidCanvas.getContext("2d"), this.overlaidCanvasCtx.textBaseline =
            "top", Ha(this.overlaidCanvasCtx)), s ? this.plotArea.ctx = this.ctx : (this.plotArea.canvas = pa(n, a), this.plotArea.canvas.style.position = "absolute", this.plotArea.canvas.setAttribute("class", "plotAreaCanvas"), this._canvasJSContainer.appendChild(this.plotArea.canvas), this.plotArea.ctx = this.plotArea.canvas.getContext("2d")), this._toolBar = document.createElement("div"), this._toolBar.setAttribute("class", "canvasjs-chart-toolbar"), this._toolBar.style.cssText = "position: absolute; right: 1px; top: 1px; z-index: 999;",
            this._canvasJSContainer.appendChild(this._toolBar), this.bounds = { x1: 0, y1: 0, x2: this.width, y2: this.height }, this.charts = [], Ea(this.charts), this._eventManager = new H(this), y(this.overlaidCanvas, "click", function (a) { v._mouseEventHandler(a) }, this.allDOMEventHandlers), y(this.overlaidCanvas, "mousemove", function (a) { v._mouseEventHandler(a) }, this.allDOMEventHandlers), y(this.overlaidCanvas, "mouseup", function (a) { v._mouseEventHandler(a) }, this.allDOMEventHandlers), y(this.overlaidCanvas, "mousedown", function (a) {
              v._mouseEventHandler(a);
              ya(v._dropdownMenu)
            }, this.allDOMEventHandlers), y(this.overlaidCanvas, "mouseout", function (a) { v._mouseEventHandler(a) }, this.allDOMEventHandlers), y(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerDown" : "touchstart", function (a) { v._touchEventHandler(a) }, this.allDOMEventHandlers), y(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerMove" : "touchmove", function (a) { v._touchEventHandler(a) }, this.allDOMEventHandlers), y(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerUp" :
              "touchend", function (a) { v._touchEventHandler(a) }, this.allDOMEventHandlers), y(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerCancel" : "touchcancel", function (a) { v._touchEventHandler(a) }, this.allDOMEventHandlers), this.windowResizeHandler = y(window, "resize", function () { v._updateSize() && v.render() }, this.allDOMEventHandlers))
        } else window.console && window.console.log('CanvasJS Error: StockChart Container with id "' + this._containerId + '" was not found')
    } function G(f, h) {
      G.base.constructor.call(this,
        f, h); this.options = h; this.dockInsidePlotArea = !1
    } function N(f, h, m) { N.base.constructor.call(this, f, h, m); this.options = h; this.dockInsidePlotArea = !1 } function H(f) { this.stockChart = f; this.lastObjectId = 0; this.objectMap = []; this.rectangularRegionEventSubscriptions = []; this.ghostCanvas = pa(this.stockChart.width, this.stockChart.height); this.ghostCtx = this.ghostCanvas.getContext("2d"); this.mouseoveredObjectMaps = [] } function B(f, h) {
      h = h || {}; this.optionsName = "navigator"; B.base.constructor.call(this, "Navigator", "navigator",
        h, null, f); this.parent = this.stockChart = f
    } function Q(f, x) { this.panel = m("canvasjs-slider-panel"); this.parent = this.navigator = f; this.stockChart = f.stockChart; this.navigator.panel.appendChild(this.panel); Q.base.constructor.call(this, "Slider", "slider", x, null, f); this.options = h(x.navigator) || h(x.navigator.slider) ? {} : x.navigator.slider; this.optionsName = "slider"; this.panMode = !1 } function R(f, m) {
      R.base.constructor.call(this, "RangeSelector", "rangeSelector", m, null, f); this.parent = this.stockChart = f; this.options = h(m) ||
        h(m.rangeSelector) ? {} : m.rangeSelector; this.optionsName = "rangeSelector"; this.ctx = f.ctx; this._label = {}; this.buttons = []
    } function M(f, m, v) { M.base.constructor.call(this, "RangeButton", "rangeButton", v, m, f.rangeSelector); this.stockChart = f; this.parent = this.rangeSelector = f.rangeSelector; this.options = h(v) ? {} : v; this.optionsName = "rangeButton"; this.enabled = !1; this.state = "off" } function T(f, m) {
      T.base.constructor.call(this, "InputFields", "inputFields", m, null, f.rangeSelector); this.stockChart = f; this.options = h(m) || h(m.inputFields) ?
        {} : m.inputFields; this.parent = this.rangeSelector = f.rangeSelector; this.elements = []; this._textBlocks = []; this.optionsName = "inputFields"; this.elements.push(n("input", "canvasjs-input-field", "text")); this.elements.push(n("input", "canvasjs-input-field", "text")); for (var v = 0; v < this.elements.length; v++)this.stockChart._canvasJSContainer.appendChild(this.elements[v]); var z = this, a = null, d = null; y(this.elements[0], "focus", function () {
          z.elements[0].focused = !0; z._textBlocks[0].borderColor = z.style.borderColorOnFocus;
          z._textBlocks[0].render(!0)
        }, this.rangeSelector.stockChart.allDOMEventHandlers); y(this.elements[0], "focusout", function () {
          z.elements[0].focused = !1; var a; z.stockChart.charts && z.stockChart.charts.length && (a = z.stockChart.charts[0].axisX && z.stockChart.charts[0].axisX.length ? z.stockChart.charts[0].axisX[0] : z.stockChart.charts[0].axisX2[0]); this.value = "dateTime" === z.valueType ? ka(a ? a.viewportMinimum : null, "YYYY-MM-DD", z.stockChart._cultureInfo) : Z(a ? a.viewportMinimum : null, z.valueFormatString, z.stockChart._cultureInfo);
          this.style.display = "none"; z._textBlocks[0].borderColor = z.style.borderColor; z._textBlocks[0].render(!0)
        }, this.rangeSelector.stockChart.allDOMEventHandlers); y(this.elements[1], "focus", function () { z.elements[1].focused = !0; z._textBlocks[1].borderColor = z.style.borderColorOnFocus; z._textBlocks[1].render(!0) }, this.rangeSelector.stockChart.allDOMEventHandlers); y(this.elements[1], "focusout", function () {
          z.elements[1].focused = !1; var a; z.stockChart.charts && z.stockChart.charts.length && (a = z.stockChart.charts[0].axisX &&
            z.stockChart.charts[0].axisX.length ? z.stockChart.charts[0].axisX[0] : z.stockChart.charts[0].axisX2[0]); this.value = "dateTime" === z.valueType ? ka(a ? a.viewportMaximum : null, "YYYY-MM-DD", z.stockChart._cultureInfo) : Z(a ? a.viewportMaximum : null, z.valueFormatString, z.stockChart._cultureInfo); this.style.display = "none"; z._textBlocks[1].borderColor = z.style.borderColor; z._textBlocks[1].render(!0)
        }, this.rangeSelector.stockChart.allDOMEventHandlers); y(this.elements[0], "change", function (b) {
          var c; if (z.stockChart.charts &&
            z.stockChart.charts.length) { var e = z.stockChart.navigator && z.stockChart.navigator.chart && z.stockChart.navigator.chart.axisX ? z.stockChart.navigator.chart.axisX[0] : z.stockChart.navigator.chart.axisX2[0]; c = z.stockChart.charts[0].axisX && z.stockChart.charts[0].axisX.length ? z.stockChart.charts[0].axisX[0] : z.stockChart.charts[0].axisX2[0] } b = "dateTime" === z.valueType ? isNaN((new Date(this.value.replace(/-/g, "/"))).getTime()) ? null : (new Date(this.value.replace(/-/g, "/"))).getTime() : this.value; a = !h(b) && b < (h(e) ?
              null : e.maximum) ? Math.max(h(e) ? null : e.minimum, b) : h(e) ? null : e.minimum; d = h(c) ? null : c.viewportMaximum; z.stockChart._rangeEventParameter = { stockChart: z.stockChart, source: "inputFields", index: null, minimum: a, maximum: d }; z.stockChart._rangeEventParameter.type = "rangeChanging"; z.stockChart.dispatchEvent("rangeChanging", z.stockChart._rangeEventParameter, z.stockChart); z.stockChart.sessionVariables._axisXMin = a; z.stockChart.sessionVariables._axisXMax = d; z.stockChart._syncCharts(a, d); z.stockChart._rangeEventParameter.type =
                "rangeChanged"; z.stockChart.dispatchEvent("rangeChanged", z.stockChart._rangeEventParameter, z.stockChart); z.stockChart.rangeSelector && z.stockChart.rangeSelector.resetRangeButtons()
        }, this.rangeSelector.stockChart.allDOMEventHandlers); y(this.elements[1], "change", function (b) {
          var c; if (z.stockChart.charts && z.stockChart.charts.length) {
            var e = z.stockChart.navigator && z.stockChart.navigator.chart && z.stockChart.navigator.chart.axisX ? z.stockChart.navigator.chart.axisX[0] : z.stockChart.navigator.chart.axisX2[0];
            c = z.stockChart.charts[0].axisX && z.stockChart.charts[0].axisX.length ? z.stockChart.charts[0].axisX[0] : z.stockChart.charts[0].axisX2[0]
          } b = "dateTime" === z.valueType ? isNaN((new Date(this.value.replace(/-/g, "/"))).getTime()) ? null : (new Date(this.value.replace(/-/g, "/"))).getTime() : this.value; a = c ? c.viewportMinimum : null; d = !h(b) && b > (e ? e.minimum : null) ? Math.min(e ? e.maximum : null, b) : e ? e.maximum : null; z.stockChart._rangeEventParameter = { stockChart: z.stockChart, source: "inputFields", index: null, minimum: a, maximum: d }; z.stockChart._rangeEventParameter.type =
            "rangeChanging"; z.stockChart.dispatchEvent("rangeChanging", z.stockChart._rangeEventParameter, z.stockChart); z.stockChart.sessionVariables._axisXMin = a; z.stockChart.sessionVariables._axisXMax = d; z.stockChart._syncCharts(a, d); z.stockChart._rangeEventParameter.type = "rangeChanged"; z.stockChart.dispatchEvent("rangeChanged", z.stockChart._rangeEventParameter, z.stockChart); z.stockChart.rangeSelector && z.stockChart.rangeSelector.resetRangeButtons()
        }, this.rangeSelector.stockChart.allDOMEventHandlers); y(this.elements[0],
          "keydown", function (a) { if (13 === a.keyCode) { if ("createEvent" in document) { var c = document.createEvent("HTMLEvents"); c.initEvent("change", !1, !0); this.dispatchEvent(c) } else this.fireEvent("onchange"); this.blur(); a.preventDefault && a.preventDefault() } }, this.rangeSelector.stockChart.allDOMEventHandlers); y(this.elements[1], "keydown", function (a) {
            if (13 === a.keyCode) {
              if ("createEvent" in document) { var c = document.createEvent("HTMLEvents"); c.initEvent("change", !1, !0); this.dispatchEvent(c) } else this.fireEvent("onchange");
              this.blur(); a.preventDefault && a.preventDefault()
            }
          }, this.rangeSelector.stockChart.allDOMEventHandlers)
    } function U(f, m) { U.base.constructor.call(this, "ButtonStyle", "buttonStyle", m, null, f.rangeSelector); this.stockChart = f; this.parent = this.rangeSelector = f.rangeSelector; this.options = h(m) || h(m.buttonStyle) ? {} : m.buttonStyle; this.optionsName = "buttonStyle" } function W(f, m) {
      W.base.constructor.call(this, "Style", "style", m, null, f.rangeSelector.inputFields); this.stockChart = f; this.parent = this.inputFields = f.rangeSelector.inputFields;
      this.options = h(m) || h(m.style) ? {} : m.style; this.optionsName = "style"
    } var Y = !0; V(D, K); D.prototype._updateOptions = function () {
      this.updateOption("width"); this.updateOption("height"); this.updateOption("theme"); this.updateOption("colorSet") && (this._selectedColorSet = "undefined" !== typeof wa[this.colorSet] ? wa[this.colorSet] : wa.colorSet1); this.updateOption("backgroundColor"); this.backgroundColor || (this.backgroundColor = "rgba(0,0,0,0)"); this.updateOption("exportEnabled"); this.updateOption("exportFileName"); this.updateOption("creditHref");
      this.updateOption("creditHref"); this.updateOption("culture"); this._cultureInfo = new Oa(this.options.culture); this.updateOption("animationEnabled"); this.updateOption("animationDuration"); this.updateOption("rangeChanging"); this.updateOption("rangeChanged"); ib(this)
    }; D._supportedChartTypes = Ea("line stepLine spline column area stepArea splineArea bubble scatter stackedColumn stackedColumn100 stackedArea stackedArea100 candlestick ohlc boxAndWhisker rangeColumn error rangeArea rangeSplineArea waterfall".split(" "));
    D.prototype._initialize = function () {
      this.toolbar = new Wa(this, this.options.toolbar); this._updateOptions(); this.animationEnabled = this.animationEnabled && s; this._updateSize(); this.clearCanvas(); this.ctx.beginPath(); var f, x = h(this.options.charts) ? [] : this.options.charts; Ea(x); for (var v = 0; v < this.charts.length; v++)f = this.charts[v], 0 > x.indexOf(f.options) && (this.charts.splice(v, 1), f.destroy(), this._canvasJSContainer.removeChild(f.panel), v--); this.layoutManager = new La(0, 0, this.width, this.height, 2); this.plotArea.layoutManager &&
        this.plotArea.layoutManager.reset(); this.options.title && (this.title = new G(this, this.options.title), this.title.setLayout()); if (this.options.subtitles) for (this.subtitles = [], v = 0; v < this.options.subtitles.length; v++)f = new N(this, this.options.subtitles[v], v), this.subtitles.push(f), f.setLayout(); this.navigator = this.navigator || new B(this, this.options.navigator); this.navigator._initialize(); if (this.navigator.enabled) {
          f = {
            theme: this.options.navigator && this.options.navigator.theme ? this.options.navigator.theme :
              this.theme, animationEnabled: this.options.navigator && !h(this.options.navigator.animationEnabled) ? this.options.navigator.animationEnabled : this.animationEnabled, animationDuration: this.options.navigator && this.options.navigator.animationDuration ? this.options.navigator.animationDuration : this.animationDuration, culture: this.options.navigator && this.options.navigator.culture ? this.options.navigator.culture : this.culture, zoomEnabled: !1, data: this.options.navigator && this.options.navigator.data ? this.options.navigator.data :
                this.options.charts && this.options.charts[0] && this.options.charts[0].data ? Za(this.options.charts[0].data) : [], axisX: this.options.navigator && this.options.navigator.axisX ? this.options.navigator.axisX : {}, axisY: this.options.navigator && this.options.navigator.axisY ? this.options.navigator.axisY : {}, axisX2: this.options.navigator && this.options.navigator.axisX2 ? this.options.navigator.axisX2 : {}, axisY2: this.options.navigator && this.options.navigator.axisY2 ? this.options.navigator.axisY2 : {}, interactivityEnabled: !1,
            exportEnabled: !1
          }; for (v = 0; v < f.data.length; v++)!h(this.navigator.options.data) || !h(f.data[v].type) && (h(f.data[v].type) || 0 <= f.data[v].type.indexOf("range") || 0 <= f.data[v].type.indexOf("ohlc") || 0 <= f.data[v].type.indexOf("candlestick") || 0 <= f.data[v].type.indexOf("error")) ? this.navigator.options.data && h(this.navigator.options.data[v].type) && (f.data[v].type = "splineArea") : f.data[v].type = "splineArea"; if (f.axisX.length) for (v = 0; v < f.axisX.length; v++)f.axisX[v].titleFontSize = h(f.axisX[v].titleFontSize) ? 1 : f.axisX[v].titleFontSize,
            f.axisX[v].labelFontSize = h(f.axisX[v].labelFontSize) ? 12 : f.axisX[v].labelFontSize, f.axisX[v].labelAngle = h(f.axisX[v].labelAngle) ? 0 : f.axisX[v].labelAngle, f.axisX[v].labelPlacement = h(f.axisX[v].labelPlacement) ? "inside" : f.axisX[v].labelPlacement, f.axisX[v].tickLength = h(f.axisX[v].tickLength) ? 0 : f.axisX[v].tickLength, f.axisX[v].lineThickness = h(f.axisX[v].lineThickness) ? 0 : f.axisX[v].lineThickness, f.axisX[v].tickThickness = h(f.axisX[v].tickThickness) ? 0 : f.axisX[v].tickThickness, f.axisX[v].gridThickness = h(f.axisX[v].gridThickness) ?
              1 : f.axisX[v].gridThickness; else f.axisX.titleFontSize = this.options.navigator && this.options.navigator.axisX && !h(this.options.navigator.axisX.titleFontSize) ? this.options.navigator.axisX.titleFontSize : s ? 0 : 1, f.axisX.labelFontSize = this.options.navigator && this.options.navigator.axisX && !h(this.options.navigator.axisX.labelFontSize) ? this.options.navigator.axisX.labelFontSize : 12, f.axisX.labelAngle = this.options.navigator && this.options.navigator.axisX && !h(this.options.navigator.axisX.labelAngle) ? this.options.navigator.axisX.labelAngle :
                0, f.axisX.labelPlacement = this.options.navigator && this.options.navigator.axisX && !h(this.options.navigator.axisX.labelPlacement) ? this.options.navigator.axisX.labelPlacement : "inside", f.axisX.tickLength = this.options.navigator && this.options.navigator.axisX && !h(this.options.navigator.axisX.tickLength) ? this.options.navigator.axisX.tickLength : 0, f.axisX.lineThickness = this.options.navigator && this.options.navigator.axisX && !h(this.options.navigator.axisX.lineThickness) ? this.options.navigator.axisX.lineThickness :
                  0, f.axisX.tickThickness = this.options.navigator && this.options.navigator.axisX && !h(this.options.navigator.axisX.tickThickness) ? this.options.navigator.axisX.tickThickness : 0, f.axisX.gridThickness = this.options.navigator && this.options.navigator.axisX && !h(this.options.navigator.axisX.gridThickness) ? this.options.navigator.axisX.gridThickness : 1; if (f.axisY.length) for (v = 0; v < f.axisY.length; v++)f.axisY[v].titleFontSize = f.axisY[v].titleFontSize ? f.axisY[v].titleFontSize : s ? 0 : 1, f.axisY[v].labelFontSize = f.axisY[v].labelFontSize ?
                    f.axisY[v].labelFontSize : s ? 0 : 1, f.axisY[v].labelPlacement = f.axisY[v].labelPlacement ? f.axisY[v].labelPlacement : "inside", f.axisY[v].includeZero = !1, f.axisY[v].lineThickness = 0, f.axisY[v].tickThickness = 0, f.axisY[v].tickLength = 0, f.axisY[v].gridThickness = 0; else f.axisY.titleFontSize = this.options.navigator && this.options.navigator.axisY && this.options.navigator.axisY.titleFontSize ? this.options.navigator.axisY.titleFontSize : s ? 0 : 1, f.axisY.labelFontSize = this.options.navigator && this.options.navigator.axisY && this.options.navigator.axisY.labelFontSize ?
                      this.options.navigator.axisY.labelFontSize : s ? 0 : 1, f.axisY.labelPlacement = this.options.navigator && this.options.navigator.axisY && this.options.navigator.axisY.labelPlacement ? this.options.navigator.axisY.labelPlacement : "inside", f.axisY.includeZero = !1, f.axisY.lineThickness = 0, f.axisY.tickThickness = 0, f.axisY.tickLength = 0, f.axisY.gridThickness = 0; if (f.axisX2.length) for (v = 0; v < f.axisX2.length; v++)f.axisX2[v].titleFontSize = f.axisX2[v].titleFontSize ? f.axisX2[v].titleFontSize : s ? 0 : 1, f.axisX2[v].labelFontSize = f.axisX2[v].labelFontSize ?
                        f.axisX2[v].labelFontSize : 12, f.axisX2[v].labelAngle = h(f.axisX2[v].labelAngle) ? 0 : f.axisX2[v].labelAngle, f.axisX2[v].labelPlacement = f.axisX2[v].labelPlacement ? f.axisX2[v].labelPlacement : "inside", f.axisX2[v].tickLength = h(f.axisX2[v].tickLength) ? 0 : f.axisX2[v].tickLength, f.axisX2[v].lineThickness = f.axisX2[v].lineThickness ? f.axisX2[v].lineThickness : 0, f.axisX2[v].tickThickness = f.axisX2[v].tickThickness ? f.axisX2[v].tickThickness : 1, f.axisX2[v].gridThickness = h(f.axisX2[v].gridThickness) ? 1 : f.axisX2[v].gridThickness;
          else f.axisX2.titleFontSize = this.options.navigator && this.options.navigator.axisX2 && this.options.navigator.axisX2.titleFontSize ? this.options.navigator.axisX2.titleFontSize : s ? 0 : 1, f.axisX2.labelFontSize = this.options.navigator && this.options.navigator.axisX2 && this.options.navigator.axisX2.labelFontSize ? this.options.navigator.axisX2.labelFontSize : 12, f.axisX2.labelAngle = this.options.navigator && this.options.navigator.axisX2 && this.options.navigator.axisX2.labelAngle ? this.options.navigator.axisX2.labelAngle :
            0, f.axisX2.labelPlacement = this.options.navigator && this.options.navigator.axisX2 && this.options.navigator.axisX2.labelPlacement ? this.options.navigator.axisX2.labelPlacement : "inside", f.axisX2.tickLength = this.options.navigator && this.options.navigator.axisX2 && this.options.navigator.axisX2.tickLength ? this.options.navigator.axisX2.tickLength : 0, f.axisX2.lineThickness = this.options.navigator && this.options.navigator.axisX2 && this.options.navigator.axisX2.lineThickness ? this.options.navigator.axisX2.lineThickness :
              0, f.axisX2.tickThickness = this.options.navigator && this.options.navigator.axisX2 && this.options.navigator.axisX2.tickThickness ? this.options.navigator.axisX2.tickThickness : 1, f.axisX2.gridThickness = this.options.navigator && this.options.navigator.axisX2 && this.options.navigator.axisX2.gridThickness ? this.options.navigator.axisX2.gridThickness : 1; if (f.axisY2.length) for (v = 0; v < f.axisY2.length; v++)f.axisY2[v].titleFontSize = f.axisY2[v].titleFontSize ? f.axisY2[v].titleFontSize : s ? 0 : 1, f.axisY2[v].labelFontSize = f.axisY2[v].labelFontSize ?
                f.axisY2[v].labelFontSize : s ? 0 : 1, f.axisY2[v].labelPlacement = f.axisY2[v].labelPlacement ? f.axisY2[v].labelPlacement : "inside", f.axisY2[v].includeZero = !1, f.axisY2[v].lineThickness = 0, f.axisY2[v].margin = 0, f.axisY2[v].tickLength = 0, f.axisY2[v].tickThickness = 0, f.axisY2[v].gridThickness = 0; else f.axisY2.titleFontSize = this.options.navigator && this.options.navigator.axisY2 && this.options.navigator.axisY2.titleFontSize ? this.options.navigator.axisY2.titleFontSize : s ? 0 : 1, f.axisY2.labelFontSize = this.options.navigator &&
                  this.options.navigator.axisY2 && this.options.navigator.axisY2.labelFontSize ? this.options.navigator.axisY2.labelFontSize : s ? 0 : 1, f.axisY2.labelPlacement = this.options.navigator && this.options.navigator.axisY2 && this.options.navigator.axisY2.labelPlacement ? this.options.navigator.axisY2.labelPlacement : "inside", f.axisY2.includeZero = !1, f.axisY2.lineThickness = 0, f.axisY2.margin = 0, f.axisY2.tickLength = 0, f.axisY2.tickThickness = 0, f.axisY2.gridThickness = 0; f.backgroundColor = this.navigator.backgroundColor; for (v = 0; v <
                    f.data.length; v++)f.data[v].markerSize = f.data[v].markerSize ? f.data[v].markerSize : 0; if (!this.navigator.chart) { var n = m("canvasjs-chart-panel"); this.navigator.panel.appendChild(n); n.style.height = this.navigator.height + "px"; n.style.width = this.navigator.width + "px" } this.navigator.chart && (this.navigator.chart.panel.style.width = this.navigator.width + "px"); this.navigator.chart = this.navigator.chart || new Ka(n, f, { parent: this.navigator, isOptionsInArray: !1, index: null, predefinedThemes: bb, optionsName: "navigator", stockChart: this });
          this.navigator.chart._initialize(); this.navigator.chart.setLayout(); this.navigator.chart._selectedColorSet = this._selectedColorSet; this.navigator._chartOptions = f; this.navigator.slider = this.navigator.slider || new Q(this.navigator, this.options); this.navigator.slider._initialize()
        } this.rangeSelector = this.rangeSelector || new R(this, this.options); this.rangeSelector.buttonStyle = this.rangeSelector.buttonStyle || new U(this, this.rangeSelector.options); this.rangeSelector.inputFields = this.rangeSelector.inputFields ||
          new T(this, this.rangeSelector.options); this.rangeSelector.inputFields.style = new W(this, this.rangeSelector.inputFields.options); this.rangeSelector.inputFields.style._updateOptions(); this.rangeSelector.inputFields._initialize(); if (this.rangeSelector.inputFields && this.rangeSelector.inputFields.enabled) for (this.rangeSelector.inputFields._textBlocks = [], this.rangeSelector.inputFields._labels = [], this.rangeSelector.inputFieldsWidth = 0, n = this.rangeSelector.inputFields.style.maxWidth = this.rangeSelector.inputFields.style.options.maxWidth ?
            this.rangeSelector.inputFields.style.options.maxWidth : this.rangeSelector.stockChart.width / 2, v = 0; v < this.rangeSelector.inputFields.elements.length; v++) {
            f = new ja(this.rangeSelector.ctx, {
              x: 0, y: 0, backgroundColor: this.rangeSelector.inputFields.style.backgroundColor, borderColor: this.rangeSelector.inputFields.style.borderColor, borderThickness: this.rangeSelector.inputFields.style.borderThickness, cornerRadius: 0, maxWidth: h(this.rangeSelector.inputFields.style.options.width) ? n : this.rangeSelector.inputFields.style.width,
              maxHeight: 2 * this.rangeSelector.inputFields.style.fontSize, angle: 0, padding: this.rangeSelector.inputFields.style.padding, text: this.rangeSelector.inputFields.valueFormatString, horizontalAlign: "center", fontSize: this.rangeSelector.inputFields.style.fontSize, fontFamily: this.rangeSelector.inputFields.style.fontFamily, fontWeight: this.rangeSelector.inputFields.style.fontWeight, fontColor: this.rangeSelector.inputFields.style.fontColor, fontStyle: this.rangeSelector.inputFields.style.fontStyle, textBaseline: "middle"
            });
            var x = f.measureText(), a = new ja(this.rangeSelector.ctx, {
              x: 0, y: 0, backgroundColor: s ? "transparent" : null, borderColor: this.rangeSelector.inputFields.style.borderColor, borderThickness: 0, cornerRadius: 0, maxWidth: this.rangeSelector.inputFields.style.maxWidth, maxHeight: 2 * this.rangeSelector.inputFields.style.fontSize, angle: 0, padding: this.rangeSelector.inputFields.style.padding, text: "From", horizontalAlign: "left", fontSize: this.rangeSelector.inputFields.style.fontSize, fontFamily: this.rangeSelector.inputFields.style.fontFamily,
              fontWeight: this.rangeSelector.inputFields.style.fontWeight, fontColor: this.rangeSelector.inputFields.style.fontColor, fontStyle: this.rangeSelector.inputFields.style.fontStyle, textBaseline: "middle"
            }); this.rangeSelector.inputFields._textBlocks.push(f); this.rangeSelector.inputFields._labels.push(a); this.rangeSelector.inputFields._textBlocks[v].bounds = { x1: null, x2: null, y1: null, y2: null, width: null, height: null }; this.rangeSelector.inputFields._labels[v].bounds = { x1: null, x2: null, y1: null, y2: null, width: null, height: null };
            this.rangeSelector.inputFieldsWidth += x.width + this.rangeSelector.inputFields.style.spacing + a.measureText().width; this.rangeSelector.inputFieldsHeight = this.rangeSelector.inputFieldsHeight < x.height ? x.height : this.rangeSelector.inputFieldsHeight; f = this.rangeSelector.inputFields._textBlocks[v]; f.id = ++this.rangeSelector.stockChart._eventManager.lastObjectId; this.rangeSelector.stockChart._eventManager.objectMap[f.id] = { id: f.id, objectType: "inputFields", inputFieldIndex: v }
          } this.rangeSelector.buttonStyle._updateOptions();
      this.rangeSelector._initialize(); this._objectsInitialized = !0
    }; D.prototype.render = function (f) {
      var x = this; f && (this.options = f); this._initialize(); this.title && this.title.render(); if (this.subtitles) for (f = 0; f < this.subtitles.length; f++)this.subtitles[f].render(); var v; if (this.options.charts) {
        v = Array(this.options.charts.length); var n = this.layoutManager.getFreeSpace(), a = n.height, n = n.height, d = this.options.charts.length; for (f = 0; f < this.options.charts.length; f++)h(this.options.charts[f].height) || (v[f] = 0 <= this.options.charts[f].height.toString().indexOf("%") ?
          Va(this.options.charts[f].height, a, Math.floor(n / d), this.height, 0) : this.options.charts[f].height, n -= v[f], d--); n = Math.floor(n / d); for (f = 0; f < this.options.charts.length; f++)h(v[f]) && (v[f] = n); var b, d = this.options.charts, c = this.charts; this.charts = []; for (f = 0; f < d.length; f++) {
            n = this.layoutManager.getFreeSpace(); a = d[f]; a.theme = d[f].theme ? d[f].theme : this.options.theme ? this.options.theme : this.theme; a.animationEnabled = h(d[f].animationEnabled) ? this.animationEnabled : d[f].animationEnabled; a.animationDuration = d[f].animationDuration ?
              d[f].animationDuration : this.animationDuration; a.culture = d[f].culture ? d[f].culture : this.culture; a.height = d[f].height ? v[f] : null; h(d.backgroundColor) ? h(this.options.backgroundColor) || (a.backgroundColor = this.backgroundColor) : a.backgroundColor = this.options.charts[f].backgroundColor; for (b = c.length; 0 < b-- && c[b].options !== a;); 0 <= b ? (this.charts[f] = c[b], this.charts[f].options = a) : (b = m("canvasjs-chart-panel"), b.style.height = v[f] + "px", this._canvasJSContainer.appendChild(b), this.charts[f] = new Ka(b, a, {
                parent: this,
                isOptionsInArray: !0, index: f, predefinedThemes: bb, optionsName: "charts", stockChart: this
              })); this.charts[f].panEnabled = this.charts[f].options.zoomEnabled ? !1 : !0; this.charts[f].panel.style.width = n.width + "px"; this.charts[f].panel.style.top = n.y1 + "px"; this.charts[f].panel.style.left = n.x1 + "px"; this.charts[f].panel.style.height = v[f] + "px"; this.charts[f].height = a.height ? a.height : v[f]; this.layoutManager.registerSpace("top", { width: n.width, height: v[f] })
          } c = null; for (f = 0; f < this.charts.length; f++)if (!h(this.options.charts[f].data)) for (b =
            0; b < this.options.charts[f].data.length; b++)v = this.options.charts[f].data[b], 0 <= D._supportedChartTypes.indexOf(v.type) || h(v.type) || (Y = !1, window.console && window.console.log("CanvasJS Error: " + v.type + " Chart is not Supported in StockChart")); if (!Y) return; this.setChartsLayout(); for (f = v = 0; f < this.charts.length; f++)if (h(this.charts[f].options.colorSet)) {
              this.charts[f]._selectedColorSet = []; for (b = v; b < v + this.charts[f].data.length; b++)this.charts[f]._selectedColorSet.push(this._selectedColorSet[b % this._selectedColorSet.length]);
              v += this.charts[f].data.length
            } if (this.navigator && this.navigator.enabled) if (this.navigator.options.data) { this.navigator.chart._selectedColorSet = []; for (b = v; b < v + this.navigator.chart.data.length; b++)this.navigator.chart._selectedColorSet.push(this._selectedColorSet[b % this._selectedColorSet.length]); v += this.navigator.chart.data.length } else this.navigator.chart._selectedColorSet = this.charts[0]._selectedColorSet
      } if (this.navigator && this.navigator.enabled) {
        for (f = 0; f < this.navigator.chart.data.length; f++)0 <=
          D._supportedChartTypes.indexOf(this.navigator.chart.data[f].type) || (Y = !1, window.console && window.console.log("CanvasJS Error: " + this.navigator.chart.data[f].type + " Chart is not Supported in Navigator")); if (Y) {
            var e = this.navigator.chart.axisX && this.navigator.chart.axisX.length ? this.navigator.chart.axisX[0] : this.navigator.chart.axisX2[0]; e.bounds.x1 > this._chartsPlotAreaX1 && (this._chartsPlotAreaX1 = e.bounds.x1); this.navigator.width = this.navigator.chart.width = this.navigator.slider.fullWidth = this.navigator.options.width ?
              this.navigator.options.width : this._chartsPlotAreaX2 - this._chartsPlotAreaX1 + e.bounds.x1; this.navigator.panel.style.left = this._chartsPlotAreaX1 + this.layoutManager.getFreeSpace().x1 - e.bounds.x1 + "px"; this.navigator.panel.style.width = this.navigator.chart.panel.style.width = this.navigator.options.width ? this.navigator.options.width : this._chartsPlotAreaX2 - this._chartsPlotAreaX1 + e.bounds.x1 + "px"; this.navigator.chart.render(this.navigator._chartOptions); this.navigator.backgroundColor = this.navigator.chart.backgroundColor;
            this.navigator.animationEnabled = this.navigator.chart.animationEnabled; this.navigator.animationDuration = this.navigator.chart.animationDuration; this.navigator.theme = this.navigator.chart.theme; this.navigator.axisX = this.navigator.chart.axisX; this.navigator.axisX2 = this.navigator.chart.axisX2; this.navigator.axisY = this.navigator.chart.axisY; this.navigator.axisY2 = this.navigator.chart.axisY2; this.navigator.data = this.navigator.chart.data
          }
      } n = v = null; b = 0; d = a = null; for (f = 0; f < this.charts.length; f++)for (c = this.charts[f].axisX &&
        this.charts[f].axisX.length ? this.charts[f].axisX : this.charts[f].axisX2, v = v || (c && 0 < c.length ? c[0].minimum : null), n = n || (c && 0 < c.length ? c[0].maximum : null), b = 0; b < c.length; b++)e = c[b], e.minimum < v && (v = e.minimum), e.maximum > n && (n = e.maximum); var g; this.navigator && (this.navigator.chart && Y) && (g = this.navigator.chart.axisX && 0 < this.navigator.chart.axisX.length ? this.navigator.chart.axisX[0] : this.navigator.chart.axisX2[0], this._axisXMin = this.navigator.slider.minimum = h(this.navigator.options.slider) || h(this.navigator.options.slider.minimum) ?
          null : Math.max(g.minimum, this.navigator.slider.minimum), this._axisXMax = this.navigator.slider.maximum = h(this.navigator.options.slider) || h(this.navigator.options.slider.maximum) ? null : Math.min(g.maximum, this.navigator.slider.maximum)); if (this.rangeSelector && this.rangeSelector.enabled) {
            b = g ? g.maximum - g.minimum : n - v; this.charts && this.charts.length && (e = this.charts[0].axisX && this.charts[0].axisX.length ? this.charts[0].axisX[0] : this.charts[0].axisX2[0]); for (f = 0; f < this.rangeSelector.buttons.length; f++) {
              var w =
                null, c = this.rangeSelector.buttons[f]; "year" === c.rangeType ? w = 31104E6 * c.range : "ytd" === c.rangeType ? w = "ytd" : "month" === c.rangeType ? w = 2592E6 * c.range : "week" === c.rangeType ? w = 6048E5 * c.range : "day" === c.rangeType ? w = 864E5 * c.range : "hour" === c.rangeType ? w = 36E5 * c.range : "minute" === c.rangeType ? w = 6E4 * c.range : "second" === c.rangeType ? w = 1E3 * c.range : "millisecond" === c.rangeType ? w = c.range : "all" === c.rangeType ? w = null : "number" === c.rangeType && (w = c.range); if ("ytd" === c.rangeType || w < b) c.enabled = !0; c.enabled ? (c.cursor = this.rangeSelector.buttonStyle.cursor,
                  "on" === c.state && ((h(this._axisXMin) && h(this._axisXMax) && (c.textBlock.fontWeight = "bold", c.textBlock.fontColor = this.rangeSelector.buttonStyle.labelFontColorOnHover, c.textBlock.backgroundColor = this.rangeSelector.buttonStyle.backgroundColorOnSelect), "ytd" === c.rangeType && e) ? (a = new Date(e.viewportMaximum), a.setDate(1), a.setMonth(0), a = a.getTime()) : h(w) ? g ? (a = g.minimum, d = g.maximum) : e && (a = e.minimum, d = e.maximum) : e.viewportMaximum - w < (g ? g.minimum : e.minimum) ? (d = g.minimum - (e.viewportMaximum - w), a = g.minimum, d = Math.min(g.maximum,
                    e.viewportMaximum + d)) : (a = e.viewportMaximum - w, d = e.viewportMaximum)), h(this._axisXMin) && h(this._axisXMax) || (c.state = "off"), this._axisXMin = h(this._axisXMin) ? a : this._axisXMin, this._axisXMax = h(this._axisXMax) ? d : this._axisXMax) : c.cursor = "not-allowed"; c.mousemove = function (a) { this.enabled && "off" === this.state && (this.textBlock.backgroundColor = a.stockChart.rangeSelector.buttonStyle.backgroundColorOnHover, this.textBlock.fontColor = a.stockChart.rangeSelector.buttonStyle.labelFontColorOnHover, this.textBlock.render(!0)) };
              c.mouseover = function (a) { this.enabled && "off" === this.state && (this.textBlock.backgroundColor = a.stockChart.rangeSelector.buttonStyle.backgroundColorOnHover, this.textBlock.fontColor = a.stockChart.rangeSelector.buttonStyle.labelFontColorOnHover, this.textBlock.render(!0)) }; c.mouseout = function (a) { this.enabled && "off" === this.state && (this.textBlock.backgroundColor = a.stockChart.rangeSelector.buttonStyle.backgroundColor, this.textBlock.fontColor = a.stockChart.rangeSelector.buttonStyle.labelFontColor, this.textBlock.render(!0)) };
              c.click = function (a) {
                if (this.enabled) {
                  for (var b = 0, c = null, d = null, e = 0; e < x.rangeSelector.buttons.length; e++)x.rangeSelector.buttons[e].state = "off", x.rangeSelector.buttons[e].textBlock.fontWeight = x.rangeSelector.buttonStyle.labelFontWeight, x.rangeSelector.buttons[e].textBlock.fontColor = a.stockChart.rangeSelector.buttonStyle.labelFontColor, x.rangeSelector.buttons[e].textBlock.backgroundColor = a.stockChart.rangeSelector.buttonStyle.backgroundColor, x.rangeSelector.buttons[e].textBlock.render(!0); this.state =
                    "on"; this.textBlock.fontWeight = "bold"; this.textBlock.fontColor = a.stockChart.rangeSelector.buttonStyle.labelFontColorOnHover; this.textBlock.backgroundColor = a.stockChart.rangeSelector.buttonStyle.backgroundColorOnSelect; this.textBlock.render(!0); var f; x.charts && x.charts.length && (f = x.charts[0].axisX && x.charts[0].axisX.length ? x.charts[0].axisX[0] : x.charts[0].axisX2[0]); var g; x.navigator && x.navigator.chart && (g = x.navigator.chart.axisX ? x.navigator.chart.axisX[0] : x.navigator.chart.axisX2[0]); "year" === this.rangeType ?
                      b = 31104E6 * this.range : "month" === this.rangeType ? b = 2592E6 * this.range : "week" === this.rangeType ? b = 6048E5 * this.range : "day" === this.rangeType ? b = 864E5 * this.range : "hour" === this.rangeType ? b = 36E5 * this.range : "minute" === this.rangeType ? b = 6E4 * this.range : "second" === this.rangeType ? b = 1E3 * this.range : "millisecond" === this.rangeType ? b = this.range : "all" === this.rangeType ? b = null : "number" === this.rangeType && (b = this.range); "ytd" === this.rangeType && f ? (c = new Date(f.viewportMaximum), c.setDate(1), c.setMonth(0), b = c.getTime(), c = Math.max(b,
                        g ? g.minimum : f.minimum), d = f.viewportMaximum) : h(b) ? g ? (c = g.minimum, d = g.maximum) : f && (c = f.minimum, d = f.maximum) : g && f.viewportMaximum - b < (g ? g.minimum : f.minimum) ? (g = x.navigator.chart.axisX[0].minimum - (f.viewportMaximum - b), c = x.navigator.chart.axisX[0].minimum, d = Math.min(x.navigator.chart.axisX[0].maximum, f.viewportMaximum + g)) : (c = f.viewportMaximum - b, d = f.viewportMaximum); x._rangeEventParameter = { stockChart: x, source: "buttons", index: this._index, minimum: c, maximum: d }; x._rangeEventParameter.type = "rangeChanging"; x.dispatchEvent("rangeChanging",
                          x._rangeEventParameter, x); x._syncCharts(c, d); x.sessionVariables._axisXMin = c; x.sessionVariables._axisXMax = d; x._rangeEventParameter.type = "rangeChanged"; x.dispatchEvent("rangeChanged", x._rangeEventParameter, x)
                }
              }
            } if (this.rangeSelector.inputFields && this.rangeSelector.inputFields.enabled) {
              this.rangeSelector.inputFields.valueType = this.options.rangeSelector && this.options.rangeSelector.inputFields && this.options.rangeSelector.inputFields.valueType ? this.options.rangeSelector.inputFields.valueType : this.isDateTime ?
                "dateTime" : "number"; for (f = 0; f < this.rangeSelector.inputFields._textBlocks.length; f++)e = this.rangeSelector.inputFields._textBlocks[f], e.mousemove = function (a) { a.inputField.cursor = a.stockChart.rangeSelector.inputFields.style.cursor }, e.mouseover = function (a) { a.inputField.cursor = a.stockChart.rangeSelector.inputFields.style.cursor }, e.mouseout = function (a) { a.inputField.cursor = "auto" }, e.click = function (a) { a.stockChart.rangeSelector.inputFields.elements[a.inputFieldIndex].style.display = "inline"; a.stockChart.rangeSelector.inputFields.elements[a.inputFieldIndex].focus() };
              if (isFinite(v) && isFinite(n)) {
                "dateTime" === this.rangeSelector.inputFields.valueType ? (this.rangeSelector.inputFields.valueFormatString = this.options.rangeSelector && this.options.rangeSelector.inputFields && this.options.rangeSelector.inputFields.valueFormatString ? this.options.rangeSelector.inputFields.valueFormatString : "MMM DD YYYY", this.rangeSelector.inputFields.startValue = h(this.rangeSelector.inputFields.options.startValue) ? h(a) ? v : a : ka(this.rangeSelector.inputFields.options.startValue, this.rangeSelector.inputFields.valueFormatString),
                  this.rangeSelector.inputFields.endValue = h(this.rangeSelector.inputFields.options.endValue) ? h(d) ? n : d : ka(this.rangeSelector.inputFields.options.endValue, this.rangeSelector.inputFields.valueFormatString)) : (this.rangeSelector.inputFields.valueFormatString = this.options.rangeSelector && this.options.rangeSelector.inputFields && this.options.rangeSelector.inputFields.valueFormatString ? this.options.rangeSelector.inputFields.valueFormatString : "#,##0.##", this.rangeSelector.inputFields.startValue = h(this.rangeSelector.inputFields.options.startValue) ?
                    h(a) ? v : a : this.rangeSelector.inputFields.options.startValue, this.rangeSelector.inputFields.endValue = h(this.rangeSelector.inputFields.options.endValue) ? h(d) ? n : d : this.rangeSelector.inputFields.options.endValue); if (!(h(this._axisXMin) && h(this._axisXMax) && h(this.rangeSelector.inputFields.options.startValue) && h(this.rangeSelector.inputFields.options.endValue))) for (b = 0; b < this.rangeSelector.buttons.length; b++)c = this.rangeSelector.buttons[b]; f = ka(this.rangeSelector.inputFields.startValue, "YYYY-MM-DD'T'HH:mm:ssZ");
                e = ka(this.rangeSelector.inputFields.endValue, "YYYY-MM-DD'T'HH:mm:ssZ"); s || (f = f.replace(/-/g, "/"), e = e.replace(/-/g, "/"), f = f.replace("T", " "), e = e.replace("T", " "), f = f.replace(/(\+[0-9]{2})(\:)([0-9]{2}$)/, " UTC$1$3"), e = e.replace(/(\+[0-9]{2})(\:)([0-9]{2}$)/, " UTC$1$3")); this._axisXMin = h(this._axisXMin) ? "dateTime" === this.rangeSelector.inputFields.valueType ? (new Date(f)).getTime() : this.rangeSelector.inputFields.startValue : this._axisXMin; this._axisXMax = h(this._axisXMax) ? "dateTime" === this.rangeSelector.inputFields.valueType ?
                  (new Date(e)).getTime() : this.rangeSelector.inputFields.endValue : this._axisXMax
              }
            } this.rangeSelector.render()
          } h(this._axisXMin) && (this._axisXMin = v); h(this._axisXMax) && (this._axisXMax = n); this._axisXMin = h(this.sessionVariables._axisXMin) ? this._axisXMin : this.sessionVariables._axisXMin; this._axisXMax = h(this.sessionVariables._axisXMax) ? this._axisXMax : this.sessionVariables._axisXMax; if (!h(g)) {
            if (this._axisXMin < g.minimum || this._axisXMin > g.maximum) this._axisXMin = g.minimum; if (this._axisXMax < g.minimum || this._axisXMax >
              g.maximum) this._axisXMax = g.maximum
          } !h(g) && g.reversed ? this._syncCharts(this._axisXMax, this._axisXMin) : this._syncCharts(this._axisXMin, this._axisXMax)
    }; D.prototype.setChartsLayout = function () {
      var f, h, m = 0, n = this.width; this.isPlotAreaSet = this.isDateTime = !1; for (var a = 0; a < this.charts.length; a++) {
        f = this.charts[a]; f._initialize(); f.setLayout(); h = {}; if ((f.axisX[0] || f.axisX2[0]) && (f.axisY[0] || f.axisY2[0])) {
          var d = f.axisX[0] ? f.axisX[0].lineCoordinates : f.axisX2[0].lineCoordinates; if (f.axisY && 0 < f.axisY.length &&
            f.axisY[0]) { var b = f.axisY[0]; h.x1 = d.x1 < d.x2 ? d.x1 : b.lineCoordinates.x1; h.x2 = d.x2 > b.lineCoordinates.x2 ? d.x2 : b.lineCoordinates.x2 } f.axisY2 && 0 < f.axisY2.length && f.axisY2[0] && (b = f.axisY2[0], h.x1 = d.x1 < d.x2 ? d.x1 : b.lineCoordinates.x1, h.x2 = d.x2 > b.lineCoordinates.x2 ? d.x2 : b.lineCoordinates.x2)
        } for (d = 0; d < f.data.length; d++)"dateTime" === f.data[d].xValueType && (this.isDateTime = !0); m = Math.max(m, h.x1); n = Math.min(n, h.x2); f.sessionVariables.plotAreaBounds = h
      } this._chartsPlotAreaX1 = m; this._chartsPlotAreaX2 = n
    }; D.prototype._updateSize =
      function () { return mb.call(this, [this.canvas, this.overlaidCanvas]) }; D.prototype._syncCharts = function (f, m) {
        for (var v = this, n = null, a = Math.min(f, m), d = Math.max(f, m), b = 0; b < this.charts.length; b++) {
          n = this.charts[b]; n.toolTip && n.toolTip.enabled && n.toolTip.hide(); for (var c = 0; c < n.axisX.length; c++)n.axisX[c].setViewPortRange(f, m); for (c = 0; c < n.axisX2.length; c++)n.axisX2[c].setViewPortRange(f, m); n.render(); (h(this.charts[b].options.toolTip) || !h(this.charts[b].options.toolTip) && h(this.charts[b].options.toolTip.updated)) &&
            this.charts[b].toolTip && (this.charts[b].toolTip.updated = function (a) { for (var b = 0; b < v.charts.length; b++)v.charts[b] != a.chart && v.charts[b].toolTip.showAtX(a.entries[0].xValue, a.entries[0].dataSeriesIndex) }); (h(this.charts[b].options.toolTip) || !h(this.charts[b].options.toolTip) && h(this.charts[b].options.toolTip.hidden)) && this.charts[b].toolTip && (this.charts[b].toolTip.hidden = function (a) { for (var b = 0; b < v.charts.length; b++)v.charts[b] != a.chart && v.charts[b].toolTip.hide() }); for (c = 0; c < this.charts[b].axisX.length; c++)this.charts[b].axisX[c].crosshair &&
              this.charts[b].axisX[c].crosshair.enabled && (this.charts[b].axisX[c].crosshair.options.updated || this.charts[b].axisX[c].crosshair.set("updated", function (a) { for (var b = 0; b < v.charts.length; b++)if (v.charts[b] != a.chart) for (var c = 0; c < v.charts[b].axisX.length; c++)v.charts[b].axisX[c].crosshair && v.charts[b].axisX[c].crosshair.showAt(a.value) })); for (c = 0; c < this.charts[b].axisX2.length; c++)this.charts[b].axisX2[c].crosshair && this.charts[b].axisX2[c].crosshair.enabled && (this.charts[b].axisX2[c].crosshair.options.updated ||
                this.charts[b].axisX2[c].crosshair.set("updated", function (a) { for (var b = 0; b < v.charts.length; b++)if (v.charts[b] != a.chart) for (var c = 0; c < v.charts[b].axisX2.length; c++)v.charts[b].axisX2[c].crosshair && v.charts[b].axisX2[c].crosshair.showAt(a.value) }))
        } this.rangeSelector && (this.rangeSelector.enabled && this.rangeSelector.inputFields && this.rangeSelector.inputFields.enabled) && this.rangeSelector._updateInputFields(a, d); this.navigator && this.navigator.enabled && this.navigator._updateSlider(a, d)
      }; D.prototype.destroy =
        function () {
          for (var f = this.allDOMEventHandlers, h = 0; h < this.charts.length; h++)this.charts[h].destroy(); this.navigator && this.navigator.enabled && this.navigator.chart.destroy(); for (h = 0; h < f.length; h++)hb(f[h][0], f[h][1], f[h][2], f[h][3]); for (this.allDOMEventHandlers = []; this.navigator && this.navigator.enabled && this.navigator.panel.hasChildNodes();)this.navigator.panel.removeChild(this.navigator.panel.lastChild); for (; this._canvasJSContainer && this._canvasJSContainer.hasChildNodes();)this._canvasJSContainer.removeChild(this._canvasJSContainer.lastChild);
          for (; this.container && this.container.hasChildNodes();)this.container.removeChild(this.container.lastChild); this.canvas = this.container = this._canvasJSContainer = null; this.navigator.panel = null; this.rangeSelector.panel = null
        }; D.prototype.exportChart = function (f) {
          f = "undefined" === typeof f ? {} : f; var h = f.format ? f.format : "png", m = f.fileName ? f.fileName : this.exportFileName, n = this.canvas.cloneNode(); n.setAttribute("class", n.getAttribute("class") + "-clone"); var a = n.getContext("2d"); a.drawImage(this.canvas, 0, 0); for (var d =
            [], b = 0; b < this.charts.length; b++) { var c = this.charts[b]; d.push({ canvas: c.canvas, position: { x: c.container.offsetLeft, y: c.container.offsetTop } }); d.push({ canvas: c.overlaidCanvas, position: { x: c.container.offsetLeft, y: c.container.offsetTop } }) } this.navigator && this.navigator.enabled && (b = this.navigator, d.push({ canvas: b.chart.canvas, position: { x: b.panel.offsetLeft, y: b.panel.offsetTop } }), d.push({ canvas: b.chart.overlaidCanvas, position: { x: b.panel.offsetLeft, y: b.panel.offsetTop } })); for (b = 0; b < d.length; b++)a.drawImage(d[b].canvas,
              d[b].position.x * ga, d[b].position.y * ga); if (f.toDataURL) return n.toDataURL("image/" + h); eb(n, h, m)
        }; D.prototype.print = function () {
          var f = this.exportChart({ toDataURL: !0 }), h = document.createElement("iframe"); h.setAttribute("class", "canvasjs-chart-print-frame"); h.setAttribute("style", "position:absolute; width:100%; border: 0px; margin: 0px 0px 0px 0px; padding 0px 0px 0px 0px;"); h.style.height = this.height + "px"; this._canvasJSContainer.appendChild(h); var m = this, n = h.contentWindow || h.contentDocument.document ||
            h.contentDocument; n.document.open(); n.document.write('<!DOCTYPE HTML>\n<html><body style="margin: 0px 0px 0px 0px; padding: 0px 0px 0px 0px;"><img src="' + f + '"/><body/></html>'); n.document.close(); setTimeout(function () { n.focus(); n.print(); setTimeout(function () { m._canvasJSContainer.removeChild(h) }, 1E3) }, 500)
        }; D.prototype.getObjectAtXY = function (f, m, v) {
          v = null; if (!h(this.rangeSelector)) {
            for (var n = 0; n < this.rangeSelector.buttons.length; n++) {
              var a = this.rangeSelector.buttons[n]; f >= a.bounds.x1 && (f <= a.bounds.x2 &&
                m >= a.bounds.y1 && m <= a.bounds.y2) && (v = a.id)
            } for (n = 0; n < this.rangeSelector.inputFields._textBlocks.length; n++)a = this.rangeSelector.inputFields._textBlocks[n], f >= a.bounds.x1 && (f <= a.bounds.x2 && m >= a.bounds.y1 && m <= a.bounds.y2) && (v = a.id)
          } return v
        }; D.prototype._touchEventHandler = function (f) {
          if (f.changedTouches) {
            var m = [], v = f.changedTouches, n = v ? v[0] : f, a = null; switch (f.type) {
              case "touchstart": case "MSPointerDown": m = ["mousemove", "mousedown"]; this._lastTouchData = Aa(n); this._lastTouchData.time = new Date; break; case "touchmove": case "MSPointerMove": m =
                ["mousemove"]; break; case "touchend": case "MSPointerUp": var d = this._lastTouchData && this._lastTouchData.time ? new Date - this._lastTouchData.time : 0, m = "touchstart" === this._lastTouchEventType || "MSPointerDown" === this._lastTouchEventType || 300 > d ? ["mouseup", "click"] : ["mouseup"]; break; default: return
            }if (!(v && 1 < v.length)) {
              a = Aa(n); a.time = new Date; try { var b = a.y - this._lastTouchData.y, d = a.time - this._lastTouchData.time; if (1 < Math.abs(b) && this._lastTouchData.scroll || 5 < Math.abs(b) && 250 > d) this._lastTouchData.scroll = !0 } catch (c) { } this._lastTouchEventType =
                f.type; if (this._lastTouchData && this._lastTouchData.scroll) this.isDrag && this.resetOverlayedCanvas(), this.isDrag = !1; else for (v = 0; v < m.length; v++)if (a = m[v], b = document.createEvent("MouseEvent"), b.initMouseEvent(a, !0, !0, window, 1, n.screenX, n.screenY, n.clientX, n.clientY, !1, !1, !1, !1, 0, null), n.target.dispatchEvent(b), this._lastTouchData && !h(this._lastTouchData.scroll) && !this._lastTouchData.scroll || this._lastTouchData && !this._lastTouchData.scroll && 250 < d || "click" === a) f.preventManipulation && f.preventManipulation(),
                  f.preventDefault && f.preventDefault()
            }
          }
        }; D.prototype._mouseEventHandler = function (f) {
          "undefined" === typeof f.target && f.srcElement && (f.target = f.srcElement); var h = Aa(f), m = f.type, n, a; f.which ? a = 3 == f.which : f.button && (a = 2 == f.button); D.capturedEventParam && (n = D.capturedEventParam, "mouseup" === m && (D.capturedEventParam = null, n.stockChart.overlaidCanvas.releaseCapture ? n.stockChart.overlaidCanvas.releaseCapture() : document.documentElement.removeEventListener("mouseup", n.stockChart._mouseEventHandler, !1)), n.hasOwnProperty(m) &&
            ("mouseup" !== m || n.stockChart.overlaidCanvas.releaseCapture ? f.target !== n.stockChart.overlaidCanvas && s || n[m].call(n.context, h.x, h.y) : f.target !== n.stockChart.overlaidCanvas && (n.stockChart.isDrag = !1))); if (this._ignoreNextEvent) this._ignoreNextEvent = !1; else if (f.preventManipulation && f.preventManipulation(), f.preventDefault && f.preventDefault(), Ma && window.console && (window.console.log(m + " --\x3e x: " + h.x + "; y:" + h.y), a && window.console.log(f.which), "mouseup" === m && window.console.log("mouseup")), !a) {
              if (!D.capturedEventParam &&
                this._events) {
                for (var d = 0; d < this._events.length; d++)if (this._events[d].hasOwnProperty(m)) if (n = this._events[d], a = n.bounds, h.x >= a.x1 && h.x <= a.x2 && h.y >= a.y1 && h.y <= a.y2) {
                  n[m].call(n.context, h.x, h.y); "mousedown" === m && !0 === n.capture ? (Chart.capturedEventParam = n, this.overlaidCanvas.setCapture ? this.overlaidCanvas.setCapture() : document.documentElement.addEventListener("mouseup", this._mouseEventHandler, !1)) : "mouseup" === m && (n.stockChart.overlaidCanvas.releaseCapture ? n.stockChart.overlaidCanvas.releaseCapture() :
                    document.documentElement.removeEventListener("mouseup", this._mouseEventHandler, !1)); break
                } else n = null; f.target.style.cursor = n && n.cursor ? n.cursor : this._defaultCursor
              } m = this.bounds; (h.x < m.x1 || h.x > m.x2 || h.y < m.y1 || h.y > m.y2) && this.resetOverlayedCanvas(); !this.isDrag && this._eventManager && this._eventManager.mouseEventHandler(f)
            }
        }; D.prototype.resetOverlayedCanvas = function () { this.overlaidCanvasCtx.clearRect(0, 0, this.width, this.height) }; D.prototype.clearCanvas = nb; D.prototype.getAutoFontSize = ob; V(G, Ia); V(N,
          Na); Ka.prototype.alignVerticalAxes = function () {
            if (!this.isNavigator && this.stockChart) {
              for (var f = this.sessionVariables.plotAreaBounds, h = this.stockChart._chartsPlotAreaX1 - f.x1, f = f.x2 - this.stockChart._chartsPlotAreaX2, m = 0; m < this.axisX.length; m++)this.axisX[m].lineCoordinates.x1 += h, this.axisX[m].lineCoordinates.x2 -= f, this.axisX[m].lineCoordinates.width = this.axisX[m].lineCoordinates.x2 - this.axisX[m].lineCoordinates.x1, this.axisX[m].bounds.x1 += h, this.axisX[m].bounds.x2 -= f, this.axisX[m].calculateValueToPixelConversionParameters();
              for (m = 0; m < this.axisX2.length; m++)this.axisX2[m].lineCoordinates.x1 += h, this.axisX2[m].lineCoordinates.x2 -= f, this.axisX2[m].lineCoordinates.width = this.axisX2[m].lineCoordinates.x2 - this.axisX2[m].lineCoordinates.x1, this.axisX2[m].bounds.x1 += h, this.axisX2[m].bounds.x2 -= f, this.axisX2[m].calculateValueToPixelConversionParameters(); for (m = 0; m < this.axisY.length; m++)this.axisY[m].lineCoordinates.x1 += h, this.axisY[m].lineCoordinates.x2 += h, this.axisY[m].bounds.x1 += h, this.axisY[m].bounds.x2 += h; for (m = 0; m < this.axisY2.length; m++)this.axisY2[m].lineCoordinates.x1 -=
                f, this.axisY2[m].lineCoordinates.x2 -= f, this.axisY2[m].bounds.x1 -= f, this.axisY2[m].bounds.x2 -= f
            }
          }; Ka.prototype.syncCharts = function (f, m) { this.stockChart && (f = h(f) ? this.stockChart._axisXMin : f, m = h(m) ? this.stockChart._axisXMax : m, this.stockChart._syncCharts(f, m), this.stockChart.sessionVariables._axisXMin = f, this.stockChart.sessionVariables._axisXMax = m, this.stockChart.rangeSelector && "zoom" !== this._zoomButton.getAttribute("state") && this.stockChart.rangeSelector.resetRangeButtons()) }; H.prototype.reset = function () {
            this.lastObjectId =
              0; this.objectMap = []; this.rectangularRegionEventSubscriptions = []; this.eventObjects = []; s && (this.ghostCtx.clearRect(0, 0, this.stockChart.width, this.stockChart.height), this.ghostCtx.beginPath())
          }; H.prototype.getNewObjectTrackingId = function () { return ++this.lastObjectId }; H.prototype.mouseEventHandler = function (f) {
            if ("mousemove" === f.type || "click" === f.type) {
              var h = [], m = Aa(f), n = null; if ((n = this.stockChart.getObjectAtXY(m.x, m.y, !1)) && "undefined" !== typeof this.objectMap[n]) if (n = this.objectMap[n], "rangeButton" ===
                n.objectType) { var a = this.stockChart.rangeSelector.buttons[n.rangeButtonIndex]; n.eventParameter = { x: m.x, y: m.y, rangeButton: a, rangeButtonIndex: n.rangeButtonIndex, stockChart: this.stockChart }; n.eventContext = { context: this.stockChart.rangeSelector, userContext: a, mouseover: "mouseover", mousemove: "mousemove", mouseout: "mouseout", click: "click" }; h.push(n) } else "inputFields" === n.objectType && (a = this.stockChart.rangeSelector.inputFields._textBlocks[n.inputFieldIndex], n.eventParameter = {
                  x: m.x, y: m.y, inputField: a, inputFieldIndex: n.inputFieldIndex,
                  stockChart: this.stockChart
                }, n.eventContext = { context: this.stockChart.rangeSelector, userContext: a, mouseover: "mouseover", mousemove: "mousemove", mouseout: "mouseout", click: "click" }, h.push(n)); a = []; for (m = 0; m < this.mouseoveredObjectMaps.length; m++) { for (var d = !0, n = 0; n < h.length; n++)if (h[n].id === this.mouseoveredObjectMaps[m].id) { d = !1; break } d ? this.fireEvent(this.mouseoveredObjectMaps[m], "mouseout", f) : a.push(this.mouseoveredObjectMaps[m]) } this.mouseoveredObjectMaps = a; for (m = 0; m < h.length; m++) {
                  a = !1; for (n = 0; n < this.mouseoveredObjectMaps.length; n++)if (h[m].id ===
                    this.mouseoveredObjectMaps[n].id) { a = !0; break } a || (this.fireEvent(h[m], "mouseover", f), this.mouseoveredObjectMaps.push(h[m])); "click" === f.type ? this.fireEvent(h[m], "click", f) : "mousemove" === f.type && this.fireEvent(h[m], "mousemove", f)
                }
            }
          }; H.prototype.fireEvent = function (f, h, m) {
            if (f && h) {
              var n = f.eventParameter, a = f.eventContext, d = f.eventContext.userContext; d && (a && d[a[h]]) && d[a[h]].call(d, n); "mouseout" !== h ? d.cursor && d.cursor !== m.target.style.cursor && (m.target.style.cursor = d.cursor) : (m.target.style.cursor = this.stockChart._defaultCursor,
                delete f.eventParameter, delete f.eventContext)
            }
          }; V(B, K); B.prototype._updateOptions = function () {
            this.updateOption("enabled"); this.updateOption("backgroundColor"); this.options.backgroundColor || (this.backgroundColor = this.stockChart.backgroundColor); this.updateOption("animationEnabled"); this.animationEnabled = this.animationEnabled && s; this.updateOption("animationDuration"); this.updateOption("theme"); this.updateOption("verticalAlign"); this.updateOption("horizontalAlign"); this.updateOption("width"); this.updateOption("height");
            this.updateOption("dynamicUpdate")
          }; B.prototype._initialize = function () {
            this._updateOptions(); var f; this.enabled && !this.panel && (this.panel = m("canvasjs-navigator-panel"), (f = !h(this.panel) && this.stockChart._canvasJSContainer.contains(this.panel)) || this.stockChart._canvasJSContainer.appendChild(this.panel)); f = !h(this.panel) && this.stockChart._canvasJSContainer.contains(this.panel); if (this.enabled) {
              this.height = this.options.height ? parseInt(this.options.height) : 0.14 * this.stockChart.height; f || this.stockChart._canvasJSContainer.appendChild(this.panel);
              var n = this.stockChart.layoutManager.getFreeSpace(), v = n.x1, s = n.y1; this.width = this.options.width ? this.width : n.width; "top" === this.verticalAlign ? (s = n.y1 + 2, f = "top") : (s = n.y2 - this.height - 2, f = "bottom"); "left" === this.horizontalAlign ? v = n.x1 + 2 : "center" === this.horizontalAlign ? v = n.x1 + n.width / 2 - this.width / 2 : "right" === this.horizontalAlign && (v = n.x2 - 2 - this.width); this.panel.style.top = s + "px"; this.panel.style.left = v + "px"; this.panel.style.height = this.height + "px"; this.panel.style.width = this.width + "px"; this.stockChart.layoutManager.registerSpace(f,
                { width: this.width, height: this.height + 2 }); this.bounds = { x1: v, y1: s, x2: v + this.width, y2: s + this.height }
            } else f && this.stockChart._canvasJSContainer.removeChild(this.panel)
          }; B.prototype._updateSlider = function (f, m) {
            var n = this.chart.axisX && this.chart.axisX.length ? this.chart.axisX[0] : this.chart.axisX2[0]; if (!h(n)) {
              var s = Math.max(n.bounds.x1, n.convertValueToPixel(n.reversed ? Math.max(f, Math.min(n.maximum, m)) : Math.min(f, Math.min(n.maximum, m)))), a = n.convertValueToPixel(n.reversed ? Math.min(f, Math.min(n.maximum, m)) :
                Math.max(f, Math.min(n.maximum, m))); this.slider.panel.style.left = s + "px"; this.slider.left = s; this.slider.panel.style.width = a - s + "px"; this.slider.width = a - s; this.slider.minimum = f; this.slider.maximum = m; this.chart.resetOverlayedCanvas(); this.slider.maskInverted ? X(this.chart.overlaidCanvasCtx, s, 0, a, this.height, this.slider.maskColor, 0, this.slider.outlineColor, 0, 0, 0, 0, this.slider.maskOpacity) : (X(this.chart.overlaidCanvasCtx, n.bounds.x1, 0, s, this.height, this.slider.maskColor, 0, this.slider.outlineColor, !1, !1, !1,
                  !1, this.slider.maskOpacity), X(this.chart.overlaidCanvasCtx, a, 0, this.width, this.height, this.slider.maskColor, 0, this.slider.outlineColor, !1, !1, !1, !1, this.slider.maskOpacity)); this.chart.overlaidCanvasCtx.lineWidth = this.slider.outlineThickness; this.chart.overlaidCanvasCtx.strokeStyle = this.slider.outlineColor; this.chart.overlaidCanvasCtx.save(); this.chart.overlaidCanvasCtx.beginPath(); 0 < this.slider.outlineThickness && (this.slider.outlineInverted ? (this.chart.overlaidCanvasCtx.moveTo(n.bounds.x1, this.height -
                    this.slider.outlineThickness / 2), this.chart.overlaidCanvasCtx.lineTo(1 === this.slider.outlineThickness % 2 ? (s - this.slider.outlineThickness / 2 << 0) + 0.5 : s, this.height - this.slider.outlineThickness / 2), this.chart.overlaidCanvasCtx.lineTo(1 === this.slider.outlineThickness % 2 ? (s - this.slider.outlineThickness / 2 << 0) + 0.5 : s, this.slider.outlineThickness / 2), this.chart.overlaidCanvasCtx.lineTo(1 === this.slider.outlineThickness % 2 ? (a - this.slider.outlineThickness / 2 << 0) + 0.5 : a, this.slider.outlineThickness / 2), this.chart.overlaidCanvasCtx.lineTo(1 ===
                      this.slider.outlineThickness % 2 ? (a - this.slider.outlineThickness / 2 << 0) + 0.5 : a, this.height - this.slider.outlineThickness / 2), this.chart.overlaidCanvasCtx.lineTo(this.width, this.height - this.slider.outlineThickness)) : (this.chart.overlaidCanvasCtx.moveTo(n.bounds.x1, this.slider.outlineThickness / 2), this.chart.overlaidCanvasCtx.lineTo(1 === this.slider.outlineThickness % 2 ? (s - this.slider.outlineThickness / 2 << 0) + 0.5 : s, this.slider.outlineThickness / 2), this.chart.overlaidCanvasCtx.lineTo(1 === this.slider.outlineThickness %
                        2 ? (s - this.slider.outlineThickness / 2 << 0) + 0.5 : s, this.height - this.slider.outlineThickness / 2), this.chart.overlaidCanvasCtx.lineTo(1 === this.slider.outlineThickness % 2 ? (a - this.slider.outlineThickness / 2 << 0) + 0.5 : a, this.height - this.slider.outlineThickness / 2), this.chart.overlaidCanvasCtx.lineTo(1 === this.slider.outlineThickness % 2 ? (a - this.slider.outlineThickness / 2 << 0) + 0.5 : a, this.slider.outlineThickness / 2), this.chart.overlaidCanvasCtx.lineTo(this.width, this.slider.outlineThickness / 2))); this.chart.overlaidCanvasCtx.stroke();
              this.chart.overlaidCanvasCtx.restore(); X(this.chart.overlaidCanvasCtx, 1 === this.slider.handleBorderThickness % 2 ? s - this.slider.handleWidth / 2 << 0.5 : s - this.slider.handleWidth / 2 << 0, 1 === this.slider.handleBorderThickness % 2 ? this.height / 2 - this.slider.handleHeight / 2 << 0.5 : this.height / 2 - this.slider.handleHeight / 2 << 0, 1 === this.slider.handleBorderThickness % 2 ? s + this.slider.handleWidth / 2 << 0.5 : s + this.slider.handleWidth / 2 << 0, 1 === this.slider.handleBorderThickness % 2 ? this.height / 2 + this.slider.handleHeight / 2 << 0.5 : this.height /
                2 + this.slider.handleHeight / 2 << 0, this.slider.handleColor, this.slider.handleBorderThickness, this.slider.handleBorderColor, !1, !1, !1, !1, 1); X(this.chart.overlaidCanvasCtx, 1 === this.slider.handleBorderThickness % 2 ? a - this.slider.handleWidth / 2 << 0.5 : a - this.slider.handleWidth / 2 << 0, 1 === this.slider.handleBorderThickness % 2 ? this.height / 2 - this.slider.handleHeight / 2 << 0.5 : this.height / 2 - this.slider.handleHeight / 2 << 0, 1 === this.slider.handleBorderThickness % 2 ? a + this.slider.handleWidth / 2 << 0.5 : a + this.slider.handleWidth / 2 <<
                  0, 1 === this.slider.handleBorderThickness % 2 ? this.height / 2 + this.slider.handleHeight / 2 << 0.5 : this.height / 2 + this.slider.handleHeight / 2 << 0, this.slider.handleColor, this.slider.handleBorderThickness, this.slider.handleBorderColor, !1, !1, !1, !1, 1); this.chart.overlaidCanvasCtx.lineWidth = this.slider.handleBorderThickness; this.chart.overlaidCanvasCtx.strokeStyle = this.slider.handleBorderColor; this.chart.overlaidCanvasCtx.save(); this.chart.overlaidCanvasCtx.beginPath(); this.chart.overlaidCanvasCtx.moveTo((1 === this.slider.handleBorderThickness %
                    2 ? (s - this.slider.handleBorderThickness / 2 << 0) + 0.5 : s) - Math.round(this.slider.handleBorderThickness), this.height / 2 - this.slider.handleHeight / 4); this.chart.overlaidCanvasCtx.lineTo((1 === this.slider.handleBorderThickness % 2 ? (s - this.slider.handleBorderThickness / 2 << 0) + 0.5 : s) - Math.round(this.slider.handleBorderThickness), this.height / 2 + this.slider.handleHeight / 4); this.chart.overlaidCanvasCtx.moveTo((1 === this.slider.handleBorderThickness % 2 ? (s + this.slider.handleBorderThickness / 2 << 0) + 0.5 : s) + Math.round(this.slider.handleBorderThickness),
                      this.height / 2 - this.slider.handleHeight / 4); this.chart.overlaidCanvasCtx.lineTo((1 === this.slider.handleBorderThickness % 2 ? (s + this.slider.handleBorderThickness / 2 << 0) + 0.5 : s) + Math.round(this.slider.handleBorderThickness), this.height / 2 + this.slider.handleHeight / 4); this.chart.overlaidCanvasCtx.moveTo((1 === this.slider.handleBorderThickness % 2 ? (a - this.slider.handleBorderThickness / 2 << 0) + 0.5 : a) - Math.round(this.slider.handleBorderThickness), this.height / 2 - this.slider.handleHeight / 4); this.chart.overlaidCanvasCtx.lineTo((1 ===
                        this.slider.handleBorderThickness % 2 ? (a - this.slider.handleBorderThickness / 2 << 0) + 0.5 : a) - Math.round(this.slider.handleBorderThickness), this.height / 2 + this.slider.handleHeight / 4); this.chart.overlaidCanvasCtx.moveTo((1 === this.slider.handleBorderThickness % 2 ? (a + this.slider.handleBorderThickness / 2 << 0) + 0.5 : a) + Math.round(this.slider.handleBorderThickness), this.height / 2 - this.slider.handleHeight / 4); this.chart.overlaidCanvasCtx.lineTo((1 === this.slider.handleBorderThickness % 2 ? (a + this.slider.handleBorderThickness /
                          2 << 0) + 0.5 : a) + Math.round(this.slider.handleBorderThickness), this.height / 2 + this.slider.handleHeight / 4); this.chart.overlaidCanvasCtx.stroke(); this.chart.overlaidCanvasCtx.restore()
            }
          }; V(Q, K); Q.prototype._updateOptions = function () {
            this.updateOption("maskColor"); this.updateOption("maskInverted"); this.updateOption("maskOpacity"); this.updateOption("handleColor"); this.updateOption("handleBorderColor"); this.updateOption("handleBorderThickness"); this.updateOption("handleWidth"); this.updateOption("handleHeight");
            this.updateOption("outlineColor"); this.updateOption("outlineThickness"); this.updateOption("outlineInverted"); this.updateOption("minimum"); this.updateOption("maximum")
          }; Q.prototype._attachEvents = function () {
            var f = this; y(this.panel, "mousedown", function (h) {
              f.stockChart.isDrag = !0; h.target !== f.leftHandle && h.target !== f.rightHandle && (f.stockChart.navigatorClicked = !0, f.currentHandle = f.leftHandle, f.panMode = !0, f.startPosition = Aa(h), h.target === f.currentHandle ? f.startPosition.x += f.currentHandle.offsetLeft + f.currentHandle.clientWidth /
                2 + f.panel.offsetLeft : h.target === f.panel && (f.startPosition.x += f.panel.offsetLeft), f.startWidth = f.panel.clientWidth, f.startLeft = f.panel.offsetLeft)
            }, this.stockChart.allDOMEventHandlers); y(this.panel, window.navigator.msPointerEnabled ? "MSPointerDown" : "touchstart", function (h) { f.stockChart._touchEventHandler(h) }, this.stockChart.allDOMEventHandlers); y(this.navigator.panel, "mousedown", function (h) {
              if (h.target !== f.navigator.slider.panel && h.target !== f.leftHandle && h.target !== f.rightHandle) {
                f.stockChart.navigatorClicked =
                  !0; var m = Aa(h), n, a; n = 0; var d = f.navigator.chart.axisX && f.navigator.chart.axisX.length ? f.navigator.chart.axisX[0] : f.navigator.chart.axisX2[0]; h = f.navigator.slider.left; n = h + f.navigator.slider.width; a = m.x - (h + n) / 2; if (m.x < h || m.x > n) {
                    var m = Math.max(0, h + a), b = Math.min(n + a, f.navigator.width); n + a > f.navigator.width && (n = n + a - f.navigator.width, m -= n); 0 > h + a && (n = Math.abs(h + a), b += n); f.stockChart._rangeEventParameter = { stockChart: f.stockChart, source: "navigator", index: null, minimum: d.convertPixelToValue(m), maximum: d.convertPixelToValue(b) };
                    f.stockChart.sessionVariables._axisXMin = d.convertPixelToValue(m); f.stockChart.sessionVariables._axisXMax = d.convertPixelToValue(b); f.navigator.dynamicUpdate ? (f.stockChart._rangeEventParameter.type = "rangeChanging", f.stockChart.dispatchEvent("rangeChanging", f.stockChart._rangeEventParameter, f.stockChart), f.stockChart._syncCharts(d.convertPixelToValue(m), d.convertPixelToValue(b)), f.stockChart._rangeEventParameter.type = "rangeChanged", f.stockChart.dispatchEvent("rangeChanged", f.stockChart._rangeEventParameter,
                      f.stockChart)) : f.navigator._updateSlider(f.stockChart.sessionVariables._axisXMin, f.stockChart.sessionVariables._axisXMax)
                  }
              }
            }, this.navigator.stockChart.allDOMEventHandlers); y(this.navigator.panel, window.navigator.msPointerEnabled ? "MSPointerDown" : "touchstart", function (h) { f.stockChart._touchEventHandler(h) }, this.navigator.stockChart.allDOMEventHandlers); y(this.navigator.stockChart.container, "mousemove", function (m) {
              var n = f.navigator.chart.axisX && f.navigator.chart.axisX.length ? f.navigator.chart.axisX[0] :
                f.navigator.chart.axisX2[0]; if (!h(f.currentHandle) && f.startPosition) {
                  f.navigator.chart.overlaidCanvas.style.cursor = f.navigator.chart.container.style.cursor = f.navigator.panel.style.cursor = "ew-resize"; var s; s = f.currentHandle === f.leftHandle ? 1 : -1; var a = Aa(m); m = m.target || m.srcElement; a.x = m === f.currentHandle ? a.x + (f.currentHandle.offsetLeft + f.currentHandle.clientWidth / 2 + f.panel.offsetLeft) : m === f.mask || m === f.panel ? a.x + f.panel.offsetLeft : m === f.rightHandle && f.currentHandle === f.leftHandle ? a.x + (f.rightHandle.offsetLeft +
                    f.rightHandle.clientWidth / 2 + f.panel.offsetLeft) : m === f.leftHandle && f.currentHandle === f.rightHandle ? a.x + f.panel.offsetLeft : a.x + ("canvasjs-chart-toolbar" === m.parentElement.className ? m.offsetParent.offsetLeft + m.offsetLeft - f.stockChart._chartsPlotAreaX1 : m.parentElement.parentElement.parentElement === f.navigator.panel ? m.offsetLeft : m.offsetLeft - f.stockChart._chartsPlotAreaX1); var d = a.x - f.startPosition.x; if (0 !== d) {
                      m = f.panel.offsetLeft; var b = f.panel.clientWidth; 0 < s && (m = Math.max(f.startLeft + s * d, f._left)); f.panMode ||
                        (b = Math.min(f.startWidth - s * d, f.fullWidth), s * d > f.startWidth ? (m = 0 < s ? f.startLeft + f.startWidth : Math.max(a.x, f._left), b = (0 < s ? a.x : f.startLeft) - parseFloat(m)) : 0 > s && (m = f.startLeft)); m + b <= f._left + f.fullWidth && (0 < s && (f.left = m, f.panel.style.left = f.left + "px"), f.panMode || (f.panel.style.width = f.width = b + "px"), h(n) || (s = n.convertPixelToValue(Math.max(n.bounds.x1, parseFloat(m))), n = n.convertPixelToValue(parseFloat(m) + parseFloat(b)), f.stockChart.sessionVariables._axisXMin = s, f.stockChart.sessionVariables._axisXMax = n,
                          f.stockChart.rangeSelector && !f.panMode && f.stockChart.rangeSelector.resetRangeButtons(), f.stockChart._rangeEventParameter = { stockChart: f.stockChart, source: "navigator", index: null, minimum: s, maximum: n }, f.navigator.dynamicUpdate ? (f.stockChart._rangeEventParameter.type = "rangeChanging", f.stockChart.dispatchEvent("rangeChanging", f.stockChart._rangeEventParameter, f.stockChart), f.stockChart._syncCharts(s, n), f.stockChart._rangeEventParameter.type = "rangeChanged", f.stockChart.dispatchEvent("rangeChanged", f.stockChart._rangeEventParameter,
                            f.stockChart)) : f.navigator._updateSlider(f.stockChart.sessionVariables._axisXMin, f.stockChart.sessionVariables._axisXMax)))
                    }
                } else f.navigator.chart.overlaidCanvas.style.cursor = f.navigator.chart.container.style.cursor = f.navigator.panel.style.cursor = "auto"
            }, this.navigator.stockChart.allDOMEventHandlers); y(this.navigator.stockChart.container, window.navigator.msPointerEnabled ? "MSPointerMove" : "touchmove", function (h) { f.stockChart._touchEventHandler(h) }, this.navigator.stockChart.allDOMEventHandlers)
          }; Q.prototype._initialize =
            function () {
              var f = this, h; this._updateOptions(); Y && (this.eventsAttached || (this._attachEvents(), this.eventsAttached = !0), this.handleWidth = this.options.handleWidth ? this.handleWidth : 8, this.handleHeight = this.options.handleHeight ? Math.min(this.navigator.height, this.options.handleHeight) : 0.25 * this.navigator.height, this.leftHandle || (this.leftHandle = n("button", "canvasjs-slider-handle", "button"), this.leftHandle.innerHTML = "||", this.leftHandle.style.cssText = "height: " + this.navigator.height + "px; width: " + this.handleWidth +
                "px; position:absolute; left: -" + this.handleWidth / 2 + "px; top: 0; cursor:ew-resize;border-style: solid; border-width:" + this.handleBorderThickness + "px; border-color: transparent; outline:none; padding:0px; background-color: transparent; color: transparent;font-size:12px;font-family:Arial;-moz-user-select: none;-webkit-user-select: none;-ms-user-select: none;user-select: none; opacity: 0;", this.panel.appendChild(this.leftHandle), this.initHandle(this.leftHandle, 1)), this.rightHandle || (this.rightHandle =
                  n("button", "canvasjs-slider-handle", "button"), this.rightHandle.innerHTML = "||", this.rightHandle.style.cssText = "height: " + this.navigator.height + "px; width: " + this.handleWidth + "px; position:absolute; right: -" + this.handleWidth / 2 + "px; top: 0; cursor:ew-resize;border-style: solid; border-width:" + this.handleBorderThickness + "px; border-color: transparent; outline:none; padding:0px; background-color: transparent; color: transparent;font-size:12px;font-family:Arial;-moz-user-select: none;-webkit-user-select: none;-ms-user-select: none;user-select: none; opacity: 0;",
                  this.panel.appendChild(this.rightHandle), this.initHandle(this.rightHandle, -1)), this.panel.style.cssText = "height: " + this.navigator.height + "px; width: 100%; position: absolute; cursor: move;", this.fullWidth = this.panel.clientWidth, this._left = this.panel.offsetLeft, y(document, "mousedown", function (h) {
                    if (f.stockChart.rangeSelector && f.stockChart.rangeSelector.inputFields && f.stockChart.rangeSelector.inputFields.enabled) for (var m = 0; m < f.stockChart.rangeSelector.inputFields.elements.length; m++)h.target != f.stockChart.rangeSelector.inputFields.elements[m] &&
                      f.stockChart.rangeSelector.inputFields.elements[m].focused && f.stockChart.rangeSelector.inputFields.elements[m].blur()
                  }, this.navigator.stockChart.allDOMEventHandlers), y(document, window.navigator.msPointerEnabled ? "MSPointerDown" : "touchstart", function (f) {
                    a: {
                      var h = f.changedTouches, h = h ? h[0] : f, a = ""; switch (f.type) { case "touchstart": case "MSPointerDown": a = "mousedown"; break; case "touchmove": case "MSPointerMove": a = "mousemove"; break; case "touchend": case "MSPointerUp": a = "mouseup"; break; default: break a }var d =
                        document.createEvent("MouseEvent"); d.initMouseEvent(a, !0, !0, window, 1, h.screenX, h.screenY, h.clientX, h.clientY, !1, !1, !1, !1, 0, null); h.target.dispatchEvent(d); f.preventManipulation && f.preventManipulation(); f.preventDefault && f.preventDefault()
                    }
                  }, this.navigator.stockChart.allDOMEventHandlers), y(document, "mouseup", function (m) {
                    f.panMode = !1; f.navigator.stockChart.isDrag = !1; if (f.stockChart.navigatorClicked) {
                      m = Math.min(f.stockChart.sessionVariables._axisXMin, f.stockChart.sessionVariables._axisXMax); var n = Math.max(f.stockChart.sessionVariables._axisXMin,
                        f.stockChart.sessionVariables._axisXMax); f.stockChart._rangeEventParameter.type = "rangeChanging"; f.stockChart.dispatchEvent("rangeChanging", f.stockChart._rangeEventParameter, f.stockChart); for (var a = 0; a < f.stockChart.charts.length; a++) { h = f.stockChart.charts[a]; h.toolTip && h.toolTip.enabled && h.toolTip.hide(); for (var d = 0; d < h.axisX.length; d++)h.axisX[d].setViewPortRange(m, n); for (d = 0; d < h.axisX2.length; d++)h.axisX2[d].setViewPortRange(m, n); h.render() } f.stockChart.rangeSelector && (f.stockChart.rangeSelector.enabled &&
                          f.stockChart.rangeSelector.inputFields && f.stockChart.rangeSelector.inputFields.enabled) && f.stockChart.rangeSelector._updateInputFields(m, n); f.stockChart._rangeEventParameter.type = "rangeChanged"; f.stockChart.dispatchEvent("rangeChanged", f.stockChart._rangeEventParameter, f.stockChart); f.currentHandle = f.startPosition = f.startWidth = f.startLeft = null
                    } f.stockChart.navigatorClicked = null
                  }, this.navigator.stockChart.allDOMEventHandlers), y(document, window.navigator.msPointerEnabled ? "MSPointerUp" : "touchend", function (m) {
                    f.panMode =
                      !1; f.navigator.stockChart.isDrag = !1; if (f.stockChart.navigatorClicked) {
                        m = Math.min(f.stockChart.sessionVariables._axisXMin, f.stockChart.sessionVariables._axisXMax); var n = Math.max(f.stockChart.sessionVariables._axisXMin, f.stockChart.sessionVariables._axisXMax); f.stockChart._rangeEventParameter.type = "rangeChanging"; f.stockChart.dispatchEvent("rangeChanging", f.stockChart._rangeEventParameter, f.stockChart); for (var a = 0; a < f.stockChart.charts.length; a++) {
                          h = f.stockChart.charts[a]; h.toolTip && h.toolTip.enabled &&
                            h.toolTip.hide(); for (var d = 0; d < h.axisX.length; d++)h.axisX[d].setViewPortRange(m, n); for (d = 0; d < h.axisX2.length; d++)h.axisX2[d].setViewPortRange(m, n); h.render()
                        } f.stockChart.rangeSelector && (f.stockChart.rangeSelector.enabled && f.stockChart.rangeSelector.inputFields && f.stockChart.rangeSelector.inputFields.enabled) && f.stockChart.rangeSelector._updateInputFields(m, n); f.stockChart._rangeEventParameter.type = "rangeChanged"; f.stockChart.dispatchEvent("rangeChanged", f.stockChart._rangeEventParameter, f.stockChart);
                        f.currentHandle = f.startPosition = f.startWidth = f.startLeft = null
                      } f.stockChart.navigatorClicked = null
                  }, this.navigator.stockChart.allDOMEventHandlers))
            }; Q.prototype.initHandle = function (f, h) {
              var m = this; f && (y(f, "mousedown", function (f) {
                m.stockChart.navigatorClicked = !0; f.preventDefault(); m.currentHandle = this; m.startPosition = Aa(f); f.target === m.currentHandle ? m.startPosition.x += m.currentHandle.offsetLeft + m.currentHandle.clientWidth / 2 + m.panel.offsetLeft : f.target === m.panel && (m.startPosition.x += m.panel.offsetLeft);
                m.startWidth = m.panel.clientWidth; m.startLeft = m.panel.offsetLeft
              }, this.navigator.stockChart.allDOMEventHandlers), y(f, window.navigator.msPointerEnabled ? "MSPointerDown" : "touchstart", function (f) { m.stockChart._touchEventHandler(f) }, this.navigator.stockChart.allDOMEventHandlers))
            }; V(R, K); R.prototype._updateOptions = function () {
              this.updateOption("enabled"); this.updateOption("verticalAlign"); this.updateOption("horizontalAlign"); this.updateOption("width"); this.updateOption("height"); this.updateOption("label");
              this.updateOption("selectedRangeButtonIndex")
            }; R.prototype._initialize = function () {
              var f = 0; this._updateOptions(); this.buttons = []; if (Y && this.enabled) {
                if (this.options.buttons) for (var m = 0; m < this.options.buttons.length; m++)this.buttons.push(new M(this.stockChart, m, this.options.buttons[m])); else { for (m = 0; 6 > m; m++)this.buttons.push(new M(this.stockChart, m)); this.buttonLabels = "1m 3m 6m YTD 1y All".split(" ") } this._wrapElements = !1; var n = this.stockChart.layoutManager.getFreeSpace(), s = n.x1, m = n.y1; this.width = this.options.width ?
                  this.width : n.width; h(this.buttonStyle.options.labelFontSize) && (this.buttonStyle.labelFontSize = this.stockChart.getAutoFontSize(this.buttonStyle.labelFontSize)); this.rangeButtonsWidth = 0; this.buttonStyle.maxWidth = this.buttonStyle.options.maxWidth ? this.buttonStyle.options.maxWidth : this.stockChart.width / this.buttons.length; if (this.buttons && 0 < this.buttons.length) {
                    var a = new ja(this.ctx, {
                      x: 0, y: 0, backgroundColor: this.stockChart.backgroundColor, borderThickness: 0, cornerRadius: 0, maxWidth: 0.2 * this.stockChart.width,
                      maxHeight: 2 * this.buttonStyle.labelFontSize, angle: 0, padding: { left: 5, right: 5, top: 2, bottom: 2 }, text: h(this.stockChart.options.culture) || h(this.stockChart._cultureInfo.rangeSelector.rangeText) ? this.label : this.stockChart._cultureInfo.rangeSelector.rangeText, horizontalAlign: "left", fontSize: this.buttonStyle.labelFontSize, fontFamily: this.buttonStyle.labelFontFamily, fontWeight: this.buttonStyle.labelFontWeight, fontColor: this.buttonStyle.labelFontColor, fontStyle: this.buttonStyle.labelFontStyle, textBaseline: "middle"
                    });
                    this._label.textBlock = a
                  } for (m = 0; m < this.buttons.length; m++) {
                    var d = this.buttons[m]; d._index = m; a = new ja(this.ctx, {
                      x: 0, y: 0, backgroundColor: this.buttonStyle.backgroundColor, borderColor: this.buttonStyle.borderColor, borderThickness: this.buttonStyle.borderThickness, cornerRadius: 0, maxWidth: this.buttonStyle.options.width ? this.buttonStyle.width : this.buttonStyle.maxWidth, maxHeight: 2 * this.buttonStyle.labelFontSize, angle: 0, padding: this.buttonStyle.padding, text: this.options.buttons && this.options.buttons.length ?
                        h(d.label) ? "" : d.label : this.buttonLabels[m], horizontalAlign: "center", fontSize: this.buttonStyle.labelFontSize, fontFamily: this.buttonStyle.labelFontFamily, fontWeight: this.buttonStyle.labelFontWeight, fontColor: this.buttonStyle.labelFontColor, fontStyle: this.buttonStyle.labelFontStyle, textBaseline: "middle"
                    }); d.state = h(this.selectedRangeButtonIndex) || this.selectedRangeButtonIndex !== m ? "off" : "on"; d.textBlock = a; d.bounds = { x1: null, x2: null, y1: null, y2: null, width: null, height: null }; a.measureText(); this.rangeButtonsWidth +=
                      a.width + this.buttonStyle.spacing; this.rangeButtonsHeight = a.height; f = f < a.height ? a.height : f; d = this.buttons[m]; d.id = ++this.stockChart._eventManager.lastObjectId; this.stockChart._eventManager.objectMap[d.id] = { id: d.id, objectType: "rangeButton", rangeButtonIndex: m }
                  } this.height < this.inputFieldsHeight + 2 * this.inputFields.style.borderThickness && (this.height = this.inputFieldsHeight + 2 * this.inputFields.style.borderThickness); this.height < f + 2 * this.buttonStyle.borderThickness + 5 && (this.height = f + 2 * this.buttonStyle.borderThickness +
                    5); this.rangeButtonsWidth + this._label.textBlock.measureText().width + this.inputFieldsWidth >= this.stockChart.width && (this.height = this.options.height ? this.height : 2 * this.height, this._wrapElements = !0); "bottom" === this.verticalAlign ? (m = n.y2 - this.height - 2, f = "bottom") : (m = n.y1 + 2, f = "top"); "left" === this.horizontalAlign ? s = n.x1 + 2 : "center" === this.horizontalAlign ? s = n.x1 + n.width / 2 - this.width / 2 : "right" === this.horizontalAlign && (s = n.x2 - 2 - this.width); this.stockChart.layoutManager.registerSpace(f, { width: this.width, height: this.height });
                this.bounds = { x1: s, y1: m, x2: s + this.width, y2: m + this.height, width: this.width, height: this.height }; for (m = 0; m < this.buttons.length; m++)this.buttons[m]._initialize(m)
              }
            }; R.prototype.render = function () {
              var f; this.setButtonsLayout(); X(this.ctx, this.bounds.x1, this.bounds.y1, this.bounds.x2, this.bounds.y2, this.stockChart.backgroundColor, 0, null, 0, 0, 0, 0, 1); this._label && this._label.textBlock && this._label.textBlock.render(!0); for (f = 0; f < this.buttons.length; f++)this.buttons[f].enabled || (this.buttons[f].textBlock.backgroundColor =
                this.buttons[f].backgroundColorDisabled, this.buttons[f].textBlock.borderColor = this.buttons[f].backgroundColorDisabled), this.buttons[f].render(!0); this.inputFields && this.inputFields.enabled && this.renderInputFields(!0)
            }; R.prototype.setButtonsLayout = function () {
              var f, h, m = this.bounds.x1 + 5, n; this._label && (this._label.textBlock && 0 < this.buttons.length) && (this._label.textBlock.x = m, this._label.textBlock.y = this.bounds.y1 + this.buttons[0].textBlock.fontSize / 2 + 2 * this.buttons[0].textBlock.borderThickness, this._label.bounds =
                { x1: m, y1: this.bounds.y1, x2: m + this._label.textBlock.measureText().width, y2: this.bounds.y1 + this._label.textBlock.measureText().height, width: this._label.textBlock.measureText().width, height: this._label.textBlock.measureText().height }, m += this._label.bounds.width); for (f = 0; f < this.buttons.length; f++)h = this.buttons[f], h.textBlock.width = h.textBlock.maxWidth = this.buttonStyle.width = this.buttonStyle.options.width ? this.buttonStyle.width : h.textBlock.width, n = m + h.textBlock.width, h.textBlock.x = h.bounds.x1 = 1 === h.textBlock.borderThickness %
                  2 ? (m << 0) + 0.5 : m, h.bounds.x2 = n, h.bounds.y1 = this.bounds.y1, h.textBlock.y = 1 === h.textBlock.borderThickness % 2 ? this.bounds.y1 + h.textBlock.fontSize / 2 + 2 * h.textBlock.borderThickness << 0.5 : this.bounds.y1 + h.textBlock.fontSize / 2 + 2 * h.textBlock.borderThickness, h.bounds.y2 = h.bounds.y1 + 1.5 * h.textBlock.fontSize, h.bounds.width = n - m, h.bounds.height = h.bounds.y2 - h.bounds.y1, m = n + this.buttonStyle.spacing, h.textBlock.maxWidth = this.buttonStyle.maxWidth
            }; R.prototype.resetRangeButtons = function () {
              for (var f = 0; f < this.buttons.length; f++)this.buttons[f].enabled &&
                (this.buttons[f].state = "off", this.buttons[f].textBlock.backgroundColor = this.buttonStyle.backgroundColor, this.buttons[f].textBlock.fontColor = this.buttonStyle.labelFontColor, this.buttons[f].textBlock.fontWeight = this.buttonStyle.labelFontWeight, this.buttons[f].textBlock.render(!0))
            }; R.prototype.renderInputFields = function () {
              this.inputFields._textBlocks[0].text = "dateTime" === this.inputFields.valueType ? ka(this.inputFields.startValue, this.inputFields.valueFormatString, this.stockChart._cultureInfo) : Z(this.inputFields.startValue,
                this.inputFields.valueFormatString, this.stockChart._cultureInfo); this.inputFields._textBlocks[1].text = "dateTime" === this.inputFields.valueType ? ka(this.inputFields.endValue, this.inputFields.valueFormatString, this.stockChart._cultureInfo) : Z(this.inputFields.endValue, this.inputFields.valueFormatString, this.stockChart._cultureInfo); this.inputFields._labels[0].text = h(this.stockChart._cultureInfo.rangeSelector.fromText) ? "From" : this.stockChart._cultureInfo.rangeSelector.fromText; this.inputFields._labels[1].text =
                  h(this.stockChart._cultureInfo.rangeSelector.toText) ? "To" : this.stockChart._cultureInfo.rangeSelector.toText; for (var f = 0, m = this.inputFields._textBlocks.length - 1; 0 <= m; m--) {
                    var n = this.inputFields._textBlocks[m], s = n.measureText(); n._width = this.inputFields.style.options.width ? this.inputFields.style.width : Math.abs(s.width - n._width) <= ("dateTime" === this.inputFields.valueType ? 10 : 5) ? n._width : s.width + 10; f += n._width + this.inputFields.style.spacing; this.inputFields.elements[m].style.width = n._width - this.inputFields.style.spacing -
                      2 * this.inputFields.style.borderThickness - 5 + "px"; n.x = n.bounds.x1 = 1 === n.borderThickness % 2 ? (this.bounds.x2 - f - (!this.stockChart.exportEnabled || this.stockChart.title && this.stockChart.title.text && "top" === this.stockChart.title.verticalAlign ? 0 : 40) << 0) + 0.5 : this.bounds.x2 - f - (!this.stockChart.exportEnabled || this.stockChart.title && this.stockChart.title.text && "top" === this.stockChart.title.verticalAlign ? 0 : 40); n.bounds.x2 = n.bounds.x1 + n._width; this.inputFields.elements[m].style.left = this.bounds.x2 - f - (!this.stockChart.exportEnabled ||
                        this.stockChart.title && this.stockChart.title.text && "top" === this.stockChart.title.verticalAlign ? 0 : 40) + this.inputFields.style.borderThickness + "px"; f += this.inputFields._labels[m].measureText().width; this.inputFields._labels[m].x = this.inputFields._labels[m].bounds.x1 = this.bounds.x2 - f - (!this.stockChart.exportEnabled || this.stockChart.title && this.stockChart.title.text && "top" === this.stockChart.title.verticalAlign ? 0 : 40); this.inputFields._labels[m].bounds.x2 = this.inputFields._labels[m].bounds.x1 + this.inputFields._labels[m].measureText().width;
                    n.width = n._width; n.y = 1 === n.borderThickness % 2 ? (this._wrapElements ? this.bounds.y1 + this.rangeButtonsHeight + 10 : this.bounds.y1) + n.fontSize / 2 + 2 * n.borderThickness << 0.5 : (this._wrapElements ? this.bounds.y1 + this.rangeButtonsHeight + 10 : this.bounds.y1) + n.fontSize / 2 + 2 * n.borderThickness; this.inputFields._labels[m].y = (this._wrapElements ? this.bounds.y1 + this.rangeButtonsHeight + 10 : this.bounds.y1) + n.fontSize / 2 + 2 * n.borderThickness; n.bounds.y1 = this.inputFields._labels[m].bounds.y1 = (this._wrapElements ? this.bounds.y1 + this.rangeButtonsHeight +
                      10 : this.bounds.y1) + 2 * n.borderThickness; n.bounds.y2 = this.inputFields._labels[m].bounds.y2 = n.bounds.y1 + s.height; this.inputFields.elements[m].style.top = (this._wrapElements ? this.bounds.y1 + this.rangeButtonsHeight + 10 : this.bounds.y1) + n.borderThickness + "px"; n.render(!0); this.inputFields._labels[m].render(!0)
                  }
            }; R.prototype._updateInputFields = function (f, h) {
              this.inputFields.elements[0].focused || (this.inputFields.elements[0].value = "dateTime" === this.inputFields.valueType ? ka(f, "YYYY-MM-DD") : Z(f, this.inputFields.valueFormatString));
              this.inputFields.elements[1].focused || (this.inputFields.elements[1].value = "dateTime" === this.inputFields.valueType ? ka(h, "YYYY-MM-DD") : Z(h, this.inputFields.valueFormatString)); for (var m = 0; m < this.inputFields.elements.length; m++)this.inputFields.elements[m].focused && this.inputFields.elements[m].focus(); this.inputFields.startValue = f; this.inputFields.endValue = h; this.render()
            }; V(M, K); M.prototype._updateOptions = function () { this.updateOption("style"); this.updateOption("label"); this.updateOption("range"); this.updateOption("rangeType") };
    M.prototype._initialize = function (f) { this._updateOptions(); var m = "1m 3m 6m YTD 1y All".split(" "), n = [1, 3, 6, null, 1, null], s = "month month month ytd year all".split(" "); this.range = "undefined" !== typeof this.options.range ? this.range : h(n[f]) ? null : n[f]; this.rangeType = "undefined" !== typeof this.options.rangeType ? this.rangeType : s[f]; this.label = this.textBlock.text = h(this.options.label) ? m[f] : this.label }; M.prototype.render = function () { this.textBlock.render(!0) }; V(T, K); T.prototype._updateOptions = function () {
      this.updateOption("enabled");
      this.updateOption("startValue"); this.updateOption("endValue"); this.updateOption("valueType"); this.updateOption("valueFormatString")
    }; T.prototype._initialize = function () {
      this._updateOptions(); h(this.style.options.fontSize) && (this.style.fontSize = this.stockChart.getAutoFontSize(this.style.fontSize)); if (this.enabled) {
        for (var f = 0; f < this.elements.length; f++)this.elements[f].style.position = "absolute", this.elements[f].style.display = this.elements[f].focused ? "inline" : "none", this.elements[f].style.backgroundColor =
          this.style.backgroundColor, this.elements[f].style.border = "none", this.elements[f].style.outline = "none", this.elements[f].style.outlineOffset = 0, this.elements[f].style.textAlign = "center", this.elements[f].style.color = this.style.fontColor, this.elements[f].style.fontSize = this.elements[f].style.height = this.style.fontSize + "px", this.elements[f].style.fontStyle = this.style.fontStyle, this.elements[f].style.fontFamily = this.style.fontFamily, this.elements[f].style.fontWeight = this.style.fontWeight, this.elements[f].style.lineHeight =
          1, isNaN(this.style.padding) ? (this.elements[f].style.paddingTop = this.style.padding.top + "px", this.elements[f].style.paddingRight = this.style.padding.right + "px", this.elements[f].style.paddingBottom = this.style.padding.bottom + "px", this.elements[f].style.paddingLeft = this.style.padding.left + "px") : this.elements[f].style.padding = this.style.padding + "px", this.elements[f].style.mozAppearance = this.elements[f].style.webkitAppearance = this.elements[f].style.appearance = "none", this.elements[f].style.webkitBorderRadius =
          0, this.elements[f].style.mozBorderRadius = 0, this.elements[f].style.borderRadius = 0, this.elements[f].style.boxSizing = "content-box"; this.parent = this.rangeSelector = this.stockChart.rangeSelector
      }
    }; V(U, K); U.prototype._updateOptions = function () {
      this.updateOption("backgroundColor"); this.updateOption("backgroundColorOnHover"); this.updateOption("backgroundColorOnSelect"); this.updateOption("borderColor"); this.updateOption("borderThickness"); this.updateOption("labelFontColor"); this.updateOption("labelFontColorOnHover");
      this.updateOption("labelFontSize"); this.updateOption("labelFontStyle"); this.updateOption("labelFontFamily"); this.updateOption("labelFontWeight"); this.updateOption("width"); this.updateOption("maxWidth"); this.updateOption("padding"); this.updateOption("spacing"); this.updateOption("cursor")
    }; V(W, K); W.prototype._updateOptions = function () {
      this.updateOption("backgroundColor"); this.updateOption("borderColor"); this.updateOption("borderThickness"); this.updateOption("borderColorOnFocus"); this.updateOption("fontColor");
      this.updateOption("fontSize"); this.updateOption("fontStyle"); this.updateOption("fontFamily"); this.updateOption("fontWeight"); this.updateOption("width"); this.updateOption("maxWidth"); this.updateOption("padding"); this.updateOption("spacing"); this.updateOption("cursor")
    }; return D
  }(); W.version = "v1.0.5 GA"; window.CanvasJS && (W && (!window.CanvasJS.StockChart && window.CanvasJS.Chart) && (window.CanvasJS.StockChart = W), W && !window.CanvasJS.Chart && (window.CanvasJS.Chart = Ka, window.CanvasJS.StockChart = W))
})();

/*
  excanvas is used to support IE678 which do not implement HTML5 Canvas Element. You can safely remove the following excanvas code if you don't need to support older browsers.

  Copyright 2006 Google Inc. https://code.google.com/p/explorercanvas/
  Licensed under the Apache License, Version 2.0
*/
document.createElement("canvas").getContext || function () {
  function V() { return this.context_ || (this.context_ = new C(this)) } function W(a, b, c) { var g = M.call(arguments, 2); return function () { return a.apply(b, g.concat(M.call(arguments))) } } function N(a) { return String(a).replace(/&/g, "&amp;").replace(/"/g, "&quot;") } function O(a) {
    a.namespaces.g_vml_ || a.namespaces.add("g_vml_", "urn:schemas-microsoft-com:vml", "#default#VML"); a.namespaces.g_o_ || a.namespaces.add("g_o_", "urn:schemas-microsoft-com:office:office", "#default#VML");
    a.styleSheets.ex_canvas_ || (a = a.createStyleSheet(), a.owningElement.id = "ex_canvas_", a.cssText = "canvas{display:inline-block;overflow:hidden;text-align:left;width:300px;height:150px}")
  } function X(a) {
    var b = a.srcElement; switch (a.propertyName) {
      case "width": b.getContext().clearRect(); b.style.width = b.attributes.width.nodeValue + "px"; b.firstChild.style.width = b.clientWidth + "px"; break; case "height": b.getContext().clearRect(), b.style.height = b.attributes.height.nodeValue + "px", b.firstChild.style.height = b.clientHeight +
        "px"
    }
  } function Y(a) { a = a.srcElement; a.firstChild && (a.firstChild.style.width = a.clientWidth + "px", a.firstChild.style.height = a.clientHeight + "px") } function D() { return [[1, 0, 0], [0, 1, 0], [0, 0, 1]] } function t(a, b) { for (var c = D(), g = 0; 3 > g; g++)for (var e = 0; 3 > e; e++) { for (var f = 0, d = 0; 3 > d; d++)f += a[g][d] * b[d][e]; c[g][e] = f } return c } function P(a, b) {
    b.fillStyle = a.fillStyle; b.lineCap = a.lineCap; b.lineJoin = a.lineJoin; b.lineWidth = a.lineWidth; b.miterLimit = a.miterLimit; b.shadowBlur = a.shadowBlur; b.shadowColor = a.shadowColor; b.shadowOffsetX =
      a.shadowOffsetX; b.shadowOffsetY = a.shadowOffsetY; b.strokeStyle = a.strokeStyle; b.globalAlpha = a.globalAlpha; b.font = a.font; b.textAlign = a.textAlign; b.textBaseline = a.textBaseline; b.arcScaleX_ = a.arcScaleX_; b.arcScaleY_ = a.arcScaleY_; b.lineScale_ = a.lineScale_
  } function Q(a) { var b = a.indexOf("(", 3), c = a.indexOf(")", b + 1), b = a.substring(b + 1, c).split(","); if (4 != b.length || "a" != a.charAt(3)) b[3] = 1; return b } function E(a, b, c) { return Math.min(c, Math.max(b, a)) } function F(a, b, c) {
    0 > c && c++; 1 < c && c--; return 1 > 6 * c ? a + 6 * (b - a) * c :
      1 > 2 * c ? b : 2 > 3 * c ? a + 6 * (b - a) * (2 / 3 - c) : a
  } function G(a) {
    if (a in H) return H[a]; var b, c = 1; a = String(a); if ("#" == a.charAt(0)) b = a; else if (/^rgb/.test(a)) { c = Q(a); b = "#"; for (var g, e = 0; 3 > e; e++)g = -1 != c[e].indexOf("%") ? Math.floor(255 * (parseFloat(c[e]) / 100)) : +c[e], b += v[E(g, 0, 255)]; c = +c[3] } else if (/^hsl/.test(a)) {
      e = c = Q(a); b = parseFloat(e[0]) / 360 % 360; 0 > b && b++; g = E(parseFloat(e[1]) / 100, 0, 1); e = E(parseFloat(e[2]) / 100, 0, 1); if (0 == g) g = e = b = e; else { var f = 0.5 > e ? e * (1 + g) : e + g - e * g, d = 2 * e - f; g = F(d, f, b + 1 / 3); e = F(d, f, b); b = F(d, f, b - 1 / 3) } b = "#" +
        v[Math.floor(255 * g)] + v[Math.floor(255 * e)] + v[Math.floor(255 * b)]; c = c[3]
    } else b = Z[a] || a; return H[a] = { color: b, alpha: c }
  } function C(a) {
    this.m_ = D(); this.mStack_ = []; this.aStack_ = []; this.currentPath_ = []; this.fillStyle = this.strokeStyle = "#000"; this.lineWidth = 1; this.lineJoin = "miter"; this.lineCap = "butt"; this.miterLimit = 1 * q; this.globalAlpha = 1; this.font = "10px sans-serif"; this.textAlign = "left"; this.textBaseline = "alphabetic"; this.canvas = a; var b = "width:" + a.clientWidth + "px;height:" + a.clientHeight + "px;overflow:hidden;position:absolute",
      c = a.ownerDocument.createElement("div"); c.style.cssText = b; a.appendChild(c); b = c.cloneNode(!1); b.style.backgroundColor = "red"; b.style.filter = "alpha(opacity=0)"; a.appendChild(b); this.element_ = c; this.lineScale_ = this.arcScaleY_ = this.arcScaleX_ = 1
  } function R(a, b, c, g) { a.currentPath_.push({ type: "bezierCurveTo", cp1x: b.x, cp1y: b.y, cp2x: c.x, cp2y: c.y, x: g.x, y: g.y }); a.currentX_ = g.x; a.currentY_ = g.y } function S(a, b) {
    var c = G(a.strokeStyle), g = c.color, c = c.alpha * a.globalAlpha, e = a.lineScale_ * a.lineWidth; 1 > e && (c *= e); b.push("<g_vml_:stroke",
      ' opacity="', c, '"', ' joinstyle="', a.lineJoin, '"', ' miterlimit="', a.miterLimit, '"', ' endcap="', $[a.lineCap] || "square", '"', ' weight="', e, 'px"', ' color="', g, '" />')
  } function T(a, b, c, g) {
    var e = a.fillStyle, f = a.arcScaleX_, d = a.arcScaleY_, k = g.x - c.x, n = g.y - c.y; if (e instanceof w) {
      var h = 0, l = g = 0, u = 0, m = 1; if ("gradient" == e.type_) { h = e.x1_ / f; c = e.y1_ / d; var p = s(a, e.x0_ / f, e.y0_ / d), h = s(a, h, c), h = 180 * Math.atan2(h.x - p.x, h.y - p.y) / Math.PI; 0 > h && (h += 360); 1E-6 > h && (h = 0) } else p = s(a, e.x0_, e.y0_), g = (p.x - c.x) / k, l = (p.y - c.y) / n, k /= f * q,
        n /= d * q, m = x.max(k, n), u = 2 * e.r0_ / m, m = 2 * e.r1_ / m - u; f = e.colors_; f.sort(function (a, b) { return a.offset - b.offset }); d = f.length; p = f[0].color; c = f[d - 1].color; k = f[0].alpha * a.globalAlpha; a = f[d - 1].alpha * a.globalAlpha; for (var n = [], r = 0; r < d; r++) { var t = f[r]; n.push(t.offset * m + u + " " + t.color) } b.push('<g_vml_:fill type="', e.type_, '"', ' method="none" focus="100%"', ' color="', p, '"', ' color2="', c, '"', ' colors="', n.join(","), '"', ' opacity="', a, '"', ' g_o_:opacity2="', k, '"', ' angle="', h, '"', ' focusposition="', g, ",", l, '" />')
    } else e instanceof
      I ? k && n && b.push("<g_vml_:fill", ' position="', -c.x / k * f * f, ",", -c.y / n * d * d, '"', ' type="tile"', ' src="', e.src_, '" />') : (e = G(a.fillStyle), b.push('<g_vml_:fill color="', e.color, '" opacity="', e.alpha * a.globalAlpha, '" />'))
  } function s(a, b, c) { a = a.m_; return { x: q * (b * a[0][0] + c * a[1][0] + a[2][0]) - r, y: q * (b * a[0][1] + c * a[1][1] + a[2][1]) - r } } function z(a, b, c) {
    isFinite(b[0][0]) && (isFinite(b[0][1]) && isFinite(b[1][0]) && isFinite(b[1][1]) && isFinite(b[2][0]) && isFinite(b[2][1])) && (a.m_ = b, c && (a.lineScale_ = aa(ba(b[0][0] * b[1][1] - b[0][1] *
      b[1][0]))))
  } function w(a) { this.type_ = a; this.r1_ = this.y1_ = this.x1_ = this.r0_ = this.y0_ = this.x0_ = 0; this.colors_ = [] } function I(a, b) { if (!a || 1 != a.nodeType || "IMG" != a.tagName) throw new A("TYPE_MISMATCH_ERR"); if ("complete" != a.readyState) throw new A("INVALID_STATE_ERR"); switch (b) { case "repeat": case null: case "": this.repetition_ = "repeat"; break; case "repeat-x": case "repeat-y": case "no-repeat": this.repetition_ = b; break; default: throw new A("SYNTAX_ERR"); }this.src_ = a.src; this.width_ = a.width; this.height_ = a.height }
  function A(a) { this.code = this[a]; this.message = a + ": DOM Exception " + this.code } var x = Math, k = x.round, J = x.sin, K = x.cos, ba = x.abs, aa = x.sqrt, q = 10, r = q / 2; navigator.userAgent.match(/MSIE ([\d.]+)?/); var M = Array.prototype.slice; O(document); var U = {
    init: function (a) { a = a || document; a.createElement("canvas"); a.attachEvent("onreadystatechange", W(this.init_, this, a)) }, init_: function (a) { a = a.getElementsByTagName("canvas"); for (var b = 0; b < a.length; b++)this.initElement(a[b]) }, initElement: function (a) {
      if (!a.getContext) {
        a.getContext =
          V; O(a.ownerDocument); a.innerHTML = ""; a.attachEvent("onpropertychange", X); a.attachEvent("onresize", Y); var b = a.attributes; b.width && b.width.specified ? a.style.width = b.width.nodeValue + "px" : a.width = a.clientWidth; b.height && b.height.specified ? a.style.height = b.height.nodeValue + "px" : a.height = a.clientHeight
      } return a
    }
  }; U.init(); for (var v = [], d = 0; 16 > d; d++)for (var B = 0; 16 > B; B++)v[16 * d + B] = d.toString(16) + B.toString(16); var Z = {
    aliceblue: "#F0F8FF", antiquewhite: "#FAEBD7", aquamarine: "#7FFFD4", azure: "#F0FFFF", beige: "#F5F5DC",
    bisque: "#FFE4C4", black: "#000000", blanchedalmond: "#FFEBCD", blueviolet: "#8A2BE2", brown: "#A52A2A", burlywood: "#DEB887", cadetblue: "#5F9EA0", chartreuse: "#7FFF00", chocolate: "#D2691E", coral: "#FF7F50", cornflowerblue: "#6495ED", cornsilk: "#FFF8DC", crimson: "#DC143C", cyan: "#00FFFF", darkblue: "#00008B", darkcyan: "#008B8B", darkgoldenrod: "#B8860B", darkgray: "#A9A9A9", darkgreen: "#006400", darkgrey: "#A9A9A9", darkkhaki: "#BDB76B", darkmagenta: "#8B008B", darkolivegreen: "#556B2F", darkorange: "#FF8C00", darkorchid: "#9932CC", darkred: "#8B0000",
    darksalmon: "#E9967A", darkseagreen: "#8FBC8F", darkslateblue: "#483D8B", darkslategray: "#2F4F4F", darkslategrey: "#2F4F4F", darkturquoise: "#00CED1", darkviolet: "#9400D3", deeppink: "#FF1493", deepskyblue: "#00BFFF", dimgray: "#696969", dimgrey: "#696969", dodgerblue: "#1E90FF", firebrick: "#B22222", floralwhite: "#FFFAF0", forestgreen: "#228B22", gainsboro: "#DCDCDC", ghostwhite: "#F8F8FF", gold: "#FFD700", goldenrod: "#DAA520", grey: "#808080", greenyellow: "#ADFF2F", honeydew: "#F0FFF0", hotpink: "#FF69B4", indianred: "#CD5C5C", indigo: "#4B0082",
    ivory: "#FFFFF0", khaki: "#F0E68C", lavender: "#E6E6FA", lavenderblush: "#FFF0F5", lawngreen: "#7CFC00", lemonchiffon: "#FFFACD", lightblue: "#ADD8E6", lightcoral: "#F08080", lightcyan: "#E0FFFF", lightgoldenrodyellow: "#FAFAD2", lightgreen: "#90EE90", lightgrey: "#D3D3D3", lightpink: "#FFB6C1", lightsalmon: "#FFA07A", lightseagreen: "#20B2AA", lightskyblue: "#87CEFA", lightslategray: "#778899", lightslategrey: "#778899", lightsteelblue: "#B0C4DE", lightyellow: "#FFFFE0", limegreen: "#32CD32", linen: "#FAF0E6", magenta: "#FF00FF", mediumaquamarine: "#66CDAA",
    mediumblue: "#0000CD", mediumorchid: "#BA55D3", mediumpurple: "#9370DB", mediumseagreen: "#3CB371", mediumslateblue: "#7B68EE", mediumspringgreen: "#00FA9A", mediumturquoise: "#48D1CC", mediumvioletred: "#C71585", midnightblue: "#191970", mintcream: "#F5FFFA", mistyrose: "#FFE4E1", moccasin: "#FFE4B5", navajowhite: "#FFDEAD", oldlace: "#FDF5E6", olivedrab: "#6B8E23", orange: "#FFA500", orangered: "#FF4500", orchid: "#DA70D6", palegoldenrod: "#EEE8AA", palegreen: "#98FB98", paleturquoise: "#AFEEEE", palevioletred: "#DB7093", papayawhip: "#FFEFD5",
    peachpuff: "#FFDAB9", peru: "#CD853F", pink: "#FFC0CB", plum: "#DDA0DD", powderblue: "#B0E0E6", rosybrown: "#BC8F8F", royalblue: "#4169E1", saddlebrown: "#8B4513", salmon: "#FA8072", sandybrown: "#F4A460", seagreen: "#2E8B57", seashell: "#FFF5EE", sienna: "#A0522D", skyblue: "#87CEEB", slateblue: "#6A5ACD", slategray: "#708090", slategrey: "#708090", snow: "#FFFAFA", springgreen: "#00FF7F", steelblue: "#4682B4", tan: "#D2B48C", thistle: "#D8BFD8", tomato: "#FF6347", turquoise: "#40E0D0", violet: "#EE82EE", wheat: "#F5DEB3", whitesmoke: "#F5F5F5", yellowgreen: "#9ACD32"
  },
    H = {}, L = {}, $ = { butt: "flat", round: "round" }, d = C.prototype; d.clearRect = function () { this.textMeasureEl_ && (this.textMeasureEl_.removeNode(!0), this.textMeasureEl_ = null); this.element_.innerHTML = "" }; d.beginPath = function () { this.currentPath_ = [] }; d.moveTo = function (a, b) { var c = s(this, a, b); this.currentPath_.push({ type: "moveTo", x: c.x, y: c.y }); this.currentX_ = c.x; this.currentY_ = c.y }; d.lineTo = function (a, b) { var c = s(this, a, b); this.currentPath_.push({ type: "lineTo", x: c.x, y: c.y }); this.currentX_ = c.x; this.currentY_ = c.y }; d.bezierCurveTo =
      function (a, b, c, g, e, f) { e = s(this, e, f); a = s(this, a, b); c = s(this, c, g); R(this, a, c, e) }; d.quadraticCurveTo = function (a, b, c, g) { a = s(this, a, b); c = s(this, c, g); g = { x: this.currentX_ + 2 / 3 * (a.x - this.currentX_), y: this.currentY_ + 2 / 3 * (a.y - this.currentY_) }; R(this, g, { x: g.x + (c.x - this.currentX_) / 3, y: g.y + (c.y - this.currentY_) / 3 }, c) }; d.arc = function (a, b, c, g, e, f) {
        c *= q; var d = f ? "at" : "wa", k = a + K(g) * c - r, n = b + J(g) * c - r; g = a + K(e) * c - r; e = b + J(e) * c - r; k != g || f || (k += 0.125); a = s(this, a, b); k = s(this, k, n); g = s(this, g, e); this.currentPath_.push({
          type: d,
          x: a.x, y: a.y, radius: c, xStart: k.x, yStart: k.y, xEnd: g.x, yEnd: g.y
        })
      }; d.rect = function (a, b, c, g) { this.moveTo(a, b); this.lineTo(a + c, b); this.lineTo(a + c, b + g); this.lineTo(a, b + g); this.closePath() }; d.strokeRect = function (a, b, c, g) { var e = this.currentPath_; this.beginPath(); this.moveTo(a, b); this.lineTo(a + c, b); this.lineTo(a + c, b + g); this.lineTo(a, b + g); this.closePath(); this.stroke(); this.currentPath_ = e }; d.fillRect = function (a, b, c, g) {
        var e = this.currentPath_; this.beginPath(); this.moveTo(a, b); this.lineTo(a + c, b); this.lineTo(a +
          c, b + g); this.lineTo(a, b + g); this.closePath(); this.fill(); this.currentPath_ = e
      }; d.createLinearGradient = function (a, b, c, g) { var e = new w("gradient"); e.x0_ = a; e.y0_ = b; e.x1_ = c; e.y1_ = g; return e }; d.createRadialGradient = function (a, b, c, g, e, f) { var d = new w("gradientradial"); d.x0_ = a; d.y0_ = b; d.r0_ = c; d.x1_ = g; d.y1_ = e; d.r1_ = f; return d }; d.drawImage = function (a, b) {
        var c, g, e, d, r, y, n, h; e = a.runtimeStyle.width; d = a.runtimeStyle.height; a.runtimeStyle.width = "auto"; a.runtimeStyle.height = "auto"; var l = a.width, u = a.height; a.runtimeStyle.width =
          e; a.runtimeStyle.height = d; if (3 == arguments.length) c = arguments[1], g = arguments[2], r = y = 0, n = e = l, h = d = u; else if (5 == arguments.length) c = arguments[1], g = arguments[2], e = arguments[3], d = arguments[4], r = y = 0, n = l, h = u; else if (9 == arguments.length) r = arguments[1], y = arguments[2], n = arguments[3], h = arguments[4], c = arguments[5], g = arguments[6], e = arguments[7], d = arguments[8]; else throw Error("Invalid number of arguments"); var m = s(this, c, g), p = []; p.push(" <g_vml_:group", ' coordsize="', 10 * q, ",", 10 * q, '"', ' coordorigin="0,0"', ' style="width:',
            10, "px;height:", 10, "px;position:absolute;"); if (1 != this.m_[0][0] || this.m_[0][1] || 1 != this.m_[1][1] || this.m_[1][0]) { var t = []; t.push("M11=", this.m_[0][0], ",", "M12=", this.m_[1][0], ",", "M21=", this.m_[0][1], ",", "M22=", this.m_[1][1], ",", "Dx=", k(m.x / q), ",", "Dy=", k(m.y / q), ""); var v = s(this, c + e, g), w = s(this, c, g + d); c = s(this, c + e, g + d); m.x = x.max(m.x, v.x, w.x, c.x); m.y = x.max(m.y, v.y, w.y, c.y); p.push("padding:0 ", k(m.x / q), "px ", k(m.y / q), "px 0;filter:progid:DXImageTransform.Microsoft.Matrix(", t.join(""), ", sizingmethod='clip');") } else p.push("top:",
              k(m.y / q), "px;left:", k(m.x / q), "px;"); p.push(' ">', '<g_vml_:image src="', a.src, '"', ' style="width:', q * e, "px;", " height:", q * d, 'px"', ' cropleft="', r / l, '"', ' croptop="', y / u, '"', ' cropright="', (l - r - n) / l, '"', ' cropbottom="', (u - y - h) / u, '"', " />", "</g_vml_:group>"); this.element_.insertAdjacentHTML("BeforeEnd", p.join(""))
      }; d.stroke = function (a) {
        var b = []; b.push("<g_vml_:shape", ' filled="', !!a, '"', ' style="position:absolute;width:', 10, "px;height:", 10, 'px;"', ' coordorigin="0,0"', ' coordsize="', 10 * q, ",", 10 * q, '"',
          ' stroked="', !a, '"', ' path="'); for (var c = { x: null, y: null }, d = { x: null, y: null }, e = 0; e < this.currentPath_.length; e++) {
            var f = this.currentPath_[e]; switch (f.type) {
              case "moveTo": b.push(" m ", k(f.x), ",", k(f.y)); break; case "lineTo": b.push(" l ", k(f.x), ",", k(f.y)); break; case "close": b.push(" x "); f = null; break; case "bezierCurveTo": b.push(" c ", k(f.cp1x), ",", k(f.cp1y), ",", k(f.cp2x), ",", k(f.cp2y), ",", k(f.x), ",", k(f.y)); break; case "at": case "wa": b.push(" ", f.type, " ", k(f.x - this.arcScaleX_ * f.radius), ",", k(f.y - this.arcScaleY_ *
                f.radius), " ", k(f.x + this.arcScaleX_ * f.radius), ",", k(f.y + this.arcScaleY_ * f.radius), " ", k(f.xStart), ",", k(f.yStart), " ", k(f.xEnd), ",", k(f.yEnd))
            }if (f) { if (null == c.x || f.x < c.x) c.x = f.x; if (null == d.x || f.x > d.x) d.x = f.x; if (null == c.y || f.y < c.y) c.y = f.y; if (null == d.y || f.y > d.y) d.y = f.y }
          } b.push(' ">'); a ? T(this, b, c, d) : S(this, b); b.push("</g_vml_:shape>"); this.element_.insertAdjacentHTML("beforeEnd", b.join(""))
      }; d.fill = function () { this.stroke(!0) }; d.closePath = function () { this.currentPath_.push({ type: "close" }) }; d.save = function () {
        var a =
          {}; P(this, a); this.aStack_.push(a); this.mStack_.push(this.m_); this.m_ = t(D(), this.m_)
      }; d.restore = function () { this.aStack_.length && (P(this.aStack_.pop(), this), this.m_ = this.mStack_.pop()) }; d.translate = function (a, b) { z(this, t([[1, 0, 0], [0, 1, 0], [a, b, 1]], this.m_), !1) }; d.rotate = function (a) { var b = K(a); a = J(a); z(this, t([[b, a, 0], [-a, b, 0], [0, 0, 1]], this.m_), !1) }; d.scale = function (a, b) { this.arcScaleX_ *= a; this.arcScaleY_ *= b; z(this, t([[a, 0, 0], [0, b, 0], [0, 0, 1]], this.m_), !0) }; d.transform = function (a, b, c, d, e, f) {
        z(this, t([[a,
          b, 0], [c, d, 0], [e, f, 1]], this.m_), !0)
      }; d.setTransform = function (a, b, c, d, e, f) { z(this, [[a, b, 0], [c, d, 0], [e, f, 1]], !0) }; d.drawText_ = function (a, b, c, d, e) {
        var f = this.m_; d = 0; var r = 1E3, t = 0, n = [], h; h = this.font; if (L[h]) h = L[h]; else { var l = document.createElement("div").style; try { l.font = h } catch (u) { } h = L[h] = { style: l.fontStyle || "normal", variant: l.fontVariant || "normal", weight: l.fontWeight || "normal", size: l.fontSize || 10, family: l.fontFamily || "sans-serif" } } var l = h, m = this.element_; h = {}; for (var p in l) h[p] = l[p]; p = parseFloat(m.currentStyle.fontSize);
        m = parseFloat(l.size); "number" == typeof l.size ? h.size = l.size : -1 != l.size.indexOf("px") ? h.size = m : -1 != l.size.indexOf("em") ? h.size = p * m : -1 != l.size.indexOf("%") ? h.size = p / 100 * m : -1 != l.size.indexOf("pt") ? h.size = m / 0.75 : h.size = p; h.size *= 0.981; p = h.style + " " + h.variant + " " + h.weight + " " + h.size + "px " + h.family; m = this.element_.currentStyle; l = this.textAlign.toLowerCase(); switch (l) {
          case "left": case "center": case "right": break; case "end": l = "ltr" == m.direction ? "right" : "left"; break; case "start": l = "rtl" == m.direction ? "right" :
            "left"; break; default: l = "left"
        }switch (this.textBaseline) { case "hanging": case "top": t = h.size / 1.75; break; case "middle": break; default: case null: case "alphabetic": case "ideographic": case "bottom": t = -h.size / 2.25 }switch (l) { case "right": d = 1E3; r = 0.05; break; case "center": d = r = 500 }b = s(this, b + 0, c + t); n.push('<g_vml_:line from="', -d, ' 0" to="', r, ' 0.05" ', ' coordsize="100 100" coordorigin="0 0"', ' filled="', !e, '" stroked="', !!e, '" style="position:absolute;width:1px;height:1px;">'); e ? S(this, n) : T(this, n, { x: -d, y: 0 },
          { x: r, y: h.size }); e = f[0][0].toFixed(3) + "," + f[1][0].toFixed(3) + "," + f[0][1].toFixed(3) + "," + f[1][1].toFixed(3) + ",0,0"; b = k(b.x / q) + "," + k(b.y / q); n.push('<g_vml_:skew on="t" matrix="', e, '" ', ' offset="', b, '" origin="', d, ' 0" />', '<g_vml_:path textpathok="true" />', '<g_vml_:textpath on="true" string="', N(a), '" style="v-text-align:', l, ";font:", N(p), '" /></g_vml_:line>'); this.element_.insertAdjacentHTML("beforeEnd", n.join(""))
      }; d.fillText = function (a, b, c, d) { this.drawText_(a, b, c, d, !1) }; d.strokeText = function (a,
        b, c, d) { this.drawText_(a, b, c, d, !0) }; d.measureText = function (a) { this.textMeasureEl_ || (this.element_.insertAdjacentHTML("beforeEnd", '<span style="position:absolute;top:-20000px;left:0;padding:0;margin:0;border:none;white-space:pre;"></span>'), this.textMeasureEl_ = this.element_.lastChild); var b = this.element_.ownerDocument; this.textMeasureEl_.innerHTML = ""; this.textMeasureEl_.style.font = this.font; this.textMeasureEl_.appendChild(b.createTextNode(a)); return { width: this.textMeasureEl_.offsetWidth } }; d.clip = function () { };
  d.arcTo = function () { }; d.createPattern = function (a, b) { return new I(a, b) }; w.prototype.addColorStop = function (a, b) { b = G(b); this.colors_.push({ offset: a, color: b.color, alpha: b.alpha }) }; d = A.prototype = Error(); d.INDEX_SIZE_ERR = 1; d.DOMSTRING_SIZE_ERR = 2; d.HIERARCHY_REQUEST_ERR = 3; d.WRONG_DOCUMENT_ERR = 4; d.INVALID_CHARACTER_ERR = 5; d.NO_DATA_ALLOWED_ERR = 6; d.NO_MODIFICATION_ALLOWED_ERR = 7; d.NOT_FOUND_ERR = 8; d.NOT_SUPPORTED_ERR = 9; d.INUSE_ATTRIBUTE_ERR = 10; d.INVALID_STATE_ERR = 11; d.SYNTAX_ERR = 12; d.INVALID_MODIFICATION_ERR =
    13; d.NAMESPACE_ERR = 14; d.INVALID_ACCESS_ERR = 15; d.VALIDATION_ERR = 16; d.TYPE_MISMATCH_ERR = 17; G_vmlCanvasManager = U; CanvasRenderingContext2D = C; CanvasGradient = w; CanvasPattern = I; DOMException = A
}();
/*eslint-enable*/
/*jshint ignore:end*/